From 9f6301d3a35a03fb654c4cb762ff40cab122be58 Mon Sep 17 00:00:00 2001
From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
Date: Mon, 28 Feb 2022 01:20:27 -0800
Subject: [PATCH] ath12k: 11be mumimo and ofdma stats support

Add support for 11be mumimo and ofdma stats.

Updated the htt_stats_type debugfs option to take more
than one arguments to test extended stats. Host needs to
pass additional arguments to htt stats command to request
ofdma specific stats

Fixed the testmode function to pass unit test commands

Example:
echo 9 > htt_stats_type and then reading htt_stats file,
retrieves pdev tx rate stats
echo 9 1 > htt_stats_type and then reading htt_stats file,
retrieves pdev tx ofdma specific rate stats

Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
Signed-off-by: Balamurugan Mahalingam <quic_bmahalin@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/core.h        |   3 +-
 drivers/net/wireless/ath/ath12k/debugfs.h     |  12 +-
 .../wireless/ath/ath12k/debugfs_htt_stats.c   | 836 +++++++++++++++++-
 .../wireless/ath/ath12k/debugfs_htt_stats.h   | 368 ++++++++
 drivers/net/wireless/ath/ath12k/testmode_i.h  |   2 +-
 5 files changed, 1212 insertions(+), 9 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -465,7 +465,8 @@ struct ath12k_fw_stats {
 };
 
 struct ath12k_dbg_htt_stats {
-	u8 type;
+	u32 type;
+	u32 cfg_param[4];
 	u8 reset;
 	struct debug_htt_stats_req *stats_req;
 	/* protects shared stats req buffer */
--- a/drivers/net/wireless/ath/ath12k/debugfs.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs.h
@@ -39,6 +39,14 @@ enum ath12k_dbg_htt_ext_stats_type {
 	ATH12K_DBG_HTT_EXT_STATS_TX_SOUNDING_INFO           =  22,
 	ATH12K_DBG_HTT_EXT_STATS_PDEV_OBSS_PD_STATS	    =  23,
 	ATH12K_DBG_HTT_EXT_STATS_RING_BACKPRESSURE_STATS    =  24,
+	ATH12K_DBG_HTT_EXT_STATS_LATENCY_PROF_STATS	    =  25,
+	ATH12K_DBG_HTT_EXT_STATS_PDEV_UL_TRIG_STATS	    =  26,
+	ATH12K_DBG_HTT_EXT_STATS_PDEV_UL_MUMIMO_TRIG_STATS  =  27,
+	ATH12K_DBG_HTT_EXT_STATS_FSE_RX			    =  28,
+	ATH12K_DBG_HTT_EXT_PEER_CTRL_PATH_TXRX_STATS	    =  29,
+	ATH12K_DBG_HTT_EXT_STATS_PDEV_RX_RATE_EXT	    =  30,
+	ATH12K_DBG_HTT_EXT_STATS_PDEV_TX_RATE_TXBF	    =  31,
+	ATH12K_DBG_HTT_EXT_STATS_TXBF_OFDMA		    =  32,
 
 	/* keep this last */
 	ATH12K_DBG_HTT_NUM_EXT_STATS,
@@ -46,8 +54,10 @@ enum ath12k_dbg_htt_ext_stats_type {
 
 struct debug_htt_stats_req {
 	bool done;
+	bool override_cfg_param;
 	u8 pdev_id;
-	u8 type;
+	u32 type;
+	u32 cfg_param[4];
 	u8 peer_addr[ETH_ALEN];
 	struct completion cmpln;
 	u32 buf_len;
--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
@@ -3896,6 +3896,758 @@ static inline void htt_print_backpressur
 	}
 }
 
+static inline void
+htt_print_tx_selfgen_be_stats_tlv(const void *tag_buf,
+				  struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_selfgen_be_stats_tlv *htt_stats_buf = tag_buf;
+	char str_buf[HTT_MAX_STRING_LEN] = {0};
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "HTT_TX_SELFGEN_BE_STATS_TLV:");
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_su_ndpa_queued = %u",
+			   htt_stats_buf->be_su_ndpa_queued);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_su_ndpa_tried = %u",
+			   htt_stats_buf->be_su_ndpa);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_su_ndp_queued = %u",
+			   htt_stats_buf->be_su_ndp_queued);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_su_ndp_tried = %u",
+			   htt_stats_buf->be_su_ndp);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndpa_queued = %u",
+			   htt_stats_buf->be_mu_mimo_ndpa_queued);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndpa_tried = %u",
+			   htt_stats_buf->be_mu_mimo_ndpa);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndp_queued = %u",
+			   htt_stats_buf->be_mu_mimo_ndp_queued);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndp_tried = %u",
+			   htt_stats_buf->be_mu_mimo_ndp);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_brpoll_queued,
+			HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS - 1);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_brpollX_queued = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_brpoll,
+			HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS - 1);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_brpollX_tried = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_ul_mumimo_trigger,
+			HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_ul_mumimo_trigger = %s ", str_buf);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_basic_trigger = %u",
+			htt_stats_buf->be_basic_trigger);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_ulmumimo_total_trigger = %u",
+			htt_stats_buf->be_ulmumimo_trigger);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_bsr_trigger = %u",
+			htt_stats_buf->be_bsr_trigger);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_mu_bar_trigger = %u",
+			htt_stats_buf->be_mu_bar_trigger);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_mu_rts_trigger = %u\n",
+			htt_stats_buf->be_mu_rts_trigger);
+
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_selfgen_be_sched_status_stats_tlv(const void *tag_buf,
+					       struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_selfgen_be_sched_status_stats_tlv *htt_stats_buf = tag_buf;
+	char str_buf[HTT_MAX_STRING_LEN] = {0};
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "HTT_TX_SELFGEN_BE_SCHED_STATUS_STATS_TLV:");
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_su_ndpa_sch_status,
+			HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_su_ndpa_sch_status = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_su_ndp_sch_status,
+			HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_su_ndp_sch_status = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_ndpa_sch_status,
+			HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndpa_sch_status = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_ndp_sch_status,
+			HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndp_sch_status = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_brp_sch_status,
+			HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_brp_sch_status = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_bar_sch_status,
+			HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_bar_sch_status = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_basic_trig_sch_status,
+			HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_basic_trig_sch_status = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_su_ndp_sch_flag_err,
+			HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_su_ndp_sch_flag_err = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_ndp_sch_flag_err,
+			HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndp_sch_flag_err = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_brp_sch_flag_err,
+			HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_brp_sch_flag_err = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_bar_sch_flag_err,
+			HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_bar_sch_flag_err = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_basic_trig_sch_flag_err,
+			HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_basic_trig_sch_flag_err = %s \n ", str_buf);
+
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_be_ul_mu_mimo_sch_stats_tlv(const void *tag_buf,
+					      struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_be_ul_mu_mimo_sch_stats_tlv *htt_stats_buf = tag_buf;
+	u8 i;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "\n11be UL MU_MIMO SCH STATS:");
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS; i++) {
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ul_mu_mimo_basic_sch_nusers_%u = %u", i,
+				   htt_stats_buf->be_ul_mu_mimo_basic_sch_nusers[i]);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ul_mu_mimo_brp_sch_nusers_%u = %u", i,
+				   htt_stats_buf->be_ul_mu_mimo_brp_sch_nusers[i]);
+	}
+
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_be_rate_stats_tlv(const void *tag_buf,
+				    struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_rate_stats_be_tlv *htt_stats_buf = tag_buf;
+	u8  i, j;
+	u16 index = 0;
+	char str_buf[HTT_MAX_STRING_LEN] = {0};
+	char *tx_gi[HTT_TX_PEER_STATS_NUM_GI_COUNTERS];
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++) {
+		tx_gi[i] = kmalloc(HTT_MAX_STRING_LEN, GFP_ATOMIC);
+		if (!tx_gi[i])
+			goto fail;
+	}
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "HTT_TX_PDEV_BE_RATE_STATS_TLV:");
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_mu_mimo_tx_ldpc = %u",
+			   htt_stats_buf->be_mu_mimo_tx_ldpc);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	/* MCS -2 and -1 will be printed first */
+	index = snprintf(&str_buf[index],
+		HTT_MAX_STRING_LEN - index,
+		" -2:%u,-1:%u,",
+		htt_stats_buf->be_mu_mimo_tx_mcs[HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS-2],
+		htt_stats_buf->be_mu_mimo_tx_mcs[HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS-1]);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_tx_mcs,
+			HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS-2);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_tx_mcs = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_tx_nss,
+			HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_tx_nss = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_tx_bw,
+			HTT_TX_PDEV_STATS_NUM_BE_BW_COUNTERS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_tx_bw = %s ", str_buf);
+
+	for (j = 0; j < HTT_TX_PDEV_STATS_NUM_GI_COUNTERS; j++) {
+		ARRAY_TO_STRING(tx_gi[j], htt_stats_buf->be_mu_mimo_tx_gi[j],
+				HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_mu_mimo_tx_gi[%u] = %s ", j, tx_gi[j]);
+	}
+
+
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+fail:
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++)
+		kfree(tx_gi[i]);
+
+}
+
+static inline void
+htt_print_be_ul_mimo_user_stats(const void *tag_buf,
+				struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_rx_pdev_be_ul_mimo_user_stats_tlv *htt_ul_user_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	if (htt_ul_user_stats_buf->user_index < HTT_RX_PDEV_MAX_ULMUMIMO_NUM_USER) {
+		if (htt_ul_user_stats_buf->user_index == 0)
+			len += HTT_DBG_OUT(buf + len, buf_len - len,
+					   "HTT_STATS_RX_PDEV_BE_UL_MIMO_USER_STATS_TLV");
+
+		len += HTT_DBG_OUT(buf + len, buf_len - len, "be_rx_ulmumimo_non_data_ppdu_%u = %u ",
+				htt_ul_user_stats_buf->user_index,
+				htt_ul_user_stats_buf->be_rx_ulmumimo_non_data_ppdu);
+		len += HTT_DBG_OUT(buf + len, buf_len - len, "be_rx_ulmumimo_data_ppdu_%u = %u ",
+				htt_ul_user_stats_buf->user_index,
+				htt_ul_user_stats_buf->be_rx_ulmumimo_data_ppdu);
+		len += HTT_DBG_OUT(buf + len, buf_len - len, "be_rx_ulmumimo_mpdu_ok_%u = %u ",
+				htt_ul_user_stats_buf->user_index,
+				htt_ul_user_stats_buf->be_rx_ulmumimo_mpdu_ok);
+		len += HTT_DBG_OUT(buf + len, buf_len - len, "be_rx_ulmumimo_mpdu_fail_%u = %u",
+				htt_ul_user_stats_buf->user_index,
+				htt_ul_user_stats_buf->be_rx_ulmumimo_mpdu_fail);
+	}
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_ul_mumimo_trig_be_stats(const void *tag_buf,
+				  struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_rx_pdev_ul_mumimo_trig_be_stats_tlv *htt_ul_mumimo_trig_be_stats_buf = tag_buf;
+	char str_buf[HTT_MAX_STRING_LEN];
+	char *rx_gi[HTT_RX_PDEV_STATS_NUM_GI_COUNTERS];
+	u8 i, j;
+	u16 index;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++) {
+		rx_gi[i] = kmalloc(HTT_MAX_STRING_LEN, GFP_ATOMIC);
+		if (!rx_gi[i])
+			goto fail;
+	}
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "HTT_RX_PDEV_UL_MUMIMO_TRIG_BE_STATS_TLV:");
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "mac_id = %lu",
+		FIELD_GET(HTT_STATS_MAC_ID, htt_ul_mumimo_trig_be_stats_buf->mac_id__word));
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "rx_11be_ul_mumimo = %u",
+			htt_ul_mumimo_trig_be_stats_buf->rx_11be_ul_mumimo);
+
+	/* TODO: Check if enough space is present before writing BE MCS Counters */
+	index = 0;
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	/* MCS -2 and -1 will be printed first */
+	index = snprintf(&str_buf[index],
+		HTT_MAX_STRING_LEN - index,
+		" -2:%u,-1:%u,",
+		htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_mcs[HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS-2],
+		htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_mcs[HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS-1]);
+
+	ARRAY_TO_STRING(&str_buf[index + 2], htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_mcs,
+			HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS - 2);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ul_mumimo_rx_mcs = %s ", str_buf);
+
+	for (j = 0; j < HTT_RX_PDEV_STATS_NUM_GI_COUNTERS; j++) {
+		index = 0;
+		memset(rx_gi[j], 0x0, HTT_MAX_STRING_LEN);
+		index = snprintf(&str_buf[index],
+			HTT_MAX_STRING_LEN - index,
+			" -2:%u,-1:%u,",
+			htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_gi[j][HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS-2],
+			htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_gi[j][HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS-1]);
+
+		ARRAY_TO_STRING(rx_gi[j],
+				htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_gi[j],
+				HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS-2);
+
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ul_mumimo_rx_gi[%u] = %s ", j, rx_gi[j]);
+	}
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf,
+			htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_nss,
+			HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_ul_mumimo_rx_nss = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf,
+			htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_bw,
+			HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_ul_mumimo_rx_bw = %s ", str_buf);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_ul_mumimo_rx_stbc = %u",
+			   htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_stbc);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_ul_mumimo_rx_ldpc = %u",
+			   htt_ul_mumimo_trig_be_stats_buf->be_ul_mumimo_rx_ldpc);
+
+	for (i = 0; i < HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS; i++) {
+		memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+		ARRAY_TO_STRING(str_buf,
+				htt_ul_mumimo_trig_be_stats_buf->be_rx_ul_mumimo_chain_rssi_in_dbm[i],
+				HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_rx_ul_mumimo_rssi_in_dbm: chain[%u] = %s ",
+				   i, str_buf);
+	}
+
+	for (i = 0; i < HTT_RX_PDEV_MAX_ULMUMIMO_NUM_USER; i++) {
+		memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+		ARRAY_TO_STRING(str_buf,
+				htt_ul_mumimo_trig_be_stats_buf->be_rx_ul_mumimo_target_rssi[i],
+				HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_rx_ul_mumimo_target_rssi: user[%u] = %s ",
+				   i, str_buf);
+	}
+
+	for (i = 0; i < HTT_RX_PDEV_MAX_ULMUMIMO_NUM_USER; i++) {
+		memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+		ARRAY_TO_STRING(str_buf,
+				htt_ul_mumimo_trig_be_stats_buf->be_rx_ul_mumimo_fd_rssi[i],
+				HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_rx_ul_mumimo_fd_rssi: user[%u] = %s ",
+				   i, str_buf);
+	}
+
+	for (i = 0; i < HTT_RX_PDEV_MAX_ULMUMIMO_NUM_USER; i++) {
+		memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+		ARRAY_TO_STRING(str_buf,
+				htt_ul_mumimo_trig_be_stats_buf->be_rx_ulmumimo_pilot_evm_dB_mean[i],
+				HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_rx_ulmumimo_pilot_evm_dB_mean: user [%u] = %s ",
+				   i, str_buf);
+	}
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "\n");
+
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+fail:
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++)
+		kfree(rx_gi[i]);
+}
+
+static inline void
+htt_print_be_ul_ofdma_trigger_stats(const void *tag_buf,
+				    struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_rx_pdev_be_ul_trigger_stats_tlv *htt_trigger_stats_buf = tag_buf;
+	char str_buf[HTT_MAX_STRING_LEN];
+	char   *rx_gi[HTT_RX_PDEV_STATS_NUM_GI_COUNTERS];
+	u8  i, j;
+	u16 index;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++) {
+		rx_gi[i] = kmalloc(HTT_MAX_STRING_LEN, GFP_ATOMIC);
+		if (!rx_gi[i])
+			goto fail;
+	}
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "HTT_RX_PDEV_BE_UL_TRIGGER_STATS_TLV:");
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "mac_id = %lu",
+			   FIELD_GET(HTT_STATS_MAC_ID, htt_trigger_stats_buf->mac_id__word));
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "rx_11be_ul_ofdma =%u",
+			   htt_trigger_stats_buf->rx_11be_ul_ofdma);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_trigger_stats_buf->be_ul_ofdma_rx_mcs,
+			HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ul_ofdma_rx_mcs = %s ",
+			   str_buf);
+
+	for (j = 0; j < HTT_RX_PDEV_STATS_NUM_GI_COUNTERS; j++) {
+		index = 0;
+		memset(rx_gi[j], 0x0, HTT_MAX_STRING_LEN);
+		for (i = 0; i < HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS; i++) {
+			index += snprintf(&rx_gi[j][index],
+					HTT_MAX_STRING_LEN - index,
+					" %u:%u,", i,
+					htt_trigger_stats_buf->be_ul_ofdma_rx_gi[j][i]);
+		}
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ul_ofdma_rx_gi[%u] = %s ", j, rx_gi[j]);
+	}
+
+	for (i = 0; i < HTT_RX_PDEV_STATS_NUM_GI_COUNTERS; i++)
+		kfree(rx_gi[i]);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_trigger_stats_buf->be_ul_ofdma_rx_nss,
+			 HTT_RX_PDEV_STATS_NUM_SPATIAL_STREAMS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ul_ofdma_rx_nss = %s ",
+			   str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_trigger_stats_buf->be_ul_ofdma_rx_bw,
+			HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ul_ofdma_rx_bw = %s ",
+			   str_buf);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ul_ofdma_rx_stbc = %u",
+			htt_trigger_stats_buf->be_ul_ofdma_rx_stbc);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ul_ofdma_rx_ldpc = %u",
+			htt_trigger_stats_buf->be_ul_ofdma_rx_ldpc);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf,
+			htt_trigger_stats_buf->be_rx_ulofdma_data_ru_size_ppdu,
+			HTT_RX_PDEV_STATS_NUM_BE_RU_SIZE_COUNTERS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_rx_ulofdma_data_ru_size_ppdu = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf,
+			htt_trigger_stats_buf->be_rx_ulofdma_non_data_ru_size_ppdu,
+			HTT_RX_PDEV_STATS_NUM_BE_RU_SIZE_COUNTERS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_rx_ulofdma_non_data_ru_size_ppdu = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_trigger_stats_buf->be_uplink_sta_aid,
+			HTT_RX_UL_MAX_UPLINK_RSSI_TRACK);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_rx_rssi_track_sta_aid = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf,
+			htt_trigger_stats_buf->be_uplink_sta_target_rssi,
+			HTT_RX_UL_MAX_UPLINK_RSSI_TRACK);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_rx_sta_target_rssi = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf,
+			htt_trigger_stats_buf->be_uplink_sta_fd_rssi,
+			HTT_RX_UL_MAX_UPLINK_RSSI_TRACK);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_rx_sta_fd_rssi = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf,
+			htt_trigger_stats_buf->be_uplink_sta_power_headroom,
+			HTT_RX_UL_MAX_UPLINK_RSSI_TRACK);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_rx_sta_power_headroom = %s ", str_buf);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "\n");
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+fail:
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++)
+		kfree(rx_gi[i]);
+}
+
+static inline void
+htt_print_tx_pdev_be_dl_mu_ofdma_sch_stats_tlv(const void *tag_buf,
+					       struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_be_dl_mu_ofdma_sch_stats_tlv *htt_stats_buf = tag_buf;
+	u8 i;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "\n11BE DL MU_OFDMA SCH STATS:");
+
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS; i++) {
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_mu_ofdma_sch_nusers_%u = %u", i,
+				   htt_stats_buf->be_mu_ofdma_sch_nusers[i]);
+	}
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_be_ul_mu_ofdma_sch_stats_tlv(const void *tag_buf,
+					       struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_be_ul_mu_ofdma_sch_stats_tlv *htt_stats_buf = tag_buf;
+	u8 i;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "\n11ax BE UL MU_OFDMA SCH STATS:");
+
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS; i++) {
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ul_mu_ofdma_basic_sch_nusers_%u = %u", i,
+				   htt_stats_buf->be_ul_mu_ofdma_basic_sch_nusers[i]);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ul_mu_ofdma_bsr_sch_nusers_%u = %u", i,
+				   htt_stats_buf->be_ul_mu_ofdma_bsr_sch_nusers[i]);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ul_mu_ofdma_bar_sch_nusers_%u = %u", i,
+				   htt_stats_buf->be_ul_mu_ofdma_bar_sch_nusers[i]);
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ul_mu_ofdma_brp_sch_nusers_%u = %u\n", i,
+				   htt_stats_buf-> be_ul_mu_ofdma_brp_sch_nusers[i]);
+	}
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_rate_stats_be_ofdma_tlv(const void *tag_buf,
+					  struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_rate_stats_be_ofdma_tlv *htt_stats_buf = tag_buf;
+	u8  i, j;
+	u16 index = 0;
+	char str_buf[HTT_MAX_STRING_LEN] = {0};
+	char *tx_gi[HTT_TX_PEER_STATS_NUM_GI_COUNTERS];
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++) {
+		tx_gi[i] = kmalloc(HTT_MAX_STRING_LEN, GFP_ATOMIC);
+		if (!tx_gi[i])
+			goto fail;
+	}
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "HTT_TX_PDEV_RATE_STATS_BE_OFDMA_TLV:");
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "mac_id = %u",
+			htt_stats_buf->mac_id__word & 0xFF);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ofdma_tx_ldpc = %u",
+			htt_stats_buf->be_ofdma_tx_ldpc);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_ofdma_tx_mcs,
+			HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ofdma_tx_mcs = %s ",
+			   str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_ofdma_tx_nss,
+			HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ofdma_tx_nss = %s ",
+			   str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_ofdma_tx_bw,
+			HTT_TX_PDEV_STATS_NUM_BW_COUNTERS);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_ofdma_tx_bw = %s ",
+			   str_buf);
+
+	for (j = 0; j < HTT_TX_PDEV_STATS_NUM_GI_COUNTERS; j++) {
+		index = 0;
+		for (i = 0; i < HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS; i++) {
+			index += snprintf(&tx_gi[j][index],
+					HTT_MAX_STRING_LEN - index,
+					" %u:%u,", i,
+					htt_stats_buf->be_ofdma_tx_gi[j][i]);
+		}
+		len += HTT_DBG_OUT(buf + len, buf_len - len,
+				   "be_ofdma_tx_gi[%u] = %s ", j, tx_gi[j]);
+	}
+
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++)
+		kfree(tx_gi[i]);
+
+	if (len >= buf_len)
+		buf[buf_len - 1] = 0;
+	else
+		buf[len] = 0;
+
+	stats_req->buf_len = len;
+fail:
+	for (i = 0; i < HTT_TX_PEER_STATS_NUM_GI_COUNTERS; i++)
+		kfree(tx_gi[i]);
+}
+
+static inline void
+htt_print_tx_selfgen_be_err_stats_tlv(const void *tag_buf,
+				      struct debug_htt_stats_req *stats_req)
+{
+	char str_buf[HTT_MAX_STRING_LEN] = {0};
+        u8 *buf = stats_req->buf;
+        u32 len = stats_req->buf_len;
+        u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	const struct htt_tx_selfgen_be_err_stats_tlv *htt_stats_buf = tag_buf;
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "HTT_TX_SELFGEN_BE_ERR_STATS_TLV:");
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_su_ndp_err = %u",
+			   htt_stats_buf->be_su_ndp_err);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_su_ndp_flushed = %u",
+			   htt_stats_buf->be_su_ndp_flushed);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_su_ndpa_err = %u",
+			   htt_stats_buf->be_su_ndpa_err);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_su_ndpa_flushed = %u",
+			   htt_stats_buf->be_su_ndpa_flushed);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_mu_mimo_ndpa_err = %u",
+			   htt_stats_buf->be_mu_mimo_ndpa_err);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndpa_flushed = %u",
+			   htt_stats_buf->be_mu_mimo_ndpa_flushed);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_mu_mimo_ndp_err = %u",
+			   htt_stats_buf->be_mu_mimo_ndp_err);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_ndp_flushed = %u",
+			   htt_stats_buf->be_mu_mimo_ndp_flushed);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_brp_err,
+	HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS - 1);
+	len += HTT_DBG_OUT(buf + len,
+			   buf_len - len, "be_mu_mimo_brpX_err = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_mu_mimo_brpoll_flushed,
+			HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS - 1);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_brpollX_flushed = %s ", str_buf);
+
+	ARRAY_TO_STRING(str_buf,
+			htt_stats_buf->be_mu_mimo_brp_err_num_cbf_received,
+			HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_mimo_num_cbf_rcvd_on_brp_err = %s ", str_buf);
+
+	memset(str_buf, 0x0, HTT_MAX_STRING_LEN);
+	ARRAY_TO_STRING(str_buf, htt_stats_buf->be_ul_mumimo_trigger_err,
+			HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_ul_mumimo_trigger_err = %s ", str_buf);
+
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_basic_trigger_err = %u",
+			   htt_stats_buf->be_basic_trigger_err);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_ulmumimo_total_trigger_err = %u",
+			   htt_stats_buf->be_ulmumimo_trigger_err);
+	len += HTT_DBG_OUT(buf + len, buf_len - len, "be_bsr_trigger_err = %u",
+			   htt_stats_buf->be_bsr_trigger_err);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_bar_trigger_err = %u",
+			   htt_stats_buf->be_mu_bar_trigger_err);
+	len += HTT_DBG_OUT(buf + len, buf_len - len,
+			   "be_mu_rts_trigger_err = %u\n",
+			   htt_stats_buf->be_mu_rts_trigger_err);
+}
+
 static int ath12k_dbg_htt_ext_stats_parse(struct ath12k_base *ab,
 					  u16 tag, u16 len, const void *tag_buf,
 					  void *user_data)
@@ -4247,6 +4999,50 @@ static int ath12k_dbg_htt_ext_stats_pars
 	case HTT_STATS_RING_BACKPRESSURE_STATS_TAG:
 		htt_print_backpressure_stats_tlv_v(tag_buf, user_data);
 		break;
+
+	case HTT_STATS_TX_PDEV_BE_DL_MU_OFDMA_STATS_TAG:
+		htt_print_tx_pdev_be_dl_mu_ofdma_sch_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_PDEV_BE_UL_MU_OFDMA_STATS_TAG:
+		htt_print_tx_pdev_be_ul_mu_ofdma_sch_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_PDEV_RATE_STATS_BE_OFDMA_TAG:
+		htt_print_tx_pdev_rate_stats_be_ofdma_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_RX_PDEV_UL_MUMIMO_TRIG_BE_STATS_TAG:
+		htt_print_ul_mumimo_trig_be_stats(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_SELFGEN_BE_STATS_TAG:
+		htt_print_tx_selfgen_be_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_SELFGEN_BE_ERR_STATS_TAG:
+		htt_print_tx_selfgen_be_err_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_SELFGEN_BE_SCHED_STATUS_STATS_TAG:
+		htt_print_tx_selfgen_be_sched_status_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_PDEV_BE_UL_MU_MIMO_STATS_TAG:
+		htt_print_tx_pdev_be_ul_mu_mimo_sch_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_RX_PDEV_BE_UL_MIMO_USER_STATS_TAG:
+		htt_print_be_ul_mimo_user_stats(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_RX_PDEV_BE_UL_TRIG_STATS_TAG:
+		htt_print_be_ul_ofdma_trigger_stats(tag_buf, stats_req);
+		break;
+	case HTT_STATS_TX_PDEV_BE_RATE_STATS_TAG:
+		htt_print_tx_pdev_be_rate_stats_tlv(tag_buf, stats_req);
+		break;
+
 	default:
 		break;
 	}
@@ -4324,12 +5120,23 @@ static ssize_t ath12k_write_htt_stats_ty
 					   size_t count, loff_t *ppos)
 {
 	struct ath12k *ar = file->private_data;
-	u8 type;
-	int ret;
+	u32 type;
+	unsigned int cfg_param[4] = {0};
+	int ret, num_args;
+	u8 *buf;
+
+	buf = vzalloc(count);
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, user_buf, count)) {
+		vfree(buf);
+		return -EFAULT;
+	}
 
-	ret = kstrtou8_from_user(user_buf, count, 0, &type);
-	if (ret)
-		return ret;
+	num_args = sscanf(buf, "%u %u %u %u %u\n", &type, &cfg_param[0],
+			  &cfg_param[1], &cfg_param[2], &cfg_param[3]);
+	vfree(buf);
 
 	if (type >= ATH12K_DBG_HTT_NUM_EXT_STATS)
 		return -E2BIG;
@@ -4339,9 +5146,12 @@ static ssize_t ath12k_write_htt_stats_ty
 		return -EPERM;
 
 	ar->debug.htt_stats.type = type;
+	ar->debug.htt_stats.cfg_param[0] = cfg_param[0];
+	ar->debug.htt_stats.cfg_param[1] = cfg_param[1];
+	ar->debug.htt_stats.cfg_param[2] = cfg_param[2];
+	ar->debug.htt_stats.cfg_param[3] = cfg_param[3];
 
 	ret = count;
-
 	return ret;
 }
 
@@ -4425,6 +5235,12 @@ int ath12k_debugfs_htt_stats_req(struct
 		ath12k_warn(ar->ab, "failed to set htt stats cfg params: %d\n", ret);
 		return ret;
 	}
+	if (stats_req->override_cfg_param) {
+		cfg_params.cfg0 = stats_req->cfg_param[0];
+		cfg_params.cfg1 = stats_req->cfg_param[1];
+		cfg_params.cfg2 = stats_req->cfg_param[2];
+		cfg_params.cfg3 = stats_req->cfg_param[3];
+	}
 
 	ret = ath12k_dp_tx_htt_h2t_ext_stats_req(ar, type, &cfg_params, cookie);
 	if (ret) {
@@ -4476,6 +5292,14 @@ static int ath12k_open_htt_stats(struct
 
 	ar->debug.htt_stats.stats_req = stats_req;
 	stats_req->type = type;
+	stats_req->cfg_param[0] = ar->debug.htt_stats.cfg_param[0];
+	stats_req->cfg_param[1] = ar->debug.htt_stats.cfg_param[1];
+	stats_req->cfg_param[2] = ar->debug.htt_stats.cfg_param[2];
+	stats_req->cfg_param[3] = ar->debug.htt_stats.cfg_param[3];
+	stats_req->override_cfg_param = !!stats_req->cfg_param[0] ||
+					!!stats_req->cfg_param[1] ||
+					!!stats_req->cfg_param[2] ||
+					!!stats_req->cfg_param[3];
 
 	ret = ath12k_debugfs_htt_stats_req(ar);
 	if (ret < 0)
--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
@@ -103,6 +103,20 @@ enum htt_tlv_tag_t {
 	HTT_STATS_PDEV_OBSS_PD_TAG                          = 88,
 	HTT_STATS_HW_WAR_TAG				    = 89,
 	HTT_STATS_RING_BACKPRESSURE_STATS_TAG		    = 90,
+	/* 11be stats */
+	HTT_STATS_TX_PDEV_BE_RATE_STATS_TAG		    = 131,
+	HTT_STATS_AST_ENTRY_TAG				    = 132,
+	HTT_STATS_TX_PDEV_BE_DL_MU_OFDMA_STATS_TAG	    = 133,
+	HTT_STATS_TX_PDEV_BE_UL_MU_OFDMA_STATS_TAG	    = 134,
+	HTT_STATS_TX_PDEV_RATE_STATS_BE_OFDMA_TAG	    = 135,
+	HTT_STATS_RX_PDEV_UL_MUMIMO_TRIG_BE_STATS_TAG	    = 136,
+	HTT_STATS_TX_SELFGEN_BE_ERR_STATS_TAG		    = 137,
+	HTT_STATS_TX_SELFGEN_BE_STATS_TAG		    = 138,
+	HTT_STATS_TX_SELFGEN_BE_SCHED_STATUS_STATS_TAG	    = 139,
+	HTT_STATS_TX_PDEV_BE_UL_MU_MIMO_STATS_TAG	    = 140,
+	HTT_STATS_RX_PDEV_BE_UL_MIMO_USER_STATS_TAG	    = 141,
+	HTT_STATS_RX_RING_STATS_TAG			    = 142,
+	HTT_STATS_RX_PDEV_BE_UL_TRIG_STATS_TAG		    = 143,
 
 	HTT_STATS_MAX_TAG,
 };
@@ -138,6 +152,8 @@ struct htt_stats_string_tlv {
 	u32 data[0]; /* Can be variable length */
 } __packed;
 
+#define HTT_STATS_MAC_ID	GENMASK(7, 0)
+
 /* == TX PDEV STATS == */
 struct htt_tx_pdev_stats_cmn_tlv {
 	u32 mac_id__word;
@@ -684,7 +700,10 @@ struct htt_tx_selfgen_ax_err_stats_tlv {
 /* == TX MU STATS == */
 #define HTT_TX_PDEV_STATS_NUM_AC_MUMIMO_USER_STATS 4
 #define HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS 8
+#define HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS 8
 #define HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS    74
+#define HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS 8
+#define HTT_STATS_MAX_MUMIMO_GRP_SZ 8
 
 struct htt_tx_pdev_mu_mimo_sch_stats_tlv {
 	/* mu-mimo sw sched cmd stats */
@@ -1150,6 +1169,64 @@ struct htt_sring_cmn_tlv {
 	(HTT_TX_PDEV_STATS_NUM_BW_COUNTERS * \
 	 HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS)
 
+#define HTT_TX_PDEV_STATS_NUM_MCS_DROP_COUNTERS \
+	(HTT_TX_PDEV_STATS_NUM_MCS_COUNTERS + \
+	 HTT_TX_PDEV_STATS_NUM_EXTRA_MCS_COUNTERS + \
+	 HTT_TX_PDEV_STATS_NUM_EXTRA2_MCS_COUNTERS)
+
+#define HTT_TX_PDEV_STATS_NUM_PER_COUNTERS 101
+
+/*
+ * Introduce new TX counters to support 320MHz support and punctured modes
+ */
+enum HTT_TX_PDEV_STATS_NUM_PUNCTURED_MODE_TYPE {
+	HTT_TX_PDEV_STATS_PUNCTURED_NONE = 0,
+	HTT_TX_PDEV_STATS_PUNCTURED_20 = 1,
+	HTT_TX_PDEV_STATS_PUNCTURED_40 = 2,
+	HTT_TX_PDEV_STATS_PUNCTURED_80 = 3,
+	HTT_TX_PDEV_STATS_PUNCTURED_120 = 4,
+	HTT_TX_PDEV_STATS_NUM_PUNCTURED_MODE_COUNTERS = 5
+};
+
+#define HTT_TX_PDEV_STATS_NUM_REDUCED_CHAN_TYPES 2 /* 0 - Half, 1 - Quarter */
+/* 11be related updates */
+#define HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS 16 /* 0...13,-2,-1 */
+#define HTT_TX_PDEV_STATS_NUM_BE_BW_COUNTERS  5  /* 20,40,80,160,320 MHz */
+
+#define HTT_TX_PDEV_STATS_NUM_HE_SIG_B_MCS_COUNTERS 6
+#define HTT_TX_PDEV_STATS_NUM_EHT_SIG_MCS_COUNTERS 4
+
+enum HTT_TX_PDEV_STATS_AX_RU_SIZE {
+	HTT_TX_PDEV_STATS_AX_RU_SIZE_26,
+	HTT_TX_PDEV_STATS_AX_RU_SIZE_52,
+	HTT_TX_PDEV_STATS_AX_RU_SIZE_106,
+	HTT_TX_PDEV_STATS_AX_RU_SIZE_242,
+	HTT_TX_PDEV_STATS_AX_RU_SIZE_484,
+	HTT_TX_PDEV_STATS_AX_RU_SIZE_996,
+	HTT_TX_PDEV_STATS_AX_RU_SIZE_996x2,
+	HTT_TX_PDEV_STATS_NUM_AX_RU_SIZE_COUNTERS,
+};
+
+enum HTT_TX_PDEV_STATS_BE_RU_SIZE {
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_26,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_52,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_52_26,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_106,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_106_26,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_242,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_484,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_484_242,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_996,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_996_484,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_996_484_242,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_996x2,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_996x2_484,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_996x3,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_996x3_484,
+	HTT_TX_PDEV_STATS_BE_RU_SIZE_996x4,
+	HTT_TX_PDEV_STATS_NUM_BE_RU_SIZE_COUNTERS,
+};
+
 struct htt_tx_pdev_rate_stats_tlv {
 	u32 mac_id__word;
 	u32 tx_ldpc;
@@ -1237,6 +1314,57 @@ struct htt_tx_pdev_rate_stats_tlv {
 #define HTT_RX_PDEV_MAX_OFDMA_NUM_USER             8
 #define HTT_RX_PDEV_STATS_RXEVM_MAX_PILOTS_PER_NSS 16
 
+#define HTT_RX_PDEV_STATS_NUM_EXTRA_MCS_COUNTERS 2 /* 12, 13 */
+#define HTT_RX_PDEV_STATS_NUM_EXTRA2_MCS_COUNTERS 2 /* 14, 15 */
+#define HTT_RX_PDEV_STATS_NUM_MCS_COUNTERS_EXT 14 /* 0-13 */
+#define HTT_RX_PDEV_STATS_TOTAL_BW_COUNTERS \
+    (HTT_RX_PDEV_STATS_NUM_BW_EXT_COUNTERS + HTT_RX_PDEV_STATS_NUM_BW_COUNTERS)
+#define HTT_RX_PDEV_STATS_NUM_BW_EXT2_COUNTERS 5 /* 20, 40, 80, 160, 320Mhz */
+#define HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS 8
+#define HTT_RX_PDEV_MAX_ULMUMIMO_NUM_USER 8
+#define HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS 16 /* 0-13, -2, -1 */
+#define HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS  5  /* 20,40,80,160,320 MHz */
+
+/* HTT_RX_PDEV_STATS_NUM_RU_SIZE_COUNTERS:
+ * RU size index 0: HTT_UL_OFDMA_V0_RU_SIZE_RU_26
+ * RU size index 1: HTT_UL_OFDMA_V0_RU_SIZE_RU_52
+ * RU size index 2: HTT_UL_OFDMA_V0_RU_SIZE_RU_106
+ * RU size index 3: HTT_UL_OFDMA_V0_RU_SIZE_RU_242
+ * RU size index 4: HTT_UL_OFDMA_V0_RU_SIZE_RU_484
+ * RU size index 5: HTT_UL_OFDMA_V0_RU_SIZE_RU_996
+ */
+#define HTT_RX_PDEV_STATS_NUM_RU_SIZE_COUNTERS 6
+/* HTT_RX_PDEV_STATS_NUM_RU_SIZE_160MHZ_CNTRS:
+ * RU size index 0: HTT_UL_OFDMA_V0_RU_SIZE_RU_26
+ * RU size index 1: HTT_UL_OFDMA_V0_RU_SIZE_RU_52
+ * RU size index 2: HTT_UL_OFDMA_V0_RU_SIZE_RU_106
+ * RU size index 3: HTT_UL_OFDMA_V0_RU_SIZE_RU_242
+ * RU size index 4: HTT_UL_OFDMA_V0_RU_SIZE_RU_484
+ * RU size index 5: HTT_UL_OFDMA_V0_RU_SIZE_RU_996
+ * RU size index 6: HTT_UL_OFDMA_V0_RU_SIZE_RU_996x2
+ */
+#define HTT_RX_PDEV_STATS_NUM_RU_SIZE_160MHZ_CNTRS 7 /* includes 996x2 */
+
+enum HTT_RX_PDEV_STATS_BE_RU_SIZE {
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_26,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_52,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_52_26,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_106,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_106_26,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_242,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_484,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_484_242,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_996,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_996_484,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_996_484_242,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_996x2,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_996x2_484,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_996x3,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_996x3_484,
+    HTT_RX_PDEV_STATS_BE_RU_SIZE_996x4,
+    HTT_RX_PDEV_STATS_NUM_BE_RU_SIZE_COUNTERS,
+};
+
 struct htt_rx_pdev_rate_stats_tlv {
 	u32 mac_id__word;
 	u32 nsts;
@@ -1686,6 +1814,246 @@ struct htt_ring_backpressure_stats_tlv {
 	u32 backpressure_hist[5];
 };
 
+/* 11BE STATS TLVs */
+enum htt_tx_err_status_t {
+	HTT_TXERR_NONE,
+	HTT_TXERR_RESP,	/* response timeout, mismatch,
+			 * BW mismatch, mimo ctrl mismatch,
+			 * CRC error.. */
+	HTT_TXERR_FILT,	/* blocked by tx filtering */
+	HTT_TXERR_FIFO,	/* fifo, misc errors in HW */
+	HTT_TXERR_SWABORT, /* software initialted abort (TX_ABORT) */
+
+	HTT_TXERR_RESERVED1,
+	HTT_TXERR_RESERVED2,
+	HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS = 7,
+
+	HTT_TXERR_INVALID = 0xff,
+};
+
+/* Matching enum for htt_tx_selfgen_sch_tsflag_error_stats */
+enum htt_tx_selfgen_sch_tsflag_error_stats {
+	HTT_TX_SELFGEN_SCH_TSFLAG_FLUSH_RCVD_ERR,
+	HTT_TX_SELFGEN_SCH_TSFLAG_FILT_SCHED_CMD_ERR,
+	HTT_TX_SELFGEN_SCH_TSFLAG_RESP_MISMATCH_ERR,
+	HTT_TX_SELFGEN_SCH_TSFLAG_RESP_CBF_MIMO_CTRL_MISMATCH_ERR,
+	HTT_TX_SELFGEN_SCH_TSFLAG_RESP_CBF_BW_MISMATCH_ERR,
+	HTT_TX_SELFGEN_SCH_TSFLAG_RETRY_COUNT_FAIL_ERR,
+	HTT_TX_SELFGEN_SCH_TSFLAG_RESP_TOO_LATE_RECEIVED_ERR,
+	HTT_TX_SELFGEN_SCH_TSFLAG_SIFS_STALL_NO_NEXT_CMD_ERR,
+
+	HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS = 8,
+	HTT_TX_SELFGEN_SCH_TSFLAG_ERROR_STATS_VALID = 8
+};
+
+enum htt_tx_mumimo_grp_invalid_reason_code_stats {
+	HTT_TX_MUMIMO_GRP_VALID,
+	HTT_TX_MUMIMO_GRP_INVALID_NUM_MU_USERS_EXCEEDED_MU_MAX_USERS,
+	HTT_TX_MUMIMO_GRP_INVALID_SCHED_ALGO_NOT_MU_COMPATIBLE_GID,
+	HTT_TX_MUMIMO_GRP_INVALID_NON_PRIMARY_GRP,
+	HTT_TX_MUMIMO_GRP_INVALID_ZERO_CANDIDATES,
+	HTT_TX_MUMIMO_GRP_INVALID_MORE_CANDIDATES,
+	HTT_TX_MUMIMO_GRP_INVALID_GROUP_SIZE_EXCEED_NSS,
+	HTT_TX_MUMIMO_GRP_INVALID_GROUP_INELIGIBLE,
+	HTT_TX_MUMIMO_GRP_INVALID,
+	HTT_TX_MUMIMO_GRP_INVALID_GROUP_EFF_MU_TPUT_OMBPS,
+	HTT_TX_MUMIMO_GRP_INVALID_MAX_REASON_CODE,
+};
+
+/* 0...13,-2,-1 */
+#define HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS 16
+/* 20,40,80,160,320 MHz */
+#define HTT_TX_PDEV_STATS_NUM_BE_BW_COUNTERS  5
+
+#define HTT_TX_PDEV_STATS_NUM_HE_SIG_B_MCS_COUNTERS 6
+#define HTT_TX_PDEV_STATS_NUM_EHT_SIG_MCS_COUNTERS 4
+
+struct htt_tx_selfgen_be_stats_tlv {
+	u32 be_su_ndpa;
+	u32 be_su_ndp;
+	u32 be_mu_mimo_ndpa;
+	u32 be_mu_mimo_ndp;
+	u32 be_mu_mimo_brpoll[HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS - 1];
+	u32 be_basic_trigger;
+	u32 be_bsr_trigger;
+	u32 be_mu_bar_trigger;
+	u32 be_mu_rts_trigger;
+	u32 be_ulmumimo_trigger;
+	u32 be_su_ndpa_queued;
+	u32 be_su_ndp_queued;
+	u32 be_mu_mimo_ndpa_queued;
+	u32 be_mu_mimo_ndp_queued;
+	u32 be_mu_mimo_brpoll_queued[HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS - 1];
+	u32 be_ul_mumimo_trigger[HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS];
+};
+
+struct htt_tx_selfgen_be_err_stats_tlv {
+	u32 be_su_ndp_err;
+	u32 be_su_ndpa_err;
+	u32 be_mu_mimo_ndpa_err;
+	u32 be_mu_mimo_ndp_err;
+	u32 be_mu_mimo_brp_err[HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS - 1];
+	u32 be_basic_trigger_err;
+	u32 be_bsr_trigger_err;
+	u32 be_mu_bar_trigger_err;
+	u32 be_mu_rts_trigger_err;
+	u32 be_ulmumimo_trigger_err;
+	u32 be_mu_mimo_brp_err_num_cbf_received[HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS];
+	u32 be_su_ndpa_flushed;
+	u32 be_su_ndp_flushed;
+	u32 be_mu_mimo_ndpa_flushed;
+	u32 be_mu_mimo_ndp_flushed;
+	u32 be_mu_mimo_brpoll_flushed[HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS - 1];
+	u32 be_ul_mumimo_trigger_err[HTT_TX_PDEV_STATS_NUM_BE_MUMIMO_USER_STATS];
+};
+
+struct htt_tx_selfgen_be_sched_status_stats_tlv {
+	u32 be_su_ndpa_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	u32 be_su_ndp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	u32 be_su_ndp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	u32 be_mu_mimo_ndpa_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	u32 be_mu_mimo_ndp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	u32 be_mu_mimo_ndp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	u32 be_mu_brp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	u32 be_mu_brp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	u32 be_mu_bar_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	u32 be_mu_bar_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	u32 be_basic_trig_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	u32 be_basic_trig_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	u32 be_ulmumimo_trig_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	u32 be_ulmumimo_trig_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+};
+
+struct htt_tx_pdev_be_dl_mu_ofdma_sch_stats_tlv {
+	u32 be_mu_ofdma_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+};
+
+struct htt_tx_pdev_be_ul_mu_ofdma_sch_stats_tlv {
+	u32 be_ul_mu_ofdma_basic_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+	u32 be_ul_mu_ofdma_bsr_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+	u32 be_ul_mu_ofdma_bar_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+	u32 be_ul_mu_ofdma_brp_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+};
+
+struct htt_tx_pdev_be_ul_mu_mimo_sch_stats_tlv {
+	u32 be_ul_mu_mimo_basic_sch_nusers[HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS];
+	u32 be_ul_mu_mimo_brp_sch_nusers[HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS];
+};
+
+struct htt_tx_pdev_rate_stats_be_tlv {
+	u32 be_mu_mimo_tx_mcs[HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS];
+	u32 be_mu_mimo_tx_nss[HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS];
+	u32 be_mu_mimo_tx_bw[HTT_TX_PDEV_STATS_NUM_BE_BW_COUNTERS];
+	u32 be_mu_mimo_tx_gi[HTT_TX_PDEV_STATS_NUM_GI_COUNTERS][HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS];
+	u32 be_mu_mimo_tx_ldpc;
+};
+
+struct htt_tx_pdev_rate_stats_be_ofdma_tlv {
+	u32 mac_id__word;
+	u32 be_ofdma_tx_ldpc;
+	u32 be_ofdma_tx_mcs[HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS];
+	u32 be_ofdma_tx_nss[HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS];
+	u32 be_ofdma_tx_bw[HTT_TX_PDEV_STATS_NUM_BE_BW_COUNTERS];
+	u32 be_ofdma_tx_gi[HTT_TX_PDEV_STATS_NUM_GI_COUNTERS][HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS];
+	u32 be_ofdma_tx_ru_size[HTT_TX_PDEV_STATS_NUM_BE_RU_SIZE_COUNTERS];
+	u32 be_ofdma_eht_sig_mcs[HTT_TX_PDEV_STATS_NUM_EHT_SIG_MCS_COUNTERS];
+};
+
+#define HTT_RX_UL_MAX_UPLINK_RSSI_TRACK 5
+struct htt_rx_pdev_be_ul_trigger_stats_tlv {
+	u32 mac_id__word;
+
+	u32 rx_11be_ul_ofdma;
+	u32 be_ul_ofdma_rx_mcs[HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS];
+	u32 be_ul_ofdma_rx_gi[HTT_RX_PDEV_STATS_NUM_GI_COUNTERS][HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS];
+	u32 be_ul_ofdma_rx_nss[HTT_RX_PDEV_STATS_NUM_SPATIAL_STREAMS];
+	u32 be_ul_ofdma_rx_bw[HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS];
+	u32 be_ul_ofdma_rx_stbc;
+	u32 be_ul_ofdma_rx_ldpc;
+
+	/*
+	 * These are arrays to hold the number of PPDUs that we received per RU.
+	 * E.g. PPDUs (data or non data) received in RU26 will be incremented in
+	 * array offset 0 and similarly RU52 will be incremented in array offset 1
+	 */
+	/* PPDU level */
+	u32 be_rx_ulofdma_data_ru_size_ppdu[HTT_RX_PDEV_STATS_NUM_BE_RU_SIZE_COUNTERS];
+	u32 be_rx_ulofdma_non_data_ru_size_ppdu[HTT_RX_PDEV_STATS_NUM_BE_RU_SIZE_COUNTERS];
+
+	/*
+	 * These arrays hold Target RSSI (rx power the AP wants),
+	 * FD RSSI (rx power the AP sees) & Power headroom values of STAs
+	 * which can be identified by AIDs, during trigger based RX.
+	 * Array acts a circular buffer and holds values for last 5 STAs
+	 * in the same order as RX.
+	 */
+	/*
+	 * STA AID array for identifying which STA the
+	 * Target-RSSI / FD-RSSI / pwr headroom stats are for
+	 */
+	u32 be_uplink_sta_aid[HTT_RX_UL_MAX_UPLINK_RSSI_TRACK];
+
+	/*
+	 * Trig Target RSSI for STA AID in same index - UNIT(dBm)
+	 */
+	s32 be_uplink_sta_target_rssi[HTT_RX_UL_MAX_UPLINK_RSSI_TRACK];
+
+	/*
+	 * Trig FD RSSI from STA AID in same index - UNIT(dBm)
+	 */
+	s32 be_uplink_sta_fd_rssi[HTT_RX_UL_MAX_UPLINK_RSSI_TRACK];
+
+	/*
+	 * Trig power headroom for STA AID in same idx - UNIT(dB)
+	 */
+	u32 be_uplink_sta_power_headroom[HTT_RX_UL_MAX_UPLINK_RSSI_TRACK];
+};
+
+struct htt_rx_pdev_be_ul_mimo_user_stats_tlv {
+	u32 user_index;
+	u32 be_rx_ulmumimo_non_data_ppdu;
+	u32 be_rx_ulmumimo_data_ppdu;
+	u32 be_rx_ulmumimo_mpdu_ok;
+	u32 be_rx_ulmumimo_mpdu_fail;
+};
+
+struct htt_rx_pdev_ul_mumimo_trig_be_stats_tlv {
+	u32 mac_id__word;
+
+	/* Number of times UL MUMIMO RX packets received */
+	u32 rx_11be_ul_mumimo;
+
+	/* 11BE EHT UL MU-MIMO RX TB PPDU MCS stats */
+	u32 be_ul_mumimo_rx_mcs[HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS];
+	/*
+	 * 11BE EHT UL MU-MIMO RX GI & LTF stats.
+	 * Index 0 indicates 1xLTF + 1.6 msec GI
+	 * Index 1 indicates 2xLTF + 1.6 msec GI
+	 * Index 2 indicates 4xLTF + 3.2 msec GI
+	 */
+	u32 be_ul_mumimo_rx_gi[HTT_RX_PDEV_STATS_NUM_GI_COUNTERS][HTT_RX_PDEV_STATS_NUM_BE_MCS_COUNTERS];
+	/*
+	 * 11BE EHT UL MU-MIMO RX TB PPDU NSS stats
+	 * (Increments the individual user NSS in the UL MU MIMO PPDU received)
+	 */
+	u32 be_ul_mumimo_rx_nss[HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS];
+	/* 11BE EHT UL MU-MIMO RX TB PPDU BW stats */
+	u32 be_ul_mumimo_rx_bw[HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS];
+	/* Number of times UL MUMIMO TB PPDUs received with STBC */
+	u32 be_ul_mumimo_rx_stbc;
+	/* Number of times UL MUMIMO TB PPDUs received with LDPC */
+	u32 be_ul_mumimo_rx_ldpc;
+
+	/* RSSI in dBm for Rx TB PPDUs */
+	s8 be_rx_ul_mumimo_chain_rssi_in_dbm[HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS][HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS];
+	/* Target RSSI programmed in UL MUMIMO triggers (units dBm) */
+	s8 be_rx_ul_mumimo_target_rssi[HTT_RX_PDEV_MAX_ULMUMIMO_NUM_USER][HTT_RX_PDEV_STATS_NUM_BE_BW_COUNTERS];
+	/* FD RSSI measured for Rx UL TB PPDUs (units dBm) */
+	s8 be_rx_ul_mumimo_fd_rssi[HTT_RX_PDEV_MAX_ULMUMIMO_NUM_USER][HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS];
+	/* Average pilot EVM measued for RX UL TB PPDU */
+	s8 be_rx_ulmumimo_pilot_evm_dB_mean[HTT_RX_PDEV_MAX_ULMUMIMO_NUM_USER][HTT_RX_PDEV_STATS_ULMUMIMO_NUM_SPATIAL_STREAMS];
+};
+
 #ifdef CPTCFG_ATH12K_DEBUGFS
 
 void ath12k_debugfs_htt_stats_init(struct ath12k *ar);
--- a/drivers/net/wireless/ath/ath12k/testmode_i.h
+++ b/drivers/net/wireless/ath/ath12k/testmode_i.h
@@ -47,5 +47,5 @@ enum ath12k_tm_cmd {
 	 * provided with ATH12K_TM_ATTR_WMI_CMDID and payload in
 	 * ATH12K_TM_ATTR_DATA.
 	 */
-	ATH12K_TM_CMD_WMI = 1,
+	ATH12K_TM_CMD_WMI = 3,
 };
