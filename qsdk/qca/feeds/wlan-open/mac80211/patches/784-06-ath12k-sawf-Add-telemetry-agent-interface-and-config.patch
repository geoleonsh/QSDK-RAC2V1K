From 89db6feadce880099794725e9a3a6415e28c683f Mon Sep 17 00:00:00 2001
From: Mahendran P <quic_mahep@quicinc.com>
Date: Thu, 1 Jun 2023 14:55:39 +0530
Subject: [PATCH] ath12k: sawf: Add telemetry agent interface and configuration

Add the telemetry agent interfaces which interacts with telemetry agent
module. These interfaces helps to configure and update the required
stats to the telemetry agent which will be processed by telemetry agent
and detect the breach and notifies the driver.

Signed-off-by: Mahendran P <quic_mahep@quicinc.com>
Signed-off-by: Nagarajan Maran <quic_nmaran@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/Makefile      |   3 +-
 drivers/net/wireless/ath/ath12k/sawf.c        |  12 +
 drivers/net/wireless/ath/ath12k/telemetry.c   |  27 +-
 .../ath/ath12k/telemetry_agent_app_if.h       | 193 +++++++++++
 .../wireless/ath/ath12k/telemetry_agent_if.c  | 308 ++++++++++++++++++
 .../wireless/ath/ath12k/telemetry_agent_if.h  |  76 +++++
 .../ath12k/telemetry_agent_wifi_driver_if.h   | 208 ++++++++++++
 7 files changed, 825 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/wireless/ath/ath12k/telemetry_agent_app_if.h
 create mode 100644 drivers/net/wireless/ath/ath12k/telemetry_agent_if.c
 create mode 100644 drivers/net/wireless/ath/ath12k/telemetry_agent_if.h
 create mode 100644 drivers/net/wireless/ath/ath12k/telemetry_agent_wifi_driver_if.h

--- a/drivers/net/wireless/ath/ath12k/sawf.c
+++ b/drivers/net/wireless/ath/ath12k/sawf.c
@@ -12,6 +12,8 @@
 #include "vendor.h"
 #include <linux/module.h>
 #include <qca-nss-ecm/ecm_classifier_emesh_public.h>
+#include "telemetry.h"
+#include "telemetry_agent_if.h"
 
 #define SVC_INDEX(svc_id) svc_id - 1
 #define DRV_TO_FW_SVC_ID(svc_id) (svc_id - 1)
@@ -126,6 +128,15 @@ void ath12k_update_svc_class(struct ath1
 	new_param->ul_max_latency = sawf_params->ul_max_latency;
 	new_param->ul_ofdma_disable = sawf_params->ul_ofdma_disable;
 	new_param->ul_mu_mimo_disable = sawf_params->ul_mu_mimo_disable;
+
+	ath12k_telemetry_set_svclass_cfg(true, new_param->svc_id,
+					 new_param->min_throughput_rate,
+					 new_param->max_throughput_rate,
+					 new_param->burst_size,
+					 new_param->service_interval,
+					 new_param->delay_bound,
+					 new_param->msdu_ttl,
+					 new_param->msdu_rate_loss);
 }
 
 bool ath12k_validate_sawf_param(struct ath12k_sawf_svc_params *params)
@@ -267,6 +278,15 @@ bool ath12k_disable_svc_class(u8 svc_id)
 	sawf_svc_class = &sawf_ctx->svc_classes[SVC_INDEX(svc_id)];
 	memset(sawf_svc_class, 0, sizeof(*sawf_svc_class));
 
+	ath12k_telemetry_set_svclass_cfg(false, svc_id,
+					 sawf_svc_class->min_throughput_rate,
+					 sawf_svc_class->max_throughput_rate,
+					 sawf_svc_class->burst_size,
+					 sawf_svc_class->service_interval,
+					 sawf_svc_class->delay_bound,
+					 sawf_svc_class->msdu_ttl,
+					 sawf_svc_class->msdu_rate_loss);
+
 	return true;
 }
 
@@ -519,8 +539,8 @@ u8 ath12k_sawf_get_msduq_of_tid(struct a
 {
 	struct ath12k_sawf_peer_ctx *peer_ctx = NULL;
 	struct ath12k_sawf_ctx *sawf_ctx;
-	u8 max_usr_def_q_sawf, def_msduq_max, q;
-	u8 msduq_id = SAWF_MSDUQ_ID_INVALID;
+	void *telemetry_peer_ctx = NULL;
+	u8 max_usr_def_q_sawf, def_msduq_max, q, msduq_id = SAWF_MSDUQ_ID_INVALID;
 
 	sawf_ctx = ath12k_get_sawf_context();
 	if (!sawf_ctx)
@@ -559,6 +579,22 @@ u8 ath12k_sawf_get_msduq_of_tid(struct a
 				ath12k_dbg(ab, ATH12K_DBG_SAWF,
 					   "New:msduq_id 0x%x:tid %u usrdefq %u\n",
 					   msduq_id, tid, q);
+
+				if (!peer_ctx->telemetry_peer_ctx) {
+					telemetry_peer_ctx =
+							ath12k_telemetry_peer_ctx_alloc(ab,
+											&peer->sawf_stats,
+											peer->addr,
+											svc_id,
+											(msduq_id - def_msduq_max));
+					if (telemetry_peer_ctx) {
+						peer_ctx->telemetry_peer_ctx = telemetry_peer_ctx;
+						ath12k_dbg(ab, ATH12K_DBG_SAWF,
+							   "telemetry peer ctx allocation"
+							   "with msduq_id:0x%x\n",
+							   msduq_id - def_msduq_max);
+					}
+				}
 				break;
 			}
 		}
@@ -571,11 +607,10 @@ u16 ath12k_sawf_alloc_msduq(struct ath12
 			    u8 svc_id,
 			    u16 peer_id)
 {
-	u8 msduq_id;
-	u8 svc_tid;
-	u16 ret_peer_msduq = SAWF_PEER_MSDUQ_INVALID;
 	struct ath12k_sawf_ctx *sawf_ctx;
 	struct ath12k_peer *peer;
+	u16 ret_peer_msduq = SAWF_PEER_MSDUQ_INVALID;
+	u8 svc_tid, msduq_id;
 
 	sawf_ctx = ath12k_get_sawf_context();
 	if (!sawf_ctx)
@@ -1396,8 +1431,9 @@ void ath12k_sawf_stats_update(struct ath
 	u64 entry_ts, enqueue_timestamp;
 	struct ath12k_base *ab = ar->ab;
 	struct sawf_tx_stats *tx_stats;
-	u32 msduq_id, len, q_id, tid;
-	u8 svc_id;
+	void *telemetry_peer_ctx;
+	u32 msduq_id, len, q_id, tid, num_pkts;
+	u8 svc_id, hostq_id;
 
 	if (!ts || !peer_ctx)
 		return;
@@ -1419,6 +1455,10 @@ void ath12k_sawf_stats_update(struct ath
 	tid = u32_get_bits(msduq_id, MSDUQID_TID_MASK);
 	q_id = u32_get_bits(msduq_id, MSDUQID_Q_MASK) - ab->default_msduq_per_tid;
 
+	hostq_id = msduq_id - (ab->default_msduq_per_tid * ATH12K_SAWF_MAX_TID_SUPPORT);
+	ath12k_telemetry_get_sla_num_pkts(&num_pkts);
+	telemetry_peer_ctx = peer->sawf_ctx_peer.telemetry_peer_ctx;
+
 	if (!(ath12k_debugfs_is_sawf_stats_enabled(ar) & ATH12K_SAWF_STATS_BASIC))
 		goto latency_stats_update;
 
@@ -1465,6 +1505,13 @@ void ath12k_sawf_stats_update(struct ath
 
 	tx_stats->queue_depth--;
 
+	if ((!((tx_stats->tx_success.num_pkts + tx_stats->tx_failed) % num_pkts)) &&
+	    telemetry_peer_ctx)
+		ath12k_telemetry_update_msdu_drop(telemetry_peer_ctx, tid, hostq_id,
+						  tx_stats->tx_success.num_pkts,
+						  tx_stats->tx_failed,
+						  tx_stats->dropped.age_out);
+
 latency_stats_update:
 
 	tx_delay_stats = &sawf_stats->tx_delay_stats[tid][q_id];
@@ -1488,6 +1535,7 @@ latency_stats_update:
 		sw_delay = (u32) (enqueue_timestamp - entry_ts);
 	tx_delay_stats->swdelay_win_total += sw_delay;
 
+	ath12k_telemetry_get_sla_mov_avg_num_pkt(&pkt_win);
 	if (!(tx_delay_stats->num_pkt % pkt_win)) {
 		tx_delay_stats->nwdelay_avg = div_u64(tx_delay_stats->nwdelay_win_total,
 					  pkt_win);
@@ -1496,6 +1544,12 @@ latency_stats_update:
 		tx_delay_stats->hwdelay_avg = div_u64(tx_delay_stats->hwdelay_win_total,
 					  pkt_win);
 
+		if (telemetry_peer_ctx)
+			ath12k_telemetry_update_delay_mvng(telemetry_peer_ctx,
+							   tid, hostq_id,
+							   tx_delay_stats->nwdelay_avg,
+							   tx_delay_stats->swdelay_avg,
+							   tx_delay_stats->hwdelay_avg);
 		tx_delay_stats->nwdelay_win_total = 0;
 		tx_delay_stats->swdelay_win_total = 0;
 		tx_delay_stats->hwdelay_win_total = 0;
@@ -1510,6 +1564,12 @@ latency_stats_update:
 			tx_delay_stats->failure++;
 		else
 			tx_delay_stats->success++;
+
+		if (!(tx_delay_stats->num_pkt % num_pkts) && telemetry_peer_ctx)
+			ath12k_telemetry_update_delay(telemetry_peer_ctx,
+						      tid, hostq_id,
+						      tx_delay_stats->success,
+						      tx_delay_stats->failure);
 	}
 	return;
 }
@@ -1579,19 +1639,21 @@ static void ath12k_copy_tx_stats(struct
 	dst->tx_failed = src->tx_failed;
 	dst->queue_depth = src->queue_depth;
 
-	dst->throughput = src->throughput = 0;
-	dst->ingress_rate = src->ingress_rate = 0;
+	dst->throughput = src->throughput;
+	dst->ingress_rate = src->ingress_rate;
 }
 
 static int ath12k_telemetry_get_txstats(struct telemetry_sawftx_stats *tx_stats,
 					struct ath12k_base *ab,
 					u8 *peer_mac, u8 svc_id)
 {
-	struct ath12k_sawf_stats *sawf_stats;
+	struct ath12k_sawf_stats *sawf_stats = NULL;
 	struct sawf_tx_stats *stats;
 	struct telemetry_sawf_tx_stat *tx;
 	struct ath12k_peer *peer = NULL;
+	struct ath12k_sawf_peer_ctx *peer_ctx = NULL;
 	int ret = 0;
+	u32 throughput = 0, ingress_rate = 0, msduq = 0;
 	u8 sawf_max_user_queues;
 
 	sawf_max_user_queues = sawf_ctx->max_msduq_per_tid - sawf_ctx->default_msduq_per_tid;
@@ -1602,6 +1664,12 @@ static int ath12k_telemetry_get_txstats(
 		goto end_stats;
 	}
 
+	peer_ctx = &peer->sawf_ctx_peer;
+	if (!peer_ctx) {
+		ret = -ENODATA;
+		goto end_stats;
+	}
+
 	sawf_stats = &peer->sawf_stats;
 	if(!sawf_stats) {
 		ret = -ENODATA;
@@ -1614,6 +1682,17 @@ static int ath12k_telemetry_get_txstats(
 			for (q_idx = 0; q_idx < sawf_max_user_queues; q_idx++) {
 				stats = &sawf_stats->tx_stats[tid][q_idx];
 				tx = &tx_stats->tx[tid][q_idx];
+				if (peer_ctx->telemetry_peer_ctx) {
+					msduq = u16_encode_bits(q_idx, MSDUQID_Q_MASK) |
+						u16_encode_bits(tid, MSDUQID_TID_MASK);
+					ath12k_telemetry_get_rate(peer_ctx->telemetry_peer_ctx,
+								  tid, msduq,
+								  &throughput,
+								  &ingress_rate);
+					msduq = 0;
+				}
+				stats->throughput = throughput;
+				stats->ingress_rate = ingress_rate;
 				ath12k_copy_tx_stats(stats, tx);
 			}
 		}
@@ -1625,6 +1704,14 @@ static int ath12k_telemetry_get_txstats(
 		}
 		stats = &sawf_stats->tx_stats[tid][q_id];
 		tx = &tx_stats->tx[0][0];
+		if (peer_ctx->telemetry_peer_ctx) {
+			msduq = u16_encode_bits(q_id, MSDUQID_Q_MASK) |
+				u16_encode_bits(tid, MSDUQID_TID_MASK);
+			ath12k_telemetry_get_rate(peer_ctx->telemetry_peer_ctx, tid, msduq,
+						  &throughput, &ingress_rate);
+		}
+		stats->throughput = throughput;
+		stats->ingress_rate = ingress_rate;
 		ath12k_copy_tx_stats(stats, tx);
 		tx_stats->tid = tid;
 		tx_stats->msduq = q_id;
@@ -1648,9 +1735,9 @@ static void ath12k_copy_delay_stats(stru
 	dst_hist_stats->max = src_hist_stats->max;
 	dst_hist_stats->avg = src_hist_stats->avg;
 
-	dst->nwdelay_avg = src->nwdelay_avg = 0;
-	dst->swdelay_avg = src->swdelay_avg = 0;
-	dst->hwdelay_avg = src->hwdelay_avg = 0;
+	dst->nwdelay_avg = src->nwdelay_avg;
+	dst->swdelay_avg = src->swdelay_avg;
+	dst->hwdelay_avg = src->hwdelay_avg;
 	dst->delay_bound_success = src->success;
 	dst->delay_bound_failure = src->failure;
 }
@@ -1663,7 +1750,9 @@ static int ath12k_telemetry_get_delaysta
 	struct sawf_tx_delay_stats *stats;
 	struct telemetry_sawf_delay_stat *delay;
 	struct ath12k_peer *peer;
+	struct ath12k_sawf_peer_ctx *peer_ctx = NULL;
 	int ret = 0;
+	u32 nwdelay_avg = 0, swdelay_avg = 0, hwdelay_avg = 0, msduq = 0;
 	u8 sawf_max_user_queues;
 
 	sawf_max_user_queues = sawf_ctx->max_msduq_per_tid - sawf_ctx->default_msduq_per_tid;
@@ -1680,12 +1769,29 @@ static int ath12k_telemetry_get_delaysta
 		goto end_stats;
 	}
 
+	peer_ctx = &peer->sawf_ctx_peer;
+	if (!peer_ctx) {
+		ret = -ENODATA;
+		goto end_stats;
+	}
+
 	if (svc_id == 0) {
 		int tid, q_idx;
 		for (tid = 0; tid < ATH12K_SAWF_MAX_TID_SUPPORT; tid++) {
 			for (q_idx = 0; q_idx < sawf_max_user_queues; q_idx++) {
 				stats = &sawf_stats->tx_delay_stats[tid][q_idx];
 				delay = &delay_stats->delay[tid][q_idx];
+				if (peer_ctx->telemetry_peer_ctx) {
+					msduq = u16_encode_bits(q_idx, MSDUQID_Q_MASK) |
+						u16_encode_bits(tid, MSDUQID_TID_MASK);
+					ath12k_telemetry_get_mov_avg(peer_ctx->telemetry_peer_ctx,
+								     tid, msduq, &nwdelay_avg,
+								     &swdelay_avg, &hwdelay_avg);
+					msduq = 0;
+				}
+				stats->nwdelay_avg = nwdelay_avg;
+				stats->swdelay_avg = swdelay_avg;
+				stats->hwdelay_avg = hwdelay_avg;
 				ath12k_copy_delay_stats(stats, delay);
 			}
 		}
@@ -1699,6 +1805,16 @@ static int ath12k_telemetry_get_delaysta
 
 		stats = &sawf_stats->tx_delay_stats[tid][q_id];
 		delay = &delay_stats->delay[0][0];
+		if (peer_ctx->telemetry_peer_ctx) {
+			msduq = u16_encode_bits(q_id, MSDUQID_Q_MASK) |
+				u16_encode_bits(tid, MSDUQID_TID_MASK);
+			ath12k_telemetry_get_mov_avg(peer_ctx->telemetry_peer_ctx,
+						     tid, msduq, &nwdelay_avg,
+						     &swdelay_avg, &hwdelay_avg);
+		}
+		stats->nwdelay_avg = nwdelay_avg;
+		stats->swdelay_avg = swdelay_avg;
+		stats->hwdelay_avg = hwdelay_avg;
 		ath12k_copy_delay_stats(stats, delay);
 		delay_stats->tid = tid;
 		delay_stats->msduq = q_id;
@@ -1745,3 +1861,156 @@ int telemetry_extract_data(struct stats_
 
 	return ret;
 }
+
+int ath12k_telemetry_sla_reset_stats(u8 svc_id, u8 *peer_mac, u8 *mld_mac_addr,
+				     u8 set_clear)
+{
+	return ath12k_telemetry_reset_peer_stats(peer_mac);
+}
+
+int ath12k_telemetry_get_sawf_tx_stats_tput(void *ptr, void *stats, u64 *in_bytes,
+					    u64 *in_cnt, u64 *tx_bytes,
+					    u64 *tx_cnt, u8 tid_v, u8 msduq_id)
+{
+	struct ath12k_base *ab = (struct ath12k_base *)ptr;
+	struct ath12k_sawf_stats *sawf_stats = (struct ath12k_sawf_stats *)stats;
+	struct sawf_tx_stats *tx_stats = NULL;
+	int ret = 0;
+	u8 tid, q_id, sawf_max_q_per_tid;
+
+	if (!ab && !sawf_stats)
+		return -ENODATA;
+
+	spin_lock_bh(&ab->base_lock);
+
+	tid = u8_get_bits(msduq_id, MSDUQID_TID_MASK);
+	q_id = u8_get_bits(msduq_id, MSDUQID_Q_MASK);
+
+	sawf_max_q_per_tid = ab->max_msduq_per_tid - ab->default_msduq_per_tid;
+
+	if (q_id > sawf_max_q_per_tid) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	tx_stats = &sawf_stats->tx_stats[tid][q_id];
+	if (!tx_stats) {
+		ret = -ENOENT;
+		goto end;
+	}
+
+	*in_bytes = tx_stats->tx_ingress.bytes;
+	*in_cnt = tx_stats->tx_ingress.num_pkts;
+	*tx_bytes = tx_stats->tx_success.bytes;
+	*tx_cnt = tx_stats->tx_success.num_pkts;
+end:
+	spin_unlock_bh(&ab->base_lock);
+	return ret;
+}
+
+int ath12k_telemetry_get_sawf_tx_stats_mpdu(void *ptr, void *stats, u64 *svc_int_pass,
+					    u64 *svc_int_fail, u64 *burst_pass,
+					    u64 *burst_fail, u8 tid_v, u8 msduq_id)
+{
+	struct ath12k_base *ab = (struct ath12k_base *)ptr;
+	struct ath12k_sawf_stats *sawf_stats = (struct ath12k_sawf_stats *)stats;
+	struct sawf_tx_stats *tx_stats = NULL;
+	int ret = 0;
+	u8 tid, q_id, sawf_max_q_per_tid;
+
+	if (!ab && !sawf_stats)
+		return -ENODATA;
+
+	spin_lock_bh(&ab->base_lock);
+
+	tid = u8_get_bits(msduq_id, MSDUQID_TID_MASK);
+	q_id = u8_get_bits(msduq_id, MSDUQID_Q_MASK);
+
+	sawf_max_q_per_tid = ab->max_msduq_per_tid - ab->default_msduq_per_tid;
+
+	if (q_id > sawf_max_q_per_tid) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	tx_stats = &sawf_stats->tx_stats[tid][q_id];
+	if (!tx_stats) {
+		ret = -ENOENT;
+		goto end;
+	}
+
+	*svc_int_pass = tx_stats->svc_intval_stats.success_cnt;
+	*svc_int_fail = tx_stats->svc_intval_stats.failure_cnt;
+	*burst_pass = tx_stats->burst_size_stats.success_cnt;
+	*burst_fail = tx_stats->burst_size_stats.failure_cnt;
+end:
+	spin_unlock_bh(&ab->base_lock);
+	return ret;
+}
+
+int ath12k_telemetry_get_sawf_tx_stats_drop(void *ptr, void *stats, u64 *pass,
+					    u64 *drop, u64 *drop_ttl,
+					    u8 tid_v, u8 msduq_id)
+{
+	struct ath12k_base *ab = (struct ath12k_base *)ptr;
+	struct ath12k_sawf_stats *sawf_stats = (struct ath12k_sawf_stats *)stats;
+	struct sawf_tx_stats *tx_stats = NULL;
+	int ret = 0;
+	u8 tid, q_id, sawf_max_q_per_tid;
+
+	if (!ab && !sawf_stats)
+		return -ENODATA;
+
+	spin_lock_bh(&ab->base_lock);
+
+	tid = u8_get_bits(msduq_id, MSDUQID_TID_MASK);
+	q_id = u8_get_bits(msduq_id, MSDUQID_Q_MASK);
+
+	sawf_max_q_per_tid = ab->max_msduq_per_tid - ab->default_msduq_per_tid;
+
+	if (q_id > sawf_max_q_per_tid) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	tx_stats = &sawf_stats->tx_stats[tid][q_id];
+	if (!tx_stats) {
+		ret = -ENOENT;
+		goto end;
+	}
+
+	*pass = tx_stats->tx_success.num_pkts;
+	*drop = tx_stats->tx_failed;
+	*drop_ttl = tx_stats->dropped.age_out;
+end:
+	spin_unlock_bh(&ab->base_lock);
+	return ret;
+}
+
+void ath12k_telemetry_notify_breach(u8 *mac_addr, u8 svc_id, u8 param,
+				    bool set_clear, u8 tid)
+{
+	struct ieee80211_vif *vif = NULL;
+	struct ath12k_base *ab = NULL;
+	struct ath12k_peer *peer = NULL;
+	u8 *mld_addr;
+
+	if (!mac_addr)
+		return;
+
+	peer = (struct ath12k_peer *)ath12k_get_ab_nd_peer_from_peer_mac(mac_addr, ab);
+	if (peer && ab) {
+		spin_lock_bh(&ab->base_lock);
+		vif = peer->vif;
+		if (peer->peer_id & ATH12K_ML_PEER_ID_VALID)
+			mld_addr = peer->ml_addr;
+		spin_unlock_bh(&ab->base_lock);
+		ath12k_vendor_telemetry_notify_breach(vif, mac_addr, svc_id, param,
+						      set_clear, tid, mld_addr);
+	} else {
+		ath12k_dbg(NULL, ATH12K_DBG_SAWF, "Peer(%s) not found for notifying breach",
+			   mac_addr);
+	}
+
+	return;
+}
--- a/drivers/net/wireless/ath/ath12k/telemetry.c
+++ b/drivers/net/wireless/ath/ath12k/telemetry.c
@@ -9,7 +9,8 @@
 #include "vendor.h"
 #include "telemetry.h"
 #include <linux/module.h>
-
+#include "telemetry_agent_if.h"
+#include "telemetry_agent_wifi_driver_if.h"
 
 #define MIN_THERSHOLD_PERCENTAGE 0
 #define MAX_THERSHOLD_PERCENTAGE 100
@@ -73,6 +74,12 @@ int ath12k_telemetry_sawf_sla_samples_co
 	telemetry_param->sla_num_pkt = param.sla_num_pkt;
 	telemetry_param->sla_time_sec = param.sla_time_sec;
 
+	ath12k_telemetry_set_mov_avg_params(telemetry_param->moving_avg_pkt,
+					    telemetry_param->moving_avg_win);
+
+	ath12k_telemetry_set_sla_params(telemetry_param->sla_num_pkt,
+					telemetry_param->sla_time_sec);
+
 	ath12k_info(NULL, "telemetry sla samples configuration done, "
 		    "movavgpkt:%d movavgwin:%d slanumpkt:%d slatimesec:%d \n",
 		    telemetry_param->moving_avg_pkt,telemetry_param->moving_avg_win,
@@ -114,6 +121,15 @@ int ath12k_telemetry_sawf_sla_thershold_
 	sla_thershold_param->msdu_ttl = param.msdu_ttl;
 	sla_thershold_param->msdu_rate_loss = param.msdu_rate_loss;
 
+	ath12k_telemetry_set_sla_cfg(sla_thershold_param->svc_id,
+				     sla_thershold_param->min_throughput_rate,
+				     sla_thershold_param->max_throughput_rate,
+				     sla_thershold_param->burst_size,
+				     sla_thershold_param->service_interval,
+				     sla_thershold_param->delay_bound,
+				     sla_thershold_param->msdu_ttl,
+				     sla_thershold_param->msdu_rate_loss);
+
 	ath12k_info(NULL, "telemetry sla thershold configuration done, "
 		    "svcid: %d MinThrRate:%d MaxThrRate:%d BurstSize:%d "
 		    "serviceInt:%d \n DelayBound: %d MsduTtl:%d "
@@ -172,6 +188,15 @@ int ath12k_telemetry_sawf_sla_detection_
 	telemetry_param->msdu_ttl = param.msdu_ttl;
 	telemetry_param->msdu_rate_loss = param.msdu_rate_loss;
 
+	ath12k_telemetry_set_sla_detect_cfg(telemetry_param->sla_detect,
+					    telemetry_param->min_throughput_rate,
+					    telemetry_param->max_throughput_rate,
+					    telemetry_param->burst_size,
+					    telemetry_param->service_interval,
+					    telemetry_param->delay_bound,
+					    telemetry_param->msdu_ttl,
+					    telemetry_param->msdu_rate_loss);
+
 	ath12k_info(NULL, "telemetry sla detection configuration done, detect option: %d "
 		   "MinThrRate:%d MaxThrRate:%d BurstSize:%d ServiceInt:%d \n DelayBound: %d "
 		   "MsduTtl:%d MsduRateLoss:%d \n", telemetry_param->sla_detect,
@@ -182,3 +207,25 @@ int ath12k_telemetry_sawf_sla_detection_
 
 	return ret;
 }
+
+bool ath12k_telemetry_get_sla_mov_avg_num_pkt(u32 *mov_avg)
+{
+	if (!telemetry_ctx) {
+		mov_avg = 1;
+		return false;
+	}
+
+	*mov_avg = telemetry_ctx->sla_samples_params.moving_avg_pkt;
+	return true;
+}
+
+bool ath12k_telemetry_get_sla_num_pkts(u32 *pkt_num)
+{
+	if (!telemetry_ctx) {
+		pkt_num = 1;
+		return false;
+	}
+
+	*pkt_num = telemetry_ctx->sla_samples_params.sla_num_pkt;
+	return true;
+}
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/telemetry_agent_app_if.h
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __TELEMETRY_AGENT_APP_IF_H__
+#define __TELEMETRY_AGENT_APP_IF_H__
+
+#define MAX_SOCS 5
+#define MAX_PDEV_LINKS 2
+#define MAX_MLO_PEERS 128
+#define NUM_TIDS 8
+#define RFS_INIT_DATA 1
+#define RFS_STATS_DATA 2
+#define WLAN_VENDOR_EHTCAP_TXRX_MCS_NSS_IDX_MAX 4
+#define MAX_T2LM_INFO 2
+#define WLAN_AC_MAX 4
+
+/*
+   Buffer Format
+   --------------------------------------------
+   |          |                  |            |
+   |  HEADER  |  Payload (stats) | Tail Data  |
+   |          |                  |            |
+   --------------------------------------------
+ */
+
+#define MAX_PEERS 512
+
+struct emesh_peer_stats {
+	u8 peer_link_mac[6];
+	u16 tx_airtime_consumption[WLAN_AC_MAX];
+};
+
+struct emesh_link_stats {
+	u8 link_mac[6];
+	u8 link_idle_airtime;
+	int num_peers;
+	struct emesh_peer_stats peer_stats[MAX_PEERS];
+};
+
+struct emesh_soc_stats {
+	int num_links;
+	struct emesh_link_stats link_stats[MAX_PDEV_LINKS];
+};
+
+
+struct emesh_relyfs_stats {
+	int num_soc;
+	struct emesh_soc_stats soc_stats[MAX_SOCS];
+};
+
+struct telemetry_agent_header {
+	u32 start_magic_num;
+	u32 stats_version;
+	u32 stats_type;
+	u32 payload_len;
+} __attribute__ ((__packed__));
+
+struct telemetry_emesh_buffer {
+	struct telemetry_agent_header header;
+	struct emesh_relyfs_stats relayfs_stats;
+	u32 end_magic_num;
+};
+
+enum wlan_vendor_channel_width {
+	WLAN_VENDOR_CHAN_WIDTH_INVALID = 0,
+	WLAN_VENDOR_CHAN_WIDTH_20MHZ = 1,
+	WLAN_VENDOR_CHAN_WIDTH_40MHZ = 2,
+	WLAN_VENDOR_CHAN_WIDTH_80MHZ = 3,
+	WLAN_VENDOR_CHAN_WIDTH_160MZ = 4,
+	WLAN_VENDOR_CHAN_WIDTH_80_80MHZ = 5,
+	WLAN_VENDOR_CHAN_WIDTH_320MHZ = 6,
+};
+
+enum t2lm_band_caps {
+	T2LM_BAND_INVALID,
+	T2LM_BAND_2GHz,
+	T2LM_BAND_5GHz,
+	T2LM_BAND_5GHz_LOW,
+	T2LM_BAND_5GHz_HIGH,
+	T2LM_BAND_6Ghz,
+	T2LM_BAND_6Ghz_LOW,
+	T2LM_BAND_6GHz_HIGH,
+};
+
+enum wlan_vendor_t2lm_direction {
+	WLAN_VENDOR_T2LM_INVALID_DIRECTION = 0,
+	WLAN_VENDOR_T2LM_DOWNLINK_DIRECTION = 1,
+	WLAN_VENDOR_T2LM_UPLINK_DIRECTION = 2,
+	WLAN_VENDOR_T2LM_BIDI_DIRECTION = 3,
+	WLAN_VENDOR_T2LM_MAX_VALID_DIRECTION =
+		WLAN_VENDOR_T2LM_BIDI_DIRECTION,
+};
+
+struct agent_peer_stats {
+	u8 peer_mld_mac[6];
+	u8 peer_link_mac[6];
+	u8 airtime_consumption[WLAN_AC_MAX];
+	u8 m1_stats;
+	u8 m2_stats;
+	s8 rssi;
+	u16 sla_mask; /* Uses telemetry_sawf_param for bitmask */
+};
+
+struct agent_link_stats {
+	u16 hw_link_id;
+	u8 link_airtime[WLAN_AC_MAX];
+	u8 freetime;
+	u8 available_airtime[WLAN_AC_MAX];
+	u32 m3_stats[WLAN_AC_MAX];
+	u32 m4_stats[WLAN_AC_MAX];
+	u16 num_peers;
+	struct agent_peer_stats peer_stats[MAX_MLO_PEERS];
+};
+
+struct agent_soc_stats {
+	u8 soc_id;
+	u16 num_peers;
+	u8 num_links;
+	struct agent_link_stats link_stats[MAX_PDEV_LINKS];
+};
+
+/* Periodic Stats */
+struct relayfs_stats {
+	u8 num_soc;
+	struct agent_soc_stats soc_stats[MAX_SOCS];
+};
+
+/*
+ * Init time interface information - complete view.
+ */
+struct link_map_of_tids {
+	enum wlan_vendor_t2lm_direction direction; /* 0-DL, 1-UL, 2-BiDi */
+	u8 default_link_mapping;
+	u8 tid_present[NUM_TIDS]; /* TID present on this link */
+};
+
+struct agent_peer_init_stats {
+	u8 mld_mac_addr[6];      /* peer MLD mac */
+	u8 link_mac_addr[6];     /* peer MLD link mac */
+	struct link_map_of_tids t2lm_info[MAX_T2LM_INFO]; /* T2LM mapping */
+	enum wlan_vendor_channel_width chan_bw;
+	u16 chan_freq;                  /* channel center frequency */
+	u32 tx_mcs_nss_map[WLAN_VENDOR_EHTCAP_TXRX_MCS_NSS_IDX_MAX];
+	u32 rx_mcs_nss_map[WLAN_VENDOR_EHTCAP_TXRX_MCS_NSS_IDX_MAX];
+	u8 ieee_link_id;
+};
+
+struct agent_link_init_stats {
+	u16 hw_link_id;
+	/* enum t2lm_band_caps band; */
+	u16 num_peers;
+	struct agent_peer_init_stats peer_stats[MAX_MLO_PEERS];
+};
+
+struct agent_soc_init_stats {
+	u8 soc_id;
+	u16 num_peers;
+	u8 num_links;
+	struct agent_link_init_stats link_stats[MAX_PDEV_LINKS];
+};
+
+struct relayfs_init_stats {
+	u8 num_soc;
+	struct agent_soc_init_stats soc_stats[MAX_SOCS];
+};
+
+struct telemetry_buffer {
+	struct telemetry_agent_header header;
+	union {
+		struct relayfs_stats periodic_stats;
+		struct relayfs_init_stats init_stats;
+	} u;
+	u32   end_magic_num;
+};
+
+#endif /* __TELEMETRY_AGENT_APP_IF_H__ */
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/telemetry_agent_if.c
@@ -0,0 +1,348 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#include "core.h"
+#include "debug.h"
+#include "sawf.h"
+#include <linux/export.h>
+#include "telemetry.h"
+#include "telemetry_agent_if.h"
+#include "telemetry_agent_wifi_driver_if.h"
+#include <linux/module.h>
+
+int ath12k_get_pdev_stats(void *obj, struct agent_link_iface_stats_obj *stats);
+int ath12k_get_peer_info(void *obj, struct agent_peer_iface_init_obj *stats);
+int ath12k_get_pdev_info(void *obj, struct agent_pdev_iface_init_obj *stats);
+int ath12k_get_peer_stats(void *obj, struct agent_peer_iface_stats_obj *stats);
+int ath12k_get_psoc_info(void *obj, struct agent_psoc_iface_init_obj *stats);
+
+struct telemetry_agent_ops *g_agent_ops;
+EXPORT_SYMBOL(g_agent_ops);
+
+int register_telemetry_agent_ops(struct telemetry_agent_ops *agent_ops);
+int unregister_telemetry_agent_ops(struct telemetry_agent_ops *agent_ops);
+
+int register_telemetry_agent_ops(struct telemetry_agent_ops *agent_ops)
+{
+	g_agent_ops = agent_ops;
+	g_agent_ops->agent_get_psoc_info = ath12k_get_psoc_info;
+	g_agent_ops->agent_get_pdev_info = ath12k_get_pdev_info;
+	g_agent_ops->agent_get_peer_info = ath12k_get_peer_info;
+	g_agent_ops->agent_get_pdev_stats = ath12k_get_pdev_stats;
+	g_agent_ops->agent_get_peer_stats = ath12k_get_peer_stats;
+	g_agent_ops->agent_get_emesh_pdev_stats = NULL;
+	g_agent_ops->agent_get_emesh_peer_stats = NULL;
+
+	/* SAWF ops */
+	g_agent_ops->sawf_get_tput_stats = ath12k_sawf_get_tput_stats;
+	g_agent_ops->sawf_get_mpdu_stats = ath12k_sawf_get_mpdu_stats;
+	g_agent_ops->sawf_get_drop_stats = ath12k_sawf_get_drop_stats;
+	g_agent_ops->sawf_notify_breach = ath12k_sawf_notify_breach;
+
+	ath12k_info(NULL, "registered telemetry agent ops: %p", g_agent_ops);
+	return 0;
+}
+EXPORT_SYMBOL(register_telemetry_agent_ops);
+
+int unregister_telemetry_agent_ops(struct telemetry_agent_ops *agent_ops)
+{
+	g_agent_ops = NULL;
+	ath12k_info(NULL, "unregistered telemetry agent ops: %p", g_agent_ops);
+	return 0;
+}
+EXPORT_SYMBOL(unregister_telemetry_agent_ops);
+
+u32 ath12k_telemetry_agent_init(void)
+{
+	int status = 0;
+	/* TODO */
+	ath12k_info(NULL, "telemetry agent init Done\n");
+	return status;
+}
+
+u32 ath12k_telemetry_agent_deinit(void)
+{
+	int status = 0;
+	/* TODO */
+	ath12k_info(NULL, "telemetry agent deinit\n");
+	return status;
+}
+
+int ath12k_get_pdev_stats(void *obj, struct agent_link_iface_stats_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_pdev_stats - not implemented \n");
+	return -1;
+}
+
+int ath12k_get_peer_info(void *obj, struct agent_peer_iface_init_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_peer_info - not implemented \n");
+	return -1;
+}
+
+int ath12k_get_pdev_info(void *obj, struct agent_pdev_iface_init_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_pdev_info - not implemented \n");
+	return -1;
+}
+
+int ath12k_get_peer_stats(void *obj, struct agent_peer_iface_stats_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_peer_stats - not implemented \n");
+	return -1;
+}
+
+int ath12k_get_psoc_info(void *obj, struct agent_psoc_iface_init_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_peer_stats - not implemented \n");
+	return -1;
+}
+
+void *ath12k_telemetry_peer_ctx_alloc(void *peer, void *sawf_stats,
+				      u8 *mac_addr,
+				      u8 svc_id, u8 hostq_id)
+{
+	if (g_agent_ops)
+		return g_agent_ops->sawf_alloc_peer(peer, sawf_stats,
+						    mac_addr,
+						    svc_id,
+						    hostq_id);
+	return NULL;
+}
+
+void ath12k_telemetry_peer_ctx_free(void *telemetry_peer_ctx)
+{
+	if (g_agent_ops)
+		g_agent_ops->sawf_free_peer(telemetry_peer_ctx);
+}
+
+bool ath12k_telemetry_update_tid_msduq(void *telemetry_peer_ctx,
+				       u8 hostq_id, u8 tid, u8 msduq_idx)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_updt_queue_info(telemetry_peer_ctx,
+						      hostq_id, tid,
+						      msduq_idx))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_mov_avg_params(u32 num_pkt,
+					 u32 num_win)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_updt_delay_mvng(num_pkt, num_win))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_sla_params(u32 num_pkt,
+				     u32 time_sec)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_updt_sla_params(num_pkt, time_sec))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_sla_cfg(u8 svc_id,
+				  u8 min_tput_rate,
+				  u8 max_tput_rate,
+				  u8 burst_size,
+				  u8 svc_interval,
+				  u8 delay_bound,
+				  u8 msdu_ttl,
+				  u8 msdu_rate_loss)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_set_sla_cfg(svc_id,
+					          min_tput_rate,
+						  max_tput_rate,
+						  burst_size,
+						  svc_interval,
+						  delay_bound,
+						  msdu_ttl,
+						  msdu_rate_loss))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_svclass_cfg(bool enable, u8 svc_id,
+				      u32 min_tput_rate,
+				      u32 max_tput_rate,
+				      u32 burst_size,
+				      u32 svc_interval,
+				      u32 delay_bound,
+				      u32 msdu_ttl,
+				      u32 msdu_rate_loss)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_set_svclass_cfg(enable, svc_id,
+						      min_tput_rate,
+						      max_tput_rate,
+						      burst_size,
+						      svc_interval,
+						      delay_bound,
+						      msdu_ttl,
+				                      msdu_rate_loss))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_sla_detect_cfg(u8 detect_type,
+					 u8 min_tput_rate,
+					 u8 max_tput_rate,
+					 u8 burst_size,
+					 u8 svc_interval,
+					 u8 delay_bound,
+					 u8 msdu_ttl,
+					 u8 msdu_rate_loss)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_set_sla_dtct_cfg(detect_type,
+						       min_tput_rate,
+						       max_tput_rate,
+						       burst_size,
+						       svc_interval,
+						       delay_bound,
+						       msdu_ttl,
+						       msdu_rate_loss))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_update_delay(void *telemetry_ctx, u8 tid,
+				   u8 queue, u64 pass,
+				   u64 fail)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_push_delay(telemetry_ctx, tid,
+						 queue, pass, fail))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_update_delay_mvng(void *telemetry_ctx,
+					u8 tid, u8 queue,
+					u64 nwdelay_winavg,
+					u64 swdelay_winavg,
+					u64 hwdelay_winavg)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_push_delay_mvng(telemetry_ctx,
+						      tid, queue,
+						      nwdelay_winavg,
+						      swdelay_winavg,
+						      hwdelay_winavg))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_update_msdu_drop(void *telemetry_ctx,
+				       u8 tid, u8 queue,
+				       u64 success,
+				       u64 failure_drop,
+				       u64 failure_ttl)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_push_msdu_drop(telemetry_ctx, tid,
+						  queue, success,
+						  failure_drop,
+						  failure_ttl))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_get_rate(void *telemetry_ctx, u8 tid,
+			       u8 queue, u32 *egress_rate,
+			       u32 *ingress_rate)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_pull_rate(telemetry_ctx, tid, queue,
+						egress_rate, ingress_rate))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_get_mov_avg(void *telemetry_ctx, u8 tid,
+				  u8 queue, u32 *nwdelay_avg,
+				  u32 *swdelay_avg,
+				  u32 *hwdelay_avg)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_pull_mov_avg(telemetry_ctx, tid,
+						   queue, nwdelay_avg,
+						   swdelay_avg, hwdelay_avg))
+			return false;
+	}
+
+	return true;
+}
+
+int ath12k_telemetry_reset_peer_stats(u8 *peer_mac)
+{
+	int ret = -EOPNOTSUPP;
+
+	if (g_agent_ops)
+		ret = g_agent_ops->sawf_reset_peer_stats(peer_mac);
+
+	return ret;
+}
+
+int ath12k_sawf_get_tput_stats(void *soc, void *arg, u64 *in_bytes,
+			       u64 *in_cnt, u64 *tx_bytes,
+			       u64 *tx_cnt, u8 tid, u8 msduq)
+{
+	return ath12k_telemetry_get_sawf_tx_stats_tput(soc, arg,
+						       in_bytes, in_cnt,
+						       tx_bytes, tx_cnt,
+						       tid, msduq);
+}
+
+int ath12k_sawf_get_mpdu_stats(void *soc, void *arg, u64 *svc_int_pass,
+			       u64 *svc_int_fail, u64 *burst_pass,
+			       u64 *burst_fail, u8 tid, u8 msduq)
+{
+	return ath12k_telemetry_get_sawf_tx_stats_mpdu(soc, arg, svc_int_pass,
+						       svc_int_fail, burst_pass,
+						       burst_fail, tid, msduq);
+}
+
+int ath12k_sawf_get_drop_stats(void *soc, void *arg, u64 *pass,
+			       u64 *drop, u64 *drop_ttl,
+			       u8 tid, u8 msduq)
+{
+	return ath12k_telemetry_get_sawf_tx_stats_drop(soc, arg, pass, drop,
+						       drop_ttl, tid, msduq);
+}
+
+void ath12k_sawf_notify_breach(u8 *mac_addr,
+			       u8 svc_id,
+			       u8 param,
+			       bool set_clear,
+			       u8 tid)
+{
+	ath12k_telemetry_notify_breach(mac_addr, svc_id, param, set_clear, tid);
+}
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/telemetry_agent_if.h
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef ATH12K_TELEMETRY_AGENT_IF_H
+#define ATH12K_TELEMETRY_AGENT_IF_H
+
+u32 ath12k_telemetry_agent_init(void);
+u32 ath12k_telemetry_agent_deinit(void);
+
+int ath12k_sawf_get_tput_stats(void *soc, void *arg, u64 *in_bytes,
+			       u64 *in_cnt, u64 *tx_bytes,
+			       u64 *tx_cnt, u8 tid, u8 msduq);
+int ath12k_sawf_get_mpdu_stats(void *soc, void *arg, u64 *svc_int_pass,
+			       u64 *svc_int_fail, u64 *burst_pass,
+			       u64 *burst_fail, u8 tid, u8 msduq);
+int ath12k_sawf_get_drop_stats(void *soc, void *arg, u64 *pass,
+			       u64 *drop, u64 *drop_ttl,
+			       u8 tid, u8 msduq);
+void ath12k_sawf_notify_breach(u8 *mac_addr, u8 svc_id, u8 param,
+			       bool set_clear, u8 tid);
+void *ath12k_telemetry_peer_ctx_alloc(void *peer, void *sawf_stats,
+				      u8 *mac_addr,
+				      u8 svc_id, u8 hostq_id);
+void ath12k_telemetry_peer_ctx_free(void *telemetry_peer_ctx);
+bool ath12k_telemetry_update_tid_msduq(void *telemetry_peer_ctx,
+				       u8 hostq_id, u8 tid, u8 msduq_idx);
+bool ath12k_telemetry_set_mov_avg_params(u32 num_pkt, u32 num_win);
+bool ath12k_telemetry_set_sla_params(u32 num_pkt, u32 time_sec);
+bool ath12k_telemetry_set_sla_cfg(u8 svc_id, u8 min_tput_rate, u8 max_tput_rate,
+				  u8 burst_size, u8 svc_interval, u8 delay_bound,
+				  u8 msdu_ttl, u8 msdu_rate_loss);
+bool ath12k_telemetry_set_svclass_cfg(bool enable, u8 svc_id,
+				      u32 min_tput_rate,
+				      u32 max_tput_rate,
+				      u32 burst_size,
+				      u32 svc_interval,
+				      u32 delay_bound,
+				      u32 msdu_ttl,
+				      u32 msdu_rate_loss);
+bool ath12k_telemetry_set_sla_detect_cfg(u8 detect_type,
+					 u8 min_tput_rate,
+					 u8 max_tput_rate,
+					 u8 burst_size,
+					 u8 svc_interval,
+					 u8 delay_bound,
+					 u8 msdu_ttl,
+					 u8 msdu_rate_loss);
+bool ath12k_telemetry_update_delay(void *telemetry_ctx, u8 tid,
+				   u8 queue, u64 pass, u64 fail);
+bool ath12k_telemetry_update_delay_mvng(void *telemetry_ctx,
+					u8 tid, u8 queue,
+					u64 nwdelay_winavg,
+					u64 swdelay_winavg,
+					u64 hwdelay_winavg);
+bool ath12k_telemetry_update_msdu_drop(void *telemetry_ctx, u8 tid,
+				       u8 queue, u64 success,
+				       u64 failure_drop,
+				       u64 failure_ttl);
+bool ath12k_telemetry_get_rate(void *telemetry_ctx, u8 tid, u8 queue,
+			       u32 *egress_rate, u32 *ingress_rate);
+bool ath12k_telemetry_get_mov_avg(void *telemetry_ctx, u8 tid, u8 queue,
+				  u32 *nwdelay_avg, u32 *swdelay_avg,
+				  u32 *hwdelay_avg);
+int ath12k_telemetry_reset_peer_stats(u8 *peer_mac);
+#endif /* ATH12K_TELEMETRY_AGENT_IF_H */
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/telemetry_agent_wifi_driver_if.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __TELEMETRY_AGENT_WIFI_DRIVER_IF_H__
+#define __TELEMETRY_AGENT_WIFI_DRIVER_IF_H__
+
+#include "telemetry_agent_app_if.h"
+struct agent_psoc_obj {
+	void *psoc_back_pointer;
+	spinlock_t psoc_lock;
+	u8 psoc_id;
+};
+
+struct agent_pdev_obj {
+	void *pdev_back_pointer;
+	void *psoc_back_pointer;
+	spinlock_t pdev_lock;
+	u8 psoc_id;
+	u8 pdev_id;
+};
+
+struct agent_peer_obj {
+	void *peer_back_pointer;
+	void *pdev_back_pointer;
+	void *psoc_back_pointer;
+	spinlock_t peer_lock;
+	u8 psoc_id;
+	u8 pdev_id;
+	u8 peer_mac_addr[6];
+};
+
+enum agent_notification_event {
+	AGENT_NOTIFY_EVENT_INIT,
+	AGENT_NOTIFY_EVENT_DEINIT,
+};
+
+enum agent_params {
+	AGENT_INVALID_PARAM,
+	AGENT_SET_DEBUG_LEVEL,
+};
+
+struct t2lm_of_tids {
+	enum wlan_vendor_t2lm_direction direction; /* 0-DL, 1-UL, 2-BiDi */
+	u8 default_link_mapping;
+	u16 t2lm_provisioned_links[NUM_TIDS]; /*Bit0 for link0, bit1 for link1 and so on*/
+};
+
+struct eht_peer_caps {
+	u32 tx_mcs_nss_map[WLAN_VENDOR_EHTCAP_TXRX_MCS_NSS_IDX_MAX];
+	u32 rx_mcs_nss_map[WLAN_VENDOR_EHTCAP_TXRX_MCS_NSS_IDX_MAX];
+};
+
+struct agent_peer_iface_init_obj {
+	u8 peer_mld_mac[6];
+	u8 peer_link_mac[6];
+	u8 bw;
+	u16 freq;
+	struct t2lm_of_tids t2lm_info[WLAN_VENDOR_T2LM_MAX_VALID_DIRECTION]; /* T2LM mapping */
+	struct eht_peer_caps caps;          /* Peer capabilities */
+	u8 ieee_link_id;
+};
+
+struct agent_pdev_iface_init_obj {
+	/* This info is stroed in telemetry pdev object,
+	 * so this can be ignored for now
+	 */
+	u16 link_id;
+	u8 soc_id;
+	u8 band;
+};
+
+struct agent_psoc_iface_init_obj {
+	u8 soc_id;
+	u16 max_peers;
+	u16 num_peers;
+
+};
+
+struct agent_peer_iface_stats_obj {
+	u8 peer_mld_mac[6];
+	u8 peer_link_mac[6];
+	u8 airtime_consumption[WLAN_AC_MAX];
+	u32 tx_mpdu_retried;
+	u32 tx_mpdu_total;
+	u32 rx_mpdu_retried;
+	u32 rx_mpdu_total;
+	u8 rssi;
+	u16 sla_mask; /* Uses telemetry_sawf_param for bitmask */
+};
+
+struct agent_link_iface_stats_obj {
+	u16 link_id;
+	u8 soc_id;
+	u8 available_airtime[WLAN_AC_MAX];
+	u32 congestion[WLAN_AC_MAX];
+	u32 tx_mpdu_failed[WLAN_AC_MAX];
+	u32 tx_mpdu_total[WLAN_AC_MAX];
+	u8 link_airtime[WLAN_AC_MAX];
+	u8 freetime;
+};
+
+struct emesh_peer_iface_stats_obj {
+	u8 peer_link_mac[6];
+	u16 tx_airtime_consumption[WLAN_AC_MAX];
+};
+
+struct emesh_link_iface_stats_obj {
+	u8 link_mac[6];
+	u8 link_idle_airtime;
+};
+
+struct telemetry_agent_ops {
+    int  (*agent_psoc_create_handler) (void *arg, struct agent_psoc_obj *psoc_obj);
+    int  (*agent_psoc_destroy_handler) (void *arg, struct agent_psoc_obj *psoc_obj);
+    int  (*agent_pdev_create_handler) (void *arg, struct agent_pdev_obj *pdev_obj);
+    int  (*agent_pdev_destroy_handler) (void *arg, struct agent_pdev_obj *pdev_obj);
+    int  (*agent_peer_create_handler) (void *arg, struct agent_peer_obj *peer_obj);
+    int  (*agent_peer_destroy_handler) (void *arg, struct agent_peer_obj *peer_obj);
+    int  (*agent_set_param) (int command, int value);
+    int  (*agent_get_param) (int command);
+    void (*agent_notify_app_event) (enum agent_notification_event);
+    void (*agent_notify_emesh_event) (enum agent_notification_event);
+    int (*agent_get_psoc_info) (void *obj, struct agent_psoc_iface_init_obj *stats);
+    int (*agent_get_pdev_info) (void *obj, struct agent_pdev_iface_init_obj *stats);
+    int (*agent_get_peer_info) (void *obj, struct agent_peer_iface_init_obj *stats);
+    int (*agent_get_pdev_stats) (void *obj, struct agent_link_iface_stats_obj *stats);
+    int (*agent_get_peer_stats) (void *obj, struct agent_peer_iface_stats_obj *stats);
+    int (*agent_get_emesh_pdev_stats) (void *obj, struct emesh_link_iface_stats_obj *stats);
+    int (*agent_get_emesh_peer_stats) (void *obj, struct emesh_peer_iface_stats_obj *stats);
+
+    /* SAWF ops */
+    void * (*sawf_alloc_peer) (void *sawf_ctx, void *sawf_stats_ctx,
+                               uint8_t *mac_addr,
+                               uint8_t svc_id, uint8_t hostq_id);
+    void (* sawf_free_peer) (void *telemetry_sawf_ctx);
+    int (* sawf_updt_queue_info) (void *telemetry_sawf_ctx,
+                                  uint8_t svc_id,
+                                  uint8_t tid, uint8_t msduq_idx);
+    int (* sawf_updt_delay_mvng) (uint32_t num_win, uint32_t num_pkt);
+    int (* sawf_updt_sla_params) (uint32_t num_pkt, uint32_t time_sec);
+    int (* sawf_set_sla_cfg) (uint8_t svc_id, uint8_t min_thruput_rate,
+                              uint8_t max_thruput_rate,
+                              uint8_t burst_size,
+                              uint8_t service_interval,
+                              uint8_t delay_bound, uint8_t msdu_ttl,
+                              uint8_t msdu_rate_loss);
+    int (* sawf_set_svclass_cfg) (bool enable, uint8_t svclass_id,
+                                  uint32_t min_thruput_rate,
+                                  uint32_t max_thruput_rate,
+                                  uint32_t burst_size,
+                                  uint32_t service_interval,
+                                  uint32_t delay_bound,
+                                  uint32_t msdu_ttl,
+                                  uint32_t msdu_rate_loss);
+    int (* sawf_set_sla_dtct_cfg) (uint8_t detect_type,
+                                   uint8_t min_thruput_rate,
+                                   uint8_t max_thruput_rate,
+                                   uint8_t burst_size,
+                                   uint8_t service_interval,
+                                   uint8_t delay_bound,
+                                   uint8_t msdu_ttl,
+                                   uint8_t msdu_rate_loss);
+    int (* sawf_push_delay) (void *telemetry_sawf_ctx, uint8_t tid,
+                             uint8_t queue, uint64_t pass,
+                             uint64_t fail);
+    int (* sawf_push_delay_mvng) (void *telemetry_ctx, uint8_t tid,
+                                  uint8_t queue, uint64_t nwdelay_avg,
+                                  uint64_t swdelay_avg,
+                                  uint64_t hwdelay_avg);
+    int (* sawf_push_msdu_drop) (void * telemetry_sawf_ctx, uint8_t tid,
+                                 uint8_t queue, uint64_t pass,
+                                 uint64_t fail_drop, uint64_t fail_ttl);
+    int (* sawf_pull_rate) (void *telemetry_sawf_ctx, uint8_t tid,
+                            uint8_t queue, uint32_t *egress_rate,
+                            uint32_t *ingress_rate);
+    int (* sawf_pull_mov_avg) (void *telemetry_sawf_ctx, uint8_t tid,
+                               uint8_t queue, uint32_t *nwdelay_avg,
+                               uint32_t *swdelay_avg, uint32_t *hwdelay_avg);
+    int (* sawf_reset_peer_stats) (uint8_t *mac_addr);
+    int (* sawf_get_tput_stats) (void *soc, void *arg, uint64_t *in_bytes,
+                                 uint64_t *in_cnt, uint64_t *tx_bytes,
+                                 uint64_t *tx_cnt, uint8_t tid,
+                                 uint8_t msduq);
+    int (* sawf_get_mpdu_stats) (void *soc, void *arg, uint64_t *svc_int_pass,
+                                 uint64_t *svc_int_fail, uint64_t *burst_pass,
+                                 uint64_t *burst_fail, uint8_t tid,
+                                 uint8_t msduq);
+    int (* sawf_get_drop_stats) (void *soc, void *arg, uint64_t *pass,
+                                 uint64_t *drop, uint64_t *drop_ttl,
+                                 uint8_t tid, uint8_t msduq);
+    void (* sawf_notify_breach) (uint8_t *mac_addr, uint8_t svc_id,
+                                 uint8_t param, bool set_clear, uint8_t tid);
+};
+
+void wlan_cfg80211_t2lm_app_reply_init_response(void);
+#endif /* __TELEMETRY_AGENT_WIFI_DRIVER_IF_H__ */
--- a/drivers/net/wireless/ath/ath12k/Makefile
+++ b/drivers/net/wireless/ath/ath12k/Makefile
@@ -33,7 +33,7 @@ ath12k-$(CPTCFG_ATH12K_PKTLOG) += pktlog
 ath12k-$(CPTCFG_ATH12K_AHB) += ahb.o
 ath12k-$(CPTCFG_ATH12K_PPE_DS_SUPPORT) += ppe.o
 ath12k-$(CPTCFG_ATH12K_BONDED_DS_SUPPORT) += bondif.o
-ath12k-$(CPTCFG_ATH12K_SAWF) += sawf.o telemetry.o
+ath12k-$(CPTCFG_ATH12K_SAWF) += sawf.o telemetry.o telemetry_agent_if.o
 
 # for tracing framework to find trace.h
 CFLAGS_trace.o := -I$(src)
--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -22,6 +22,7 @@
 #include "ppe.h"
 #include "ahb.h"
 #include "telemetry.h"
+#include "peer.h"
 
 unsigned int ath12k_debug_mask;
 module_param_named(debug_mask, ath12k_debug_mask, uint, 0644);
@@ -2571,6 +2572,39 @@ int ath12k_core_sawf_ul_config(struct ne
 	return ret;
 }
 
+void *ath12k_get_ab_nd_peer_from_peer_mac(u8 *peer_mac, struct ath12k_base *ab)
+{
+	struct ath12k_hw_group *ag = NULL;
+	void *peer = NULL;
+	int soc;
+
+	mutex_lock(&ath12k_hw_lock);
+	list_for_each_entry(ag, &ath12k_hw_groups, list) {
+		if (!ag) {
+			ath12k_warn(NULL, "unable to fetch hw group\n");
+			mutex_unlock(&ath12k_hw_lock);
+			return -ENODEV;
+		}
+		for (soc = ag->num_probed; soc > 0; soc--) {
+
+			ab = ag->ab[soc - 1];
+			if (!ab) {
+				/* Control should not reach here */
+				ath12k_info(NULL, "SOC not initialized\n");
+				continue;
+			}
+			spin_lock_bh(&ab->base_lock);
+			peer = ath12k_peer_find_by_addr(ab, peer_mac);
+			spin_unlock_bh(&ab->base_lock);
+			if (peer)
+				return peer;
+			ab = NULL;
+		}
+	}
+	mutex_unlock(&ath12k_hw_lock);
+	return peer;
+}
+
 #endif /* CPTCFG_ATH12K_SAWF */
 
 static int ath12k_init(void)
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -29,6 +29,7 @@
 #include "pktlog.h"
 #include "sawf.h"
 #include "vendor.h"
+#include "telemetry_agent_if.h"
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 #include <ppe_ds_wlan.h>
 #include <ppe_vp_public.h>
@@ -1602,6 +1603,7 @@ void ath12k_fw_stats_free(struct ath12k_
 int ath12k_send_sawf_configs_soc(struct ath12k_sawf_svc_params *new_param);
 int ath12k_sawf_send_disable_soc(u8 svc_id);
 int ath12k_core_sawf_ul_config(struct net_device *dev, struct ath12k_sawf_wmi_peer_latency_param *latency_info);
+void *ath12k_get_ab_nd_peer_from_peer_mac(u8 *peer_mac, struct ath12k_base *ab);
 #endif /* CPTCFG_ATH12K_SAWF */
 
 static inline const char *ath12k_scan_state_str(enum ath12k_scan_state state)
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -2045,8 +2045,10 @@ static void ath12k_htt_sawf_info_ind_han
 					     struct sk_buff *skb)
 {
 	struct htt_t2h_sawf_info_ind *resp = (struct htt_t2h_sawf_info_ind *)skb->data;
-	u32 htt_qtype, remapped_tid, peer_id;
-	u32 hlos_tid, flow_or, ast_idx, who_cl, tgt_opaque_id;
+	struct ath12k_peer *peer = NULL;
+	u32 htt_qtype, remapped_tid, peer_id, default_msduq_per_tid, default_msduq_max, sawf_msduq_per_tid;
+	u32 hlos_tid, flow_or, ast_idx, who_cl, tgt_opaque_id, sawf_msduq_max;
+	u8 msduq_index;
 
 	htt_qtype = u32_get_bits(__le32_to_cpu(resp->info0),
 				 HTT_T2H_SAWF_MSDUQ_INFO_0_IND_HTT_QTYPE_ID);
@@ -2080,6 +2082,24 @@ static void ath12k_htt_sawf_info_ind_han
 		   flow_or,
 		   ast_idx,
 		   tgt_opaque_id);
+	spin_lock_bh(&ab->base_lock);
+
+	default_msduq_per_tid = ab->default_msduq_per_tid;
+	sawf_msduq_per_tid = ab->max_msduq_per_tid - ab->default_msduq_per_tid;
+	default_msduq_max = default_msduq_per_tid * ATH12K_SAWF_MAX_TID_SUPPORT;
+	sawf_msduq_max = sawf_msduq_per_tid * ATH12K_SAWF_MAX_TID_SUPPORT;
+	msduq_index = ((who_cl * default_msduq_max) +
+		      (flow_or * ATH12K_SAWF_MAX_TID_SUPPORT) + hlos_tid) -
+		      default_msduq_max;
+
+	peer = ath12k_peer_find_by_id(ab, peer_id);
+	if ((msduq_index < sawf_msduq_max) && peer) {
+		if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+			ath12k_telemetry_update_tid_msduq(peer->sawf_ctx_peer.telemetry_peer_ctx,
+							  msduq_index ,remapped_tid,
+							  (htt_qtype - default_msduq_per_tid));
+	}
+	spin_unlock_bh(&ab->base_lock);
 }
 #endif /* CPTCFG_ATH12K_SAWF */
 void ath12k_dp_htt_htc_t2h_msg_handler(struct ath12k_base *ab,
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -1037,6 +1037,10 @@ void ath12k_mac_peer_cleanup_all(struct
 		ath12k_dp_rx_peer_tid_cleanup(ar, peer);
 		ath12k_peer_rhash_delete(ab, peer);
 		list_del(&peer->list);
+#ifdef CPTCFG_ATH12K_SAWF
+	if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+		ath12k_telemetry_peer_ctx_free(peer->sawf_ctx_peer.telemetry_peer_ctx);
+#endif
 		kfree(peer);
 	}
 	spin_unlock_bh(&ab->base_lock);
@@ -6699,6 +6703,10 @@ static void ath12k_mac_station_post_remo
 		ath12k_peer_rhash_delete(ar->ab, peer);
 		peer->sta = NULL;
 		list_del(&peer->list);
+#ifdef CPTCFG_ATH12K_SAWF
+		if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+			ath12k_telemetry_peer_ctx_free(peer->sawf_ctx_peer.telemetry_peer_ctx);
+#endif
 		kfree(peer);
 		ar->num_peers--;
 	}
--- a/drivers/net/wireless/ath/ath12k/peer.c
+++ b/drivers/net/wireless/ath/ath12k/peer.c
@@ -141,6 +141,10 @@ void ath12k_peer_unmap_event(struct ath1
 		   peer->vdev_id, peer->addr, peer_id);
 
 	list_del(&peer->list);
+#ifdef CPTCFG_ATH12K_SAWF
+	if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+		ath12k_telemetry_peer_ctx_free(peer->sawf_ctx_peer.telemetry_peer_ctx);
+#endif
 	kfree(peer);
 	wake_up(&ab->peer_mapping_wq);
 
@@ -343,6 +347,10 @@ void ath12k_peer_cleanup(struct ath12k *
 			    peer->addr, vdev_id);
 		ath12k_peer_rhash_delete(ab, peer);
 		list_del(&peer->list);
+#ifdef CPTCFG_ATH12K_SAWF
+		if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+			ath12k_telemetry_peer_ctx_free(peer->sawf_ctx_peer.telemetry_peer_ctx);
+#endif
 		kfree(peer);
 		ar->num_peers--;
 	}
--- a/drivers/net/wireless/ath/ath12k/sawf.h
+++ b/drivers/net/wireless/ath/ath12k/sawf.h
@@ -217,10 +217,13 @@ struct ath12k_sawf_def_queue_report {
  * The allocation is mapped with the service class ID.
  * @msduq_table: map table of msduq and svc id per peer
  * @def_q_map: default q map report
+ * @telemetry_peer_ctx: pointer to hold the structure reference
+ * maintained in telemetry agent module.
  */
 struct ath12k_sawf_peer_ctx {
 	struct ath12k_msduq_map msduq_table[ATH12K_SAWF_MAX_TID_SUPPORT][MAX_Q_PER_TID];
 	struct ath12k_sawf_def_queue_report def_q_map[ATH12K_SAWF_MAX_TID_SUPPORT];
+	void *telemetry_peer_ctx;
 };
 
 /* MSG_TYPE => HTT_H2T_SAWF_DEF_QUEUES_MAP_REQ
@@ -850,6 +853,19 @@ int telemetry_extract_data(struct stats_
 			   struct telemetry_sawftx_stats *tx_stats,
 			   struct telemetry_sawfdelay_stats *delay_stats,
 			   struct ath12k_base *ab);
+int ath12k_telemetry_sla_reset_stats(u8 svc_id, u8 *peer_mac, u8 *mld_mac_addr,
+				     u8 set_clear);
+int ath12k_telemetry_get_sawf_tx_stats_tput(void *ptr, void *stats, u64 *in_bytes,
+					    u64 *in_cnt, u64 *tx_bytes,
+					    u64 *tx_cnt, u8 tid_v, u8 msduq_id);
+int ath12k_telemetry_get_sawf_tx_stats_mpdu(void *ptr, void *stats, u64 *svc_int_pass,
+					    u64 *svc_int_fail, u64 *burst_pass,
+					    u64 *burst_fail, u8 tid_v, u8 msduq_id);
+int ath12k_telemetry_get_sawf_tx_stats_drop(void *ptr, void *stats, u64 *pass,
+					    u64 *drop, u64 *drop_ttl,
+					    u8 tid, u8 msduq_id);
+void ath12k_telemetry_notify_breach(u8 *mac_addr, u8 svc_id, u8 param,
+				    bool set_clear, u8 tid);
 #else /* CPTCFG_ATH12K_SAWF */
 
 static inline void ath12k_sawf_init(struct ath12k_base *ab) {
--- a/drivers/net/wireless/ath/ath12k/telemetry.h
+++ b/drivers/net/wireless/ath/ath12k/telemetry.h
@@ -101,7 +101,8 @@ struct ath12k_telemetry_ctx *get_telemet
 int ath12k_telemetry_sawf_sla_samples_config(struct ath12k_sla_samples_cfg param);
 int ath12k_telemetry_sawf_sla_thershold_config(struct ath12k_sla_thershold_cfg param);
 int ath12k_telemetry_sawf_sla_detection_config(struct ath12k_sla_detect_cfg param);
-
+bool ath12k_telemetry_get_sla_num_pkts(u32 *pkt_num);
+bool ath12k_telemetry_get_sla_mov_avg_num_pkt(u32 *mov_avg);
 #else /* CPTCFG_ATH12K_SAWF */
 
 static inline void ath12k_telemetry_init(struct ath12k_base *ab) {
--- a/drivers/net/wireless/ath/ath12k/vendor.c
+++ b/drivers/net/wireless/ath/ath12k/vendor.c
@@ -95,6 +95,18 @@ ath12k_telemetric_req_policy[QCA_WLAN_VE
 	[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_SERVICEID] = {.type = NLA_U8},
 };
 
+static const struct nla_policy
+ath12k_telemetric_sla_policy[QCA_WLAN_VENDOR_ATTR_SLA_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC] = {.type = NLA_BINARY,
+					       .len = ETH_ALEN},
+	[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SLA_PARAM] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC] = {.type = NLA_BINARY,
+						   .len = ETH_ALEN},
+	[QCA_WLAN_VENDOR_ATTR_SLA_AC] = {.type = NLA_U8},
+};
+
 static void ath12k_set_default_values(struct ath12k_sawf_svc_params *param)
 {
 	param->min_throughput_rate = SAWF_SVC_PARAM_DEFAULT_MIN_THRUPUT;
@@ -892,6 +904,110 @@ end_stats:
 	return ret;
 }
 
+static int ath12k_vendor_telemetry_sla_reset_stats(struct wiphy *wihpy,
+						   struct wireless_dev *wdev,
+						   const void *data,
+						   int data_len)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX + 1];
+	int ret = 0;
+	u8 svc_id, mac_addr[ETH_ALEN] = { 0 }, mld_mac_addr[ETH_ALEN] = { 0 }, set_clear;
+
+	if (!ath12k_sawf_enable)
+		return -EOPNOTSUPP;
+
+	ret = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SLA_MAX, data, data_len,
+			ath12k_telemetric_sla_policy, NULL);
+
+	if (ret) {
+		ath12k_err(NULL, "Invalid attribute with telemetry sla reset stats command\n");
+		return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID])
+		svc_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID]);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC] &&
+	    (nla_len(tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC]) == ETH_ALEN))
+		memcpy(mac_addr, nla_data(tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC]),
+		       ETH_ALEN);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC] &&
+	    (nla_len(tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC]) == ETH_ALEN))
+		memcpy(mld_mac_addr, nla_data(tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC]),
+		       ETH_ALEN);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR])
+		set_clear = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR]);
+
+	return ath12k_telemetry_sla_reset_stats(svc_id, mac_addr, mld_mac_addr,
+						set_clear);
+}
+
+void ath12k_vendor_telemetry_notify_breach(struct ieee80211_vif *vif, u8 *mac_addr,
+					   u8 svc_id, u8 param, bool set_clear,
+					   u8 tid, u8 *mld_addr)
+{
+	struct wireless_dev *wdev;
+	struct sk_buff *skb;
+	u8 access_category;
+
+	wdev = ieee80211_vif_to_wdev(vif);
+
+	if (!wdev)
+		return;
+
+	if (!wdev->wiphy)
+		return;
+
+	skb = cfg80211_vendor_event_alloc(wdev->wiphy, wdev, NLMSG_DEFAULT_SIZE,
+					  QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX,
+					  GFP_KERNEL);
+	if (!skb) {
+		ath12k_err(NULL, "No memory available to send notify breach event\n");
+		return;
+	}
+
+	switch (tid) {
+	case 0:
+	case 3:
+		access_category = 0; //AC_BE
+		break;
+	case 1:
+	case 2:
+		access_category = 1; //AC_BK
+		break;
+	case 4:
+	case 5:
+		access_category = 2; //AC_VI
+		break;
+	case 6:
+	case 7:
+		access_category = 3; //AC_VO
+		break;
+	default:
+		ath12k_err(NULL, "Invalid TID = %u for notifying breach event\n", tid);
+		goto err;
+	}
+
+	if (nla_put(skb, QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC, ETH_ALEN, mac_addr) ||
+	    (mld_addr && nla_put(skb, QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC,
+	    ETH_ALEN, mld_addr)) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID, svc_id) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SLA_PARAM, param) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR, set_clear) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SLA_AC, access_category)) {
+		ath12k_err(NULL, "No memory available at NL to send notify breach event\n");
+		goto err;
+	}
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	return;
+err:
+	kfree(skb);
+	return;
+}
+
 #endif /* CPTCFG_ATH12K_SAWF */
 static struct wiphy_vendor_command ath12k_vendor_commands[] = {
 #ifdef CPTCFG_ATH12K_SAWF
@@ -977,6 +1093,14 @@ static struct wiphy_vendor_command ath12
 		.maxattr = QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX,
 		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
 	},
+	{
+		.info.vendor_id = QCA_NL80211_VENDOR_ID,
+		.info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH,
+		.doit = ath12k_vendor_telemetry_sla_reset_stats,
+		.policy = ath12k_telemetric_sla_policy,
+		.maxattr = QCA_WLAN_VENDOR_ATTR_SLA_MAX,
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+	},
 #endif /* CPTCFG_ATH12K_SAWF */
 };
 
--- a/drivers/net/wireless/ath/ath12k/vendor.h
+++ b/drivers/net/wireless/ath/ath12k/vendor.h
@@ -21,6 +21,8 @@ enum qca_nl80211_vendor_subcmds {
 	QCA_NL80211_VENDOR_SUBCMD_TELEMETRY_SLA_SAMPLES_CFG = 211,
 	QCA_NL80211_VENDOR_SUBCMD_TELEMETRY_SLA_BREACH_DETECTION_CFG = 212,
 	QCA_NL80211_VENDOR_SUBCMD_SAWF_STREAMING_STATS = 213,
+	QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH = 214,
+	QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX = 215,
 	QCA_NL80211_VENDOR_SUBCMD_TELEMETRIC_DATA = 334,
 #endif /* CPTCFG_ATH12K_SAWF */
 };
@@ -451,6 +453,42 @@ struct unified_stats {
 	void *feat[STATS_FEAT_MAX];
 	u_int32_t size[STATS_FEAT_MAX];
 };
+
+/**
+ * enum qca_wlan_vendor_attr_sawf_sla_params - This enum defines
+ * attributes required for QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH
+ * Attributes are required to notify SLA breaches from driver to
+ * user application.
+ *
+ * @QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC: Unsigned 8-bit array
+ * of size 6, representing peer mac address.
+ * @QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID: Unsigned 8-bit representing service ID
+ * @QCA_WLAN_VENDOR_ATTR_SLA_PARAM: Unsigned 8-bit indicaing service class
+ * from qca_vendor_attr_sla_param_type
+ * @QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC: Unsigned 8-bit array
+ * of size 6, representing peer mld mac address. Filled only for ML capable
+ * peers
+ * @QCA_WLAN_VENDOR_ATTR_SLA_AC: Unsigned 8-bit representing AC for breach
+ *
+ */
+enum qca_wlan_vendor_attr_sawf_sla_params {
+	QCA_WLAN_VENDOR_ATTR_SLA_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC = 1,
+	QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID = 2,
+	QCA_WLAN_VENDOR_ATTR_SLA_PARAM = 3,
+	QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR = 4,
+	QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC = 5,
+	QCA_WLAN_VENDOR_ATTR_SLA_AC = 6,
+
+	/* Keep last */
+	QCA_WLAN_VENDOR_ATTR_SLA_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SLA_MAX =
+		QCA_WLAN_VENDOR_ATTR_SLA_AFTER_LAST - 1
+};
+
+void ath12k_vendor_telemetry_notify_breach(struct ieee80211_vif *vif, u8 *mac_addr,
+					   u8 svc_id, u8 param, bool set_clear,
+					   u8 tid, u8 *mld_addr);
 #endif /* CPTCFG_ATH12K_SAWF */
 
 int ath12k_vendor_register(struct ath12k_hw *ah);
