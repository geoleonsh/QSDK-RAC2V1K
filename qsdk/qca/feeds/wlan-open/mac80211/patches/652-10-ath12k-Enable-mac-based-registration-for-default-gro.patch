From 01d34e048c112f2edf4ceeef33fceacbb13b0668 Mon Sep 17 00:00:00 2001
From: Karthikeyan Periyasamy <quic_periyasa@quicinc.com>
Date: Tue, 7 Jun 2022 11:43:30 +0530
Subject: [PATCH 1/2] ath12k: Enable mac based registration for default group

Previously by default, all pdev within the SOC get combined
and registered as single wiphy. But now we go as legacy, where
each pdev get registered as separate wiphy.

Signed-off-by: Karthikeyan Periyasamy <quic_periyasa@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/core.c |  21 ++-
 drivers/net/wireless/ath/ath12k/core.h |  11 +-
 drivers/net/wireless/ath/ath12k/mac.c  | 303 ++++++++++++++++++++++-----------
 drivers/net/wireless/ath/ath12k/wmi.c  |   6 +-
 4 files changed, 228 insertions(+), 113 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -1088,13 +1088,20 @@ static void ath12k_core_restart(struct w
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
 	struct ath12k_vif *arvif;
+	struct ath12k_hw *ah;
 	int i, j;
 
 	spin_lock_bh(&ab->base_lock);
 	ab->stats.fw_crash_counter++;
 	spin_unlock_bh(&ab->base_lock);
 
-	ieee80211_stop_queues(ag->ah->hw);
+	for (i = 0; i < ag->num_hw; i++) {
+		ah = ag->ah[i];
+		if (!ah)
+			continue;
+
+		ieee80211_stop_queues(ah->hw);
+	}
 
 	for (i = 0; i < ag->num_chip; i++) {
 		ab = ag->ab[i];
@@ -1183,9 +1190,15 @@ static void ath12k_core_restart(struct w
 		complete(&ab->driver_recovery);
 	}
 
-	mutex_lock(&ag->ah->conf_mutex);
-	ieee80211_restart_hw(ag->ah->hw);
-	mutex_unlock(&ag->ah->conf_mutex);
+	for (i = 0; i < ag->num_hw; i++) {
+		ah = ag->ah[i];
+		if (!ah)
+			continue;
+
+		mutex_lock(&ah->conf_mutex);
+		ieee80211_restart_hw(ah->hw);
+		mutex_unlock(&ah->conf_mutex);
+	}
 }
 
 static void ath12k_core_reset(struct work_struct *work)
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -175,8 +175,9 @@ struct ath12k_he {
 	u32 heop_param;
 };
 
-#define MAX_RADIOS 3
-#define ATH12K_MAX_SOCS 3
+#define MAX_RADIOS             3
+#define ATH12K_MAX_SOCS        3
+#define ATH12K_GROUP_MAX_RADIO (ATH12K_MAX_SOCS * MAX_RADIOS)
 #define ATH12K_INVALID_GRP_ID  0xFF
 #define ATH12K_INVALID_CHIP_ID 0xFF
 enum {
@@ -624,7 +625,7 @@ enum ath12k_fw_recovery_option {
 
 struct ath12k {
 	struct ath12k_base *ab;
-	struct ieee80211_hw *hw;
+	struct ath12k_hw *ah;
 	struct ath12k_pdev *pdev;
 	struct ath12k_pdev_wmi *wmi;
 	struct ath12k_pdev_dp dp;
@@ -887,13 +888,15 @@ struct ath12k_hw {
 
 /* Holds info on the group of SOCs that are registered as a single wiphy */
 struct ath12k_hw_group {
+	/* Keep this always as first member */
+	struct list_head list;
 	u8 id;
 	u8 num_chip;
 	u8 num_probed;
 	u8 num_started;
+	u8 num_hw;
 	unsigned long dev_flags;
-	struct list_head list;
-	struct ath12k_hw *ah;
+	struct ath12k_hw *ah[ATH12K_GROUP_MAX_RADIO];
 	struct ath12k_base *ab[ATH12K_MAX_SOCS];
 	struct mutex mutex_lock;
 };
@@ -903,7 +906,6 @@ struct ath12k_base {
 	enum ath12k_hw_rev hw_rev;
 	struct platform_device *pdev;
 	struct device *dev;
-	struct ath12k_hw *ah;
 	struct ath12k_hw_group *ag;
 	struct ath12k_qmi qmi;
 	struct ath12k_wmi_base wmi_ab;
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -593,7 +593,7 @@ struct ath12k_vif *ath12k_mac_get_arvif(
 	arvif_iter.ar = ar;
 
 	flags = IEEE80211_IFACE_ITER_RESUME_ALL;
-	ieee80211_iterate_active_interfaces_atomic(ar->hw,
+	ieee80211_iterate_active_interfaces_atomic(ar->ah->hw,
 						   flags,
 						   ath12k_get_arvif_iter,
 						   &arvif_iter);
@@ -1147,7 +1147,7 @@ static int ath12k_mac_monitor_start(stru
 	if (test_bit(MONITOR_VDEV_STARTED, &ar->monitor_flags))
 		return 0;
 
-	ieee80211_iter_chan_contexts_atomic(ar->hw,
+	ieee80211_iter_chan_contexts_atomic(ar->ah->hw,
 					    ath12k_mac_get_any_chandef_iter,
 					    &chandef);
 	if (!chandef)
@@ -1375,7 +1375,7 @@ static int ath12k_mac_setup_bcn_tmpl_ema
 		return -1;
 
 	tx_arvif = (void *)arvif->vif->mbssid_tx_vif->drv_priv;
-	beacons = ieee80211_beacon_get_template_ema_list(tx_arvif->ar->hw,
+	beacons = ieee80211_beacon_get_template_ema_list(tx_arvif->ar->ah->hw,
 							 tx_arvif->vif, 0);
 	if (!beacons || !beacons->cnt) {
 		ath12k_warn(arvif->ar->ab,
@@ -1423,7 +1423,7 @@ static int ath12k_mac_setup_bcn_tmpl_non
 	if (arvif->vif->mbssid_tx_vif)
 		tx_arvif = (void *)arvif->vif->mbssid_tx_vif->drv_priv;
 
-	bcn = ieee80211_beacon_get_template(tx_arvif->ar->hw, tx_arvif->vif,
+	bcn = ieee80211_beacon_get_template(tx_arvif->ar->ah->hw, tx_arvif->vif,
 					    &offs, 0);
 	if (!bcn) {
 		ath12k_warn(arvif->ar->ab,
@@ -1569,7 +1569,7 @@ static void ath12k_peer_assoc_h_basic(st
 	arg->peer_associd = aid;
 	arg->auth_flag = true;
 	/* TODO: STA WAR in ath10k for listen interval required? */
-	arg->peer_listen_intval = ar->hw->conf.listen_interval;
+	arg->peer_listen_intval = ar->ah->hw->conf.listen_interval;
 	arg->peer_nss = 1;
 	arg->peer_caps = vif->bss_conf.assoc_capability;
 }
@@ -1585,13 +1585,15 @@ static void ath12k_peer_assoc_h_crypto(s
 	struct ath12k_vif *arvif = (struct ath12k_vif *)vif->drv_priv;
 	const u8 *rsnie = NULL;
 	const u8 *wpaie = NULL;
+	struct ieee80211_hw *hw;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
 	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
 		return;
 
-	bss = cfg80211_get_bss(ar->hw->wiphy, def.chan, info->bssid, NULL, 0,
+	hw = ar->ah->hw;
+	bss = cfg80211_get_bss(hw->wiphy, def.chan, info->bssid, NULL, 0,
 			       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
 
 	if (arvif->rsnie_present || arvif->wpaie_present) {
@@ -1611,7 +1613,7 @@ static void ath12k_peer_assoc_h_crypto(s
 						ies->data,
 						ies->len);
 		rcu_read_unlock();
-		cfg80211_put_bss(ar->hw->wiphy, bss);
+		cfg80211_put_bss(hw->wiphy, bss);
 	}
 
 	/* FIXME: base on RSN IE/WPA IE is a correct idea? */
@@ -1656,7 +1658,7 @@ static void ath12k_peer_assoc_h_rates(st
 		return;
 
 	band = def.chan->band;
-	sband = ar->hw->wiphy->bands[band];
+	sband = ar->ah->hw->wiphy->bands[band];
 	ratemask = sta->deflink.supp_rates[band];
 	ratemask &= arvif->bitrate_mask.control[band].legacy;
 	rates = sband->bitrates;
@@ -3354,7 +3356,7 @@ static void ath12k_recalculate_mgmt_rate
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	sband = ar->hw->wiphy->bands[def->chan->band];
+	sband = ar->ah->hw->wiphy->bands[def->chan->band];
 	basic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;
 	bitrate = sband->bitrates[basic_rate_idx].bitrate;
 
@@ -3382,6 +3384,7 @@ static int ath12k_mac_fils_discovery(str
 {
 	struct ath12k *ar = arvif->ar;
 	struct sk_buff *tmpl;
+	struct ath12k_hw *ah = ar->ah;
 	int ret;
 	u32 interval;
 	bool unsol_bcast_probe_resp_enabled = false;
@@ -3389,7 +3392,7 @@ static int ath12k_mac_fils_discovery(str
 	if (info->fils_discovery.max_interval) {
 		interval = info->fils_discovery.max_interval;
 
-		tmpl = ieee80211_get_fils_discovery_tmpl(ar->hw, arvif->vif);
+		tmpl = ieee80211_get_fils_discovery_tmpl(ah->hw, arvif->vif);
 		if (tmpl)
 			ret = ath12k_wmi_fils_discovery_tmpl(ar, arvif->vdev_id,
 							     tmpl);
@@ -3397,7 +3400,7 @@ static int ath12k_mac_fils_discovery(str
 		unsol_bcast_probe_resp_enabled = 1;
 		interval = info->unsol_bcast_probe_resp_interval;
 
-		tmpl = ieee80211_get_unsol_bcast_probe_resp_tmpl(ar->hw,
+		tmpl = ieee80211_get_unsol_bcast_probe_resp_tmpl(ah->hw,
 								 arvif->vif);
 		if (tmpl)
 			ret = ath12k_wmi_probe_resp_tmpl(ar, arvif->vdev_id,
@@ -4057,6 +4060,8 @@ ath12k_mac_select_scan_device(struct iee
 
 void __ath12k_mac_scan_finish(struct ath12k *ar)
 {
+	struct ath12k_hw *ah = ar->ah;
+
 	lockdep_assert_held(&ar->data_lock);
 
 	switch (ar->scan.state) {
@@ -4070,9 +4075,9 @@ void __ath12k_mac_scan_finish(struct ath
 					    ATH12K_SCAN_ABORTING),
 			};
 
-			ieee80211_scan_completed(ar->hw, &info);
+			ieee80211_scan_completed(ah->hw, &info);
 		} else if (ar->scan.roc_notify) {
-			ieee80211_remain_on_channel_expired(ar->hw);
+			ieee80211_remain_on_channel_expired(ah->hw);
 		}
 		fallthrough;
 	case ATH12K_SCAN_STARTING:
@@ -4337,7 +4342,7 @@ static int ath12k_mac_op_hw_scan(struct
 	}
 
 	/* Add a 200ms margin to account for event/command processing */
-	ieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,
+	ieee80211_queue_delayed_work(ar->ah->hw, &ar->scan.timeout,
 				     msecs_to_jiffies(arg.max_scan_time +
 						      ATH12K_MAC_SCAN_TIMEOUT_MSECS));
 
@@ -4503,7 +4508,7 @@ static int ath12k_mac_set_key(struct ath
 	int ret = 0;
 	u32 flags = 0;
 
-	lockdep_assert_held(&ar->ab->ah->conf_mutex);
+	lockdep_assert_held(&ar->ah->conf_mutex);
 
 	ab = ar->ab;
 
@@ -6536,7 +6541,7 @@ static void ath12k_mgmt_over_wmi_tx_drop
 {
 	int num_mgmt;
 
-	ieee80211_free_txskb(ar->hw, skb);
+	ieee80211_free_txskb(ar->ah->hw, skb);
 
 	num_mgmt = atomic_dec_if_positive(&ar->num_pending_mgmt_tx);
 
@@ -6736,6 +6741,7 @@ static void ath12k_mac_op_tx(struct ieee
 	struct ieee80211_vif *vif = info->control.vif;
 	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
 	struct ath12k *ar = arvif->ar;
+	struct ath12k_hw *ah = ar->ah;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_key_conf *key = info->control.hw_key;
 	struct ath12k_sta *arsta = NULL;
@@ -6759,7 +6765,7 @@ static void ath12k_mac_op_tx(struct ieee
 		if (ret) {
 			ath12k_warn(ar->ab, "failed to queue management frame %d\n",
 				    ret);
-			ieee80211_free_txskb(ar->hw, skb);
+			ieee80211_free_txskb(ah->hw, skb);
 		}
 		return;
 	}
@@ -6774,7 +6780,7 @@ static void ath12k_mac_op_tx(struct ieee
 		else
 			ath12k_warn(ar->ab, "failed to transmit frame %d\n",
 				    ret);
-		ieee80211_free_txskb(ar->hw, skb);
+		ieee80211_free_txskb(ah->hw, skb);
 	}
 }
 
@@ -7073,7 +7079,7 @@ static int ath12k_mac_setup_vdev_params_
 	tx_arvif = (void *)tx_vif->drv_priv;
 
 	if (arvif->vif->bss_conf.nontransmitted) {
-		if (ar->hw->wiphy != ieee80211_vif_to_wdev(tx_vif)->wiphy)
+		if (ar->ah->hw->wiphy != ieee80211_vif_to_wdev(tx_vif)->wiphy)
 			return -EINVAL;
 
 		*flags = WMI_HOST_VDEV_FLAGS_NON_TRANSMIT_AP;
@@ -7210,7 +7216,7 @@ static int ath12k_mac_vdev_create(struct
 {
 	struct ath12k_base *ab = ar->ab;
 	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
-	struct ieee80211_hw *hw = ab->ah->hw;
+	struct ieee80211_hw *hw = ar->ah->hw;
 	struct vdev_create_params vdev_param = {0};
 	struct peer_create_params peer_param;
 	u32 param_id, param_value;
@@ -7433,7 +7439,7 @@ err:
 
 static void ath12k_mac_vif_cache_flush(struct ath12k *ar,  struct ieee80211_vif *vif)
 {
-	struct ath12k_hw *ah = ar->ab->ah;
+	struct ath12k_hw *ah = ar->ah;
 	struct ath12k_vif *arvif = (void *)vif->drv_priv;
 	int ret;
 
@@ -8096,7 +8102,7 @@ static int ath12k_mac_num_chanctxs(struc
 {
         int num = 0;
 
-        ieee80211_iter_chan_contexts_atomic(ar->hw,
+        ieee80211_iter_chan_contexts_atomic(ar->ah->hw,
                                             ath12k_mac_num_chanctxs_iter,
                                             &num);
 
@@ -8131,7 +8137,7 @@ static void ath12k_mac_update_rx_channel
          */
         rcu_read_lock();
         if (!ctx && ath12k_mac_num_chanctxs(ar) == 1) {
-                ieee80211_iter_chan_contexts_atomic(ar->hw,
+                ieee80211_iter_chan_contexts_atomic(ar->ah->hw,
                                                     ath12k_mac_get_any_chandef_iter,
                                                     &def);
                 if (vifs)
@@ -8274,10 +8280,11 @@ ath12k_mac_update_active_vif_chan(struct
 				  struct ieee80211_chanctx_conf *ctx)
 {
 	struct ath12k_mac_change_chanctx_arg arg = { .ctx = ctx, .ar = ar };
+	struct ath12k_hw *ah = ar->ah;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	ieee80211_iterate_active_interfaces_atomic(ar->hw,
+	ieee80211_iterate_active_interfaces_atomic(ah->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   ath12k_mac_change_chanctx_cnt_iter,
 						   &arg);
@@ -8288,7 +8295,7 @@ ath12k_mac_update_active_vif_chan(struct
 	if (!arg.vifs)
 		return;
 
-	ieee80211_iterate_active_interfaces_atomic(ar->hw,
+	ieee80211_iterate_active_interfaces_atomic(ah->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   ath12k_mac_change_chanctx_fill_iter,
 						   &arg);
@@ -8516,7 +8523,7 @@ static void ath12k_mac_get_psd_channel(s
         */
        *center_freq = *start_freq + i * step_freq;
        /* -1 to reg_6g_power_mode to make it 0 based indexing */
-       *temp_chan = ieee80211_get_6g_channel_khz(ar->hw->wiphy, MHZ_TO_KHZ(*center_freq),
+       *temp_chan = ieee80211_get_6g_channel_khz(ar->ah->hw->wiphy, MHZ_TO_KHZ(*center_freq),
                                                  reg_6g_power_mode - 1);
        *tx_power = (*temp_chan)->max_reg_power;
 }
@@ -8549,7 +8556,7 @@ static void ath12k_mac_get_eirp_power(st
                *center_freq += 10;
 
        /* -1 to reg_6g_power_mode to make it 0 based indexing */
-       *temp_chan = ieee80211_get_6g_channel_khz(ar->hw->wiphy, MHZ_TO_KHZ(*center_freq),
+       *temp_chan = ieee80211_get_6g_channel_khz(ar->ah->hw->wiphy, MHZ_TO_KHZ(*center_freq),
                                                   reg_6g_power_mode - 1);
        *tx_power = (*temp_chan)->max_reg_power;
 }
@@ -9202,7 +9209,7 @@ static void ath12k_mac_flush(struct ath1
 	struct ath12k_base *ab = ar->ab;
 	long time_left;
 
-	lockdep_assert_held(&ar->ab->ah->conf_mutex);
+	lockdep_assert_held(&ar->ah->conf_mutex);
 
 	time_left = wait_event_timeout(ar->dp.tx_empty_waitq,
 				       (atomic_read(&ar->dp.num_tx_pending) == 0),
@@ -9734,7 +9741,7 @@ static void ath12k_mac_set_bitrate_mask_
 	arsta->changed |= IEEE80211_RC_SUPP_RATES_CHANGED;
 	spin_unlock_bh(&ar->data_lock);
 
-	ieee80211_queue_work(ar->hw, &arsta->update_wk);
+	ieee80211_queue_work(ar->ah->hw, &arsta->update_wk);
 }
 
 static void ath12k_mac_disable_peer_fixed_rate(void *data,
@@ -9891,7 +9898,7 @@ ath12k_mac_op_set_bitrate_mask(struct ie
 				    arvif->vdev_id, ret);
 			goto out;
 		}
-		ieee80211_iterate_stations_atomic(ar->hw,
+		ieee80211_iterate_stations_atomic(hw,
 						  ath12k_mac_disable_peer_fixed_rate,
 						  arvif);
 	} else if (ath12k_mac_bitrate_mask_get_single_nss(ar, band, mask,
@@ -9900,7 +9907,7 @@ ath12k_mac_op_set_bitrate_mask(struct ie
 		nss = single_nss;
 		mutex_lock(&ar->conf_mutex);
 		arvif->bitrate_mask = *mask;
-		ieee80211_iterate_stations_atomic(ar->hw,
+		ieee80211_iterate_stations_atomic(hw,
 						  ath12k_mac_set_bitrate_mask_iter,
 						  arvif);
 		mutex_unlock(&ar->conf_mutex);
@@ -9977,12 +9984,12 @@ ath12k_mac_op_set_bitrate_mask(struct ie
 		}
 
 		mutex_lock(&ar->conf_mutex);
-		ieee80211_iterate_stations_atomic(ar->hw,
+		ieee80211_iterate_stations_atomic(hw,
 						  ath12k_mac_disable_peer_fixed_rate,
 						  arvif);
 
 		arvif->bitrate_mask = *mask;
-		ieee80211_iterate_stations_atomic(ar->hw,
+		ieee80211_iterate_stations_atomic(hw,
 						  ath12k_mac_set_bitrate_mask_iter,
 						  arvif);
 
@@ -10320,7 +10327,7 @@ static int ath12k_mac_setup_channels_rat
 					   u32 supported_bands)
 {
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_hw *ah = ar->ab->ah;
+	struct ath12k_hw *ah = ar->ah;
 	struct ieee80211_supported_band *band;
 	struct ath12k_hal_reg_capabilities_ext *reg_cap, *temp_reg_cap;
 	void *channels;
@@ -10350,7 +10357,7 @@ static int ath12k_mac_setup_channels_rat
 		band->channels = channels;
 		band->n_bitrates = ath12k_g_rates_size;
 		band->bitrates = ath12k_g_rates;
-		ar->hw->wiphy->bands[NL80211_BAND_2GHZ] = band;
+		ah->hw->wiphy->bands[NL80211_BAND_2GHZ] = band;
 
 		if (ab->hw_params->single_pdev_only) {
 			phy_id = ath12k_get_phy_id(ar, WMI_HOST_WLAN_2G_CAP);
@@ -10389,7 +10396,7 @@ static int ath12k_mac_setup_channels_rat
                         band->channels = channels;
                         band->n_bitrates = ath12k_a_rates_size;
                         band->bitrates = ath12k_a_rates;
-                        ar->hw->wiphy->bands[NL80211_BAND_5GHZ] = band;
+                        ah->hw->wiphy->bands[NL80211_BAND_5GHZ] = band;
 
                         if (ar->ab->hw_params->single_pdev_only) {
                                 phy_id = ath12k_get_phy_id(ar, WMI_HOST_WLAN_5G_CAP);
@@ -10437,7 +10444,7 @@ static int ath12k_mac_setup_channels_rat
                         ar->supports_6ghz = true;
                         band->n_bitrates = ath12k_a_rates_size;
                         band->bitrates = ath12k_a_rates;
-                        ar->hw->wiphy->bands[NL80211_BAND_6GHZ] = band;
+                        ah->hw->wiphy->bands[NL80211_BAND_6GHZ] = band;
 
                         ath12k_mac_update_ch_list(ar, band,
 						  max(temp_reg_cap->low_5ghz_chan,
@@ -10461,18 +10468,23 @@ static int ath12k_mac_setup_channels_rat
 	return 0;
 }
 
-static int ath12k_mac_setup_iface_combinations(struct ath12k_base *ab)
+static int ath12k_mac_setup_iface_combinations(struct ath12k_hw *ah)
 {
-	struct ieee80211_hw *hw = ab->ah->hw;
+	struct ieee80211_hw *hw = ah->hw;
 	struct ieee80211_iface_combination *combinations;
 	struct ieee80211_iface_limit *limits;
+	struct ath12k_base *ab_dflt;
+	struct ath12k *ar;
 	int n_limits, max_interfaces;
 	bool ap, mesh;
 
-	ap = ab->hw_params->interface_modes & BIT(NL80211_IFTYPE_AP);
+	ar = ah->radio;
+	ab_dflt = ar->ab;
+
+	ap = ab_dflt->hw_params->interface_modes & BIT(NL80211_IFTYPE_AP);
 
 	mesh = IS_ENABLED(CPTCFG_MAC80211_MESH) &&
-		ab->hw_params->interface_modes & BIT(NL80211_IFTYPE_MESH_POINT);
+		ab_dflt->hw_params->interface_modes & BIT(NL80211_IFTYPE_MESH_POINT);
 
 	combinations = kzalloc(sizeof(*combinations), GFP_KERNEL);
 	if (!combinations)
@@ -10585,15 +10597,11 @@ static void __ath12k_mac_unregister(stru
 	__ath12k_mac_post_unregister(ar);
 }
 
-void ath12k_mac_unregister(struct ath12k_hw_group *ag)
+static void ath12k_mac_hw_unregister(struct ath12k_hw *ah)
 {
-	struct ath12k_hw *ah = ag->ah;
 	struct ath12k *ar;
 	int i;
 
-	if (!ah)
-		return;
-
 	ar = ah->radio;
 	for (i = 0; i < ah->num_radio; i++) {
 		__ath12k_mac_pre_unregister(ar);
@@ -10614,6 +10622,20 @@ void ath12k_mac_unregister(struct ath12k
 	SET_IEEE80211_DEV(ah->hw, NULL);
 }
 
+void ath12k_mac_unregister(struct ath12k_hw_group *ag)
+{
+	struct ath12k_hw *ah = ag->ah;
+	int i;
+
+	for (i = 0; i < ag->num_hw; i++) {
+		ah = ag->ah[i];
+		if (!ah)
+			continue;
+
+		ath12k_mac_hw_unregister(ah);
+	}
+}
+
 static int __ath12k_mac_register(struct ath12k *ar)
 {
 	struct ieee80211_hw *hw;
@@ -10621,7 +10643,7 @@ static int __ath12k_mac_register(struct
 	int ret;
 	u32 ht_cap = 0;
 
-	hw = ar->hw;
+	hw = ar->ah->hw;
 	init_waitqueue_head(&ar->txmgmt_empty_waitq);
 	idr_init(&ar->txmgmt_idr);
 	spin_lock_init(&ar->txmgmt_idr_lock);
@@ -10660,11 +10682,10 @@ static int __ath12k_mac_register(struct
 	return 0;
 }
 
-int ath12k_mac_register(struct ath12k_hw_group *ag)
+static int ath12k_mac_hw_register(struct ath12k_hw *ah)
 {
 	struct ieee80211_hw *hw;
 	struct ath12k_pdev_cap *cap;
-	struct ath12k_hw *ah;
 	struct ath12k_base *ab, *ab_dflt;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
@@ -10683,12 +10704,6 @@ int ath12k_mac_register(struct ath12k_hw
 		WLAN_CIPHER_SUITE_CCMP_256,
 	};
 
-	/* Use the first chip in group to advertise some features/info
-	 * these are expected to be similar for chips in group
-	 */
-	ab_dflt = ag->ab[0];
-
-	ah = ag->ah;
 	hw = ah->hw;
 	hw->wiphy->max_ap_assoc_sta = 0;
 	antennas_rx = 0;
@@ -10697,6 +10712,11 @@ int ath12k_mac_register(struct ath12k_hw
 	ar = ah->radio;
 	ab = ar->ab;
 
+	/* Use the first chip in group to advertise some features/info
+	 * these are expected to be similar for chips in group
+	 */
+	ab_dflt = ab;
+
 	for (i = 0; i < ah->num_radio; i++) {
 		ab = ar->ab;
 		pdev = ar->pdev;
@@ -10727,9 +10747,9 @@ int ath12k_mac_register(struct ath12k_hw
 	hw->wiphy->available_antennas_tx = antennas_tx;
 
 	/* TODO: Add link/ar specific iface combinations
-	 * For now, setting up combination once for the group
+	 * For now, setting up combination once for the wiphy (ah)
 	 */
-	ret = ath12k_mac_setup_iface_combinations(ab_dflt);
+	ret = ath12k_mac_setup_iface_combinations(ah);
 	if (ret) {
 		ath12k_err(NULL, "failed to setup interface combinations: %d\n",
 			   ret);
@@ -10769,7 +10789,7 @@ int ath12k_mac_register(struct ath12k_hw
 		ieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);
 	}
 
-	if (ab->hw_params->supports_ap_ps)
+	if (ab_dflt->hw_params->supports_ap_ps)
 		ieee80211_hw_set(hw, SUPPORTS_AP_PS);
 
 	hw->wiphy->features |= NL80211_FEATURE_STATIC_SMPS;
@@ -10810,7 +10830,7 @@ int ath12k_mac_register(struct ath12k_hw
 	hw->wiphy->iftype_ext_capab = ath12k_iftypes_ext_capa;
 	hw->wiphy->num_iftype_ext_capab = ARRAY_SIZE(ath12k_iftypes_ext_capa);
 
-	hw->wiphy->mbssid_max_interfaces = ab->num_radios * TARGET_NUM_VDEVS;
+	hw->wiphy->mbssid_max_interfaces = ah->num_radio * TARGET_NUM_VDEVS;
 	hw->wiphy->ema_max_profile_periodicity = TARGET_EMA_MAX_PROFILE_PERIOD;
 
 	ah->hw->wiphy->regulatory_flags = REGULATORY_WIPHY_SELF_MANAGED;
@@ -10883,6 +10903,35 @@ err_cleanup:
 	return ret;
 }
 
+int ath12k_mac_register(struct ath12k_hw_group *ag)
+{
+	struct ath12k_hw *ah;
+	int ret, i;
+
+	for (i = 0; i < ag->num_hw; i++) {
+		ah = ag->ah[i];
+		if (!ah)
+			continue;
+
+		ret = ath12k_mac_hw_register(ah);
+		if (ret)
+			goto err_mac_unregister;
+	}
+
+	return 0;
+
+err_mac_unregister:
+	for (i = i - 1; i >= 0; i--) {
+		ah = ag->ah[i];
+		if (!ah)
+			continue;
+
+		ath12k_mac_hw_unregister(ah);
+	}
+
+	return ret;
+}
+
 static inline struct ath12k *ath12k_mac_get_ar(struct ath12k_hw *ah,
 					       u8 link_idx)
 {
@@ -10894,71 +10943,58 @@ static inline struct ath12k *ath12k_mac_
 	return ar + link_idx;
 }
 
-static int ath12k_mac_chip_setup(struct ath12k_hw *ah, u8 *link_id,
-				 struct ath12k_base *ab)
+static int ath12k_mac_setup(struct ath12k_hw *ah, u8 link_id,
+			    struct ath12k_base *ab, int mac_id)
 {
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
-	int i;
-
-	ab->ah = ah;
-
-	for (i = 0; i < ab->num_radios; i++) {
-		pdev = &ab->pdevs[i];
-		ar = ath12k_mac_get_ar(ah, *link_id);
-		if (!ar)
-			return -EINVAL;
 
-		ar->ab = ab;
-		ar->hw = ah->hw;
-		ar->pdev = pdev;
-		ar->pdev_idx = i;
-		ar->lmac_id = ath12k_hw_get_mac_from_pdev_id(ab->hw_params, i);
-		ar->link_idx = *link_id;
-
-		ar->wmi = &ab->wmi_ab.wmi[i];
-		/* FIXME wmi[0] is already initialized during attach,
-		 * Should we do this again?
-		 */
-		ath12k_wmi_pdev_attach(ab, i);
+	pdev = &ab->pdevs[mac_id];
+	ar = ath12k_mac_get_ar(ah, link_id);
+	if (!ar)
+		return -EINVAL;
 
-		ar->cfg_tx_chainmask = pdev->cap.tx_chain_mask;
-		ar->cfg_rx_chainmask = pdev->cap.rx_chain_mask;
-		ar->num_tx_chains = get_num_chains(pdev->cap.tx_chain_mask);
-		ar->num_rx_chains = get_num_chains(pdev->cap.rx_chain_mask);
-
-		pdev->ar = ar;
-		spin_lock_init(&ar->data_lock);
-		INIT_LIST_HEAD(&ar->arvifs);
-		INIT_LIST_HEAD(&ar->ppdu_stats_info);
-		mutex_init(&ar->conf_mutex);
-		init_completion(&ar->vdev_setup_done);
-		init_completion(&ar->vdev_delete_done);
-		init_completion(&ar->peer_assoc_done);
-		init_completion(&ar->peer_delete_done);
-		init_completion(&ar->install_key_done);
-		init_completion(&ar->bss_survey_done);
-		init_completion(&ar->scan.started);
-		init_completion(&ar->scan.completed);
-		init_completion(&ar->thermal.wmi_sync);
-
-		INIT_DELAYED_WORK(&ar->scan.timeout, ath12k_scan_timeout_work);
-		INIT_WORK(&ar->regd_update_work, ath12k_regd_update_work);
-
-		INIT_WORK(&ar->wmi_mgmt_tx_work, ath12k_mgmt_over_wmi_tx_work);
-		skb_queue_head_init(&ar->wmi_mgmt_tx_queue);
-		clear_bit(MONITOR_VDEV_STARTED, &ar->monitor_flags);
-		ar->monitor_vdev_id = -1;
-		clear_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags);
+	ar->ab = ab;
+	ar->ah = ah;
+	ar->pdev = pdev;
+	ar->pdev_idx = mac_id;
+	ar->lmac_id = ath12k_hw_get_mac_from_pdev_id(ab->hw_params, mac_id);
+	ar->link_idx = link_id;
+
+	ar->wmi = &ab->wmi_ab.wmi[mac_id];
+	/* FIXME wmi[0] is already initialized during attach,
+	 * Should we do this again?
+	 */
+	ath12k_wmi_pdev_attach(ab, mac_id);
 
-		*link_id = *link_id + 1;
-	}
+	ar->cfg_tx_chainmask = pdev->cap.tx_chain_mask;
+	ar->cfg_rx_chainmask = pdev->cap.rx_chain_mask;
+	ar->num_tx_chains = get_num_chains(pdev->cap.tx_chain_mask);
+	ar->num_rx_chains = get_num_chains(pdev->cap.rx_chain_mask);
+
+	pdev->ar = ar;
+	spin_lock_init(&ar->data_lock);
+	INIT_LIST_HEAD(&ar->arvifs);
+	INIT_LIST_HEAD(&ar->ppdu_stats_info);
+	mutex_init(&ar->conf_mutex);
+	init_completion(&ar->vdev_setup_done);
+	init_completion(&ar->vdev_delete_done);
+	init_completion(&ar->peer_assoc_done);
+	init_completion(&ar->peer_delete_done);
+	init_completion(&ar->install_key_done);
+	init_completion(&ar->bss_survey_done);
+	init_completion(&ar->scan.started);
+	init_completion(&ar->scan.completed);
+	init_completion(&ar->thermal.wmi_sync);
 
-	/* Initialize channel counters frequency value in hertz */
-	ab->cc_freq_hz = 320000;
-	ab->free_vdev_map = (1LL << (ab->num_radios * TARGET_NUM_VDEVS)) - 1;
+	INIT_DELAYED_WORK(&ar->scan.timeout, ath12k_scan_timeout_work);
+	INIT_WORK(&ar->regd_update_work, ath12k_regd_update_work);
 
-	ath12k_dp_pdev_pre_alloc(ab);
+	INIT_WORK(&ar->wmi_mgmt_tx_work, ath12k_mgmt_over_wmi_tx_work);
+	skb_queue_head_init(&ar->wmi_mgmt_tx_queue);
+	clear_bit(MONITOR_VDEV_STARTED, &ar->monitor_flags);
+	ar->monitor_vdev_id = -1;
+	clear_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags);
 
 	return 0;
 }
@@ -10966,40 +11002,98 @@ static int ath12k_mac_chip_setup(struct
 int ath12k_mac_allocate(struct ath12k_hw_group *ag)
 {
 	struct ieee80211_hw *hw;
+	struct ath12k_base *ab;
 	struct ath12k_hw *ah;
+	struct ieee80211_ops *ops;
 	size_t len;
-	int i, num_radios = 0, ret;
-	u8 link_id = 0;
+	int i, j, total_radio, num_radios, ret;
+	int mac_id, chip_id;
+	u8 link_id, num_hw;
 
+	total_radio = 0;
 	for (i = 0; i < ag->num_chip; i++)
-		num_radios += ag->ab[i]->num_radios;
+		total_radio += ag->ab[i]->num_radios;
 
-	len = sizeof(struct ath12k_hw) + (num_radios * sizeof(struct ath12k));
-	hw = ieee80211_alloc_hw(len, &ath12k_ops);
-	if (!hw) {
-		WARN_ON(1);
-		return -ENOMEM;
-	}
+	/* Each pdev get register separately in the default
+	 * (ATH12K_INVALID_GRP_ID) group.
+	 * where as in other group, all pdev get combined in
+	 * register as single wiphy.
+	 */
+	if (ag->id == ATH12K_INVALID_GRP_ID)
+		num_radios = 1;
+	else
+		num_radios = total_radio;
 
-	ah = hw->priv;
-	ah->hw = hw;
-	ah->ops = &ath12k_ops;
-	ah->num_radio = num_radios;
-	ag->ah = ah;
-
-	ath12k_info(NULL,
-		    "ath12k hw device created with %d radios in group %d with %d chips\n",
-		    ah->num_radio, ag->id, ag->num_chip);
+	num_hw = total_radio / num_radios;
 
-	mutex_init(&ah->conf_mutex);
+	if (num_hw >= ATH12K_GROUP_MAX_RADIO) {
+		ath12k_err(NULL, "HW count %d is not supported\n", num_hw);
+		return -ENOSPC;
+	}
 
-	for (i = 0; i < ag->num_chip; i++) {
-		ret = ath12k_mac_chip_setup(ah, &link_id, ag->ab[i]);
-		if (ret) {
-			ath12k_err(ag->ab[i], "failed to perform chip allocate for chip %d group %d\n",
-				   i, ag->id);
+	ag->num_hw = 0;
+	mac_id = 0;
+	chip_id = 0;
+	for (i = 0; i < num_hw; i++) {
+		ops = kmemdup(&ath12k_ops, sizeof(ath12k_ops), GFP_KERNEL);
+		if (!ops) {
+			ret = -ENOMEM;
+			goto err_mac_destroy;
+		}
+
+		len = sizeof(struct ath12k_hw) + (num_radios * sizeof(struct ath12k));
+		hw = ieee80211_alloc_hw(len, ops);
+		if (!hw) {
+			kfree(ops);
+			ret = -ENOMEM;
 			goto err_mac_destroy;
 		}
+
+		ah = hw->priv;
+		ah->hw = hw;
+		ah->ops = ops;
+		ah->num_radio = num_radios;
+		ag->ah[i] = ah;
+
+		ath12k_info(NULL,
+			    "ath12k hw device created with %d radios in group %d with %d chips\n",
+			     ah->num_radio, ag->id, ag->num_chip);
+
+		mutex_init(&ah->conf_mutex);
+
+		link_id = 0;
+		for (j = 0; j < num_radios; j++) {
+			ab = ag->ab[chip_id];
+			ret = ath12k_mac_setup(ah, link_id, ab, mac_id);
+			if (ret) {
+				ieee80211_free_hw(ah->hw);
+				kfree(ops);
+				ag->ah[i] = NULL;
+
+				ath12k_err(ab, "failed to setup mac %d for chip %d group %d\n",
+					   mac_id, chip_id, ag->id);
+				goto err_mac_destroy;
+			}
+
+			link_id++;
+			mac_id++;
+
+			/* If mac_id falls beyond the current chip MACs then
+			 * move to next chip
+			 */
+			if (mac_id >= ab->num_radios) {
+				chip_id++;
+				mac_id = 0;
+
+				/* Initialize channel counters frequency value in hertz */
+				ab->cc_freq_hz = 320000;
+				ab->free_vdev_map = (1LL << (ab->num_radios * TARGET_NUM_VDEVS)) - 1;
+
+				ath12k_dp_pdev_pre_alloc(ab);
+			}
+		}
+
+		ag->num_hw++;
 	}
 
 	return 0;
@@ -11015,6 +11109,7 @@ void ath12k_mac_destroy(struct ath12k_hw
 	struct ath12k_hw *ah = ag->ah;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
+	struct ieee80211_ops *ops;
 	int i, j;
 
 	if (!ah)
@@ -11035,6 +11130,14 @@ void ath12k_mac_destroy(struct ath12k_hw
 		}
 	}
 
-	ieee80211_free_hw(ah->hw);
-	ag->ah = NULL;
+	for (i = 0; i < ag->num_hw; i++) {
+		ah = ag->ah[i];
+		if (!ah)
+			continue;
+
+		ops = ah->ops;
+		ieee80211_free_hw(ah->hw);
+		kfree(ops);
+		ag->ah[i] = NULL;
+	}
 }
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -5738,7 +5738,7 @@ static int wmi_process_mgmt_tx_comp(stru
 	if ((!(info->flags & IEEE80211_TX_CTL_NO_ACK)) && !status)
 		info->flags |= IEEE80211_TX_STAT_ACK;
 
-	ieee80211_tx_status_irqsafe(ar->hw, msdu);
+	ieee80211_tx_status_irqsafe(ar->ah->hw, msdu);
 
 	num_mgmt = atomic_dec_if_positive(&ar->num_pending_mgmt_tx);
 
@@ -5881,7 +5881,7 @@ static void ath12k_wmi_event_scan_foreig
 		break;
 	case ATH12K_SCAN_RUNNING:
 	case ATH12K_SCAN_ABORTING:
-		ar->scan_channel = ieee80211_get_channel(ar->hw->wiphy,
+		ar->scan_channel = ieee80211_get_channel(ar->ah->hw->wiphy,
 							 freq);
 		break;
 	}
@@ -6021,10 +6021,11 @@ static int ath12k_pull_roam_ev(struct at
 static int freq_to_idx(struct ath12k *ar, int freq)
 {
 	struct ieee80211_supported_band *sband;
+	struct ieee80211_hw *hw = ar->ah->hw;
 	int band, ch, idx = 0;
 
 	for (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {
-		sband = ar->hw->wiphy->bands[band];
+		sband = hw->wiphy->bands[band];
 		if (!sband)
 			continue;
 
@@ -6832,7 +6833,7 @@ static int ath12k_reg_handle_chan_list(s
 		kfree(ab->new_regd[pdev_idx]);
 		ab->new_regd[pdev_idx] = regd;
 
-		ieee80211_queue_work(ab->ah->hw, &ar->regd_update_work);
+		ieee80211_queue_work(ar->ah->hw, &ar->regd_update_work);
 	} else {
 		/* Multiple events for the same *ar is not expected. But we
 		 * can still clear any previously stored default_regd if we
@@ -7226,7 +7227,7 @@ static void ath12k_mgmt_rx_event(struct
 		   status->freq, status->band, status->signal,
 		   status->rate_idx);
 
-	ieee80211_rx_ni(ab->ah->hw, skb);
+	ieee80211_rx_ni(ar->ah->hw, skb);
 
 exit:
 	rcu_read_unlock();
@@ -7386,7 +7387,7 @@ static void ath12k_peer_sta_kickout_even
 		goto exit;
 	}
 
-	sta = ieee80211_find_sta_by_ifaddr(ab->ah->hw,
+	sta = ieee80211_find_sta_by_ifaddr(ar->ah->hw,
 					   arg.mac_addr, NULL);
 	if (!sta) {
 		ath12k_warn(ab, "Spurious quick kickout for STA %pM\n",
@@ -7866,7 +7867,7 @@ ath12k_wmi_pdev_dfs_radar_detected_event
 	if (ar->dfs_block_radar_events)
 		ath12k_info(ab, "DFS Radar detected, but ignored as requested\n");
 	else
-		ieee80211_radar_detected(ab->ah->hw);
+		ieee80211_radar_detected(ar->ah->hw);
 
 exit:
 	kfree(tb);
@@ -7998,6 +7999,7 @@ ath12k_wmi_dcs_awgn_interference_event(s
         struct cfg80211_chan_def *chandef = NULL;
         struct ath12k *ar;
         const struct wmi_tlv *tlv;
+	struct ath12k_hw *ah;
         u16 tlv_tag;
         u8 *ptr;
         int ret;
@@ -8067,10 +8069,12 @@ ath12k_wmi_dcs_awgn_interference_event(s
                 goto exit;
         }
 
+	ah = ar->ah;
+
         ath12k_info(ab, "Interface(pdev %d) : AWGN interference detected\n",
                     dcs_intf_ev->pdev_id);
 
-        ieee80211_iter_chan_contexts_atomic(ar->hw, ath12k_mac_get_any_chandef_iter,
+        ieee80211_iter_chan_contexts_atomic(ah->hw, ath12k_mac_get_any_chandef_iter,
                                             &chandef);
         if (!chandef) {
                 ath12k_warn(ab, "chandef is not available\n");
@@ -8078,7 +8082,7 @@ ath12k_wmi_dcs_awgn_interference_event(s
         }
         ar->awgn_chandef = *chandef;
 
-        ieee80211_awgn_detected(ar->hw, awgn_info.chan_bw_interference_bitmap);
+        ieee80211_awgn_detected(ah->hw, awgn_info.chan_bw_interference_bitmap);
 
         spin_lock_bh(&ar->data_lock);
         ar->awgn_intf_handling_in_prog = true;
@@ -8328,7 +8332,7 @@ ath12k_wmi_pdev_update_muedca_params_sta
 						 ev->ecwmin[WMI_AC_VO]);
 	params->ac_vo.mu_edca_timer = ev->muedca_expiration_time[WMI_AC_VO];
 
-	cfg80211_update_muedca_params_event(ar->hw->wiphy, params, GFP_ATOMIC);
+	cfg80211_update_muedca_params_event(ar->ah->hw->wiphy, params, GFP_ATOMIC);
 
 	kfree(params);
 
@@ -8859,14 +8863,14 @@ static void ath12k_wmi_pdev_detach(struc
 }
 
 int ath12k_wmi_pdev_attach(struct ath12k_base *ab,
-			   u8 pdev_id)
+			   u8 pdev_idx)
 {
 	struct ath12k_pdev_wmi *wmi_handle;
 
-	if (pdev_id >= ab->hw_params->max_radios)
+	if (pdev_idx >= ab->hw_params->max_radios)
 		return -EINVAL;
 
-	wmi_handle = &ab->wmi_ab.wmi[pdev_id];
+	wmi_handle = &ab->wmi_ab.wmi[pdev_idx];
 
 	wmi_handle->wmi_ab = &ab->wmi_ab;
 
--- a/drivers/net/wireless/ath/ath12k/reg.c
+++ b/drivers/net/wireless/ath/ath12k/reg.c
@@ -164,7 +164,7 @@ int ath12k_reg_update_chan_list(struct a
 	struct ieee80211_supported_band **bands;
 	struct scan_chan_list_params *params;
 	struct ieee80211_channel *channel;
-	struct ieee80211_hw *hw = ar->hw;
+	struct ieee80211_hw *hw = ar->ah->hw;
 	struct channel_param *ch;
 	enum nl80211_band band;
 	int num_channels = 0;
@@ -278,7 +278,7 @@ int ath12k_regd_update(struct ath12k *ar
 	int i;
 
 	ab = ar->ab;
-	ah = ab->ah;
+	ah = ar->ah;
 
 	mutex_lock(&ah->conf_mutex);
 
@@ -342,9 +342,9 @@ int ath12k_regd_update(struct ath12k *ar
 	}
 
 	rtnl_lock();
-	wiphy_lock(ar->hw->wiphy);
-	ret = regulatory_set_wiphy_regd_sync(ar->hw->wiphy, regd_copy);
-	wiphy_unlock(ar->hw->wiphy);
+	wiphy_lock(ah->hw->wiphy);
+	ret = regulatory_set_wiphy_regd_sync(ah->hw->wiphy, regd_copy);
+	wiphy_unlock(ah->hw->wiphy);
 	rtnl_unlock();
 
 	kfree(regd_copy);
--- a/drivers/net/wireless/ath/ath12k/thermal.c
+++ b/drivers/net/wireless/ath/ath12k/thermal.c
@@ -157,21 +157,21 @@ int ath12k_thermal_set_throttling(struct
 
 int ath12k_thermal_register(struct ath12k_base *ab)
 {
-	struct ath12k_hw *ah;
 	struct thermal_cooling_device *cdev;
 	struct device *hwmon_dev;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
+	struct ieee80211_hw *hw;
 	int i, ret;
 	char pdev_name[20];
 
-	ah = ab->ah;
 	for (i = 0; i < ab->num_radios; i++) {
 		pdev = &ab->pdevs[i];
 		ar = pdev->ar;
 		if (!ar)
 			continue;
 
+		hw = ar->ah->hw;
 		memset(pdev_name, 0, sizeof(pdev_name));
 
 		cdev = thermal_cooling_device_register("ath12k_thermal", ar,
@@ -189,7 +189,7 @@ int ath12k_thermal_register(struct ath12
 
 		ar->thermal.cdev = cdev;
 
-		ret = sysfs_create_link(&ar->hw->wiphy->dev.kobj, &cdev->device.kobj,
+		ret = sysfs_create_link(&hw->wiphy->dev.kobj, &cdev->device.kobj,
 					pdev_name);
 		if (ret) {
 			ath12k_err(ab, "failed to create cooling device symlink\n");
@@ -199,7 +199,7 @@ int ath12k_thermal_register(struct ath12
 		if (!IS_REACHABLE(CONFIG_HWMON))
 			return 0;
 
-		hwmon_dev = devm_hwmon_device_register_with_groups(&ar->hw->wiphy->dev,
+		hwmon_dev = devm_hwmon_device_register_with_groups(&hw->wiphy->dev,
 								   "ath12k_hwmon", ar,
 								   ath12k_hwmon_groups);
 		if (IS_ERR(hwmon_dev)) {
@@ -219,25 +219,25 @@ err_thermal_destroy:
 
 void ath12k_thermal_unregister(struct ath12k_base *ab)
 {
-	struct ath12k_hw *ah;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
+	struct ieee80211_hw *hw;
 	int i;
 	char pdev_name[20];
 
-	ah = ab->ah;
 	for (i = 0; i < ab->num_radios; i++) {
 		pdev = &ab->pdevs[i];
 		ar = pdev->ar;
 		if (!ar)
 			continue;
 
+		hw = ar->ah->hw;
 		memset(pdev_name, 0, sizeof(pdev_name));
 
 		snprintf(pdev_name, sizeof(pdev_name), "%s%d", "cooling_device",
 			 ar->link_idx);
 
-		sysfs_remove_link(&ar->hw->wiphy->dev.kobj, pdev_name);
+		sysfs_remove_link(&hw->wiphy->dev.kobj, pdev_name);
 		thermal_cooling_device_unregister(ar->thermal.cdev);
 	}
 }
--- a/drivers/net/wireless/ath/ath12k/debugfs.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs.c
@@ -1362,6 +1362,7 @@ static const struct file_operations fops
 int ath12k_debugfs_register(struct ath12k *ar)
 {
 	struct ath12k_base *ab = ar->ab;
+	struct ieee80211_hw *hw = ar->ah->hw;
 	char pdev_name[5];
 	char buf[100] = {0};
 
@@ -1373,7 +1374,7 @@ int ath12k_debugfs_register(struct ath12
 
 	/* Create a symlink under ieee80211/phy* */
 	snprintf(buf, 100, "../../ath12k/%pd2", ar->debug.debugfs_pdev);
-	debugfs_create_symlink("ath12k", ar->hw->wiphy->debugfsdir, buf);
+	debugfs_create_symlink("ath12k", hw->wiphy->debugfsdir, buf);
 
 	ath12k_debugfs_htt_stats_init(ar);
 
@@ -1389,7 +1390,7 @@ int ath12k_debugfs_register(struct ath12
 			    ar->debug.debugfs_pdev, ar,
 			    &fops_pktlog_filter);
 
-	if (ar->hw->wiphy->bands[NL80211_BAND_5GHZ]) {
+	if (hw->wiphy->bands[NL80211_BAND_5GHZ]) {
 		debugfs_create_file("dfs_simulate_radar", 0200,
 				    ar->debug.debugfs_pdev, ar,
 				    &fops_simulate_radar);
@@ -1398,7 +1399,7 @@ int ath12k_debugfs_register(struct ath12
 				    &ar->dfs_block_radar_events);
 	}
 
-	if (ar->hw->wiphy->bands[NL80211_BAND_6GHZ]) {
+	if (hw->wiphy->bands[NL80211_BAND_6GHZ]) {
                 debugfs_create_file("simulate_awgn", 0200,
                                     ar->debug.debugfs_pdev, ar,
                                     &fops_simulate_awgn);
--- a/drivers/net/wireless/ath/ath12k/dp_mon.c
+++ b/drivers/net/wireless/ath/ath12k/dp_mon.c
@@ -1798,7 +1798,7 @@ ath12k_dp_mon_fill_rx_stats(struct ath12
 	}
 
 	if (unlikely(rx_status->band == NUM_NL80211_BANDS ||
-		     !ar->hw->wiphy->bands[rx_status->band])) {
+		     !ar->ah->hw->wiphy->bands[rx_status->band])) {
 		ath12k_dbg(ar->ab, ATH12K_DBG_DATA,
 			   "sband is NULL for status band 1 %d channel_num %d center_freq %d pdev_id %d\n",
 			   rx_status->band, channel_num, center_freq, ar->pdev_idx);
@@ -2191,7 +2191,7 @@ static void ath12k_dp_mon_rx_deliver_msd
 	    !(is_mcbc && rx_status->flag & RX_FLAG_DECRYPTED))
 		rx_status->flag |= RX_FLAG_8023;
 
-	ieee80211_rx_napi(ar->hw, pubsta, msdu, napi);
+	ieee80211_rx_napi(ar->ah->hw, pubsta, msdu, napi);
 }
 
 static int ath12k_dp_mon_rx_deliver(struct ath12k *ar, u32 mpdu_idx,
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -2641,7 +2641,7 @@ void ath12k_dp_rx_h_ppdu(struct ath12k *
 		rx_status->band = NL80211_BAND_5GHZ;
 	}
 
-	if (unlikely(rx_status->band == NUM_NL80211_BANDS || !ar->hw->wiphy->bands[rx_status->band])) {
+	if (unlikely(rx_status->band == NUM_NL80211_BANDS || !ar->ah->hw->wiphy->bands[rx_status->band])) {
 		ath12k_err(ar->ab, "sband is NULL for status band %d channel_num %d center_freq %d pdev_id %d\n",
 			   rx_status->band, channel_num, center_freq, ar->pdev_idx);
 
@@ -2745,7 +2745,7 @@ static void ath12k_dp_rx_deliver_msdu(st
 	    !(is_mcbc && rx_status->flag & RX_FLAG_DECRYPTED))
 		rx_status->flag |= RX_FLAG_8023;
 
-	ieee80211_rx_napi(ar->hw, pubsta, msdu, napi);
+	ieee80211_rx_napi(ar->ah->hw, pubsta, msdu, napi);
 }
 
 static int ath12k_dp_rx_process_msdu(struct ath12k *ar,
@@ -3128,7 +3128,7 @@ mic_fail:
 	ath12k_dp_rx_h_ppdu(ar, rx_desc, rxs);
 	ath12k_dp_rx_h_undecap(ar, msdu, rx_desc,
 			       HAL_ENCRYPT_TYPE_TKIP_MIC, rxs, true);
-	ieee80211_rx(ar->hw, msdu);
+	ieee80211_rx(ar->ah->hw, msdu);
 	return -EINVAL;
 }
 
--- a/drivers/net/wireless/ath/ath12k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.c
@@ -418,7 +418,7 @@ ath12k_dp_tx_htt_tx_complete_buf(struct
 		}
 	}
 
-	ieee80211_tx_status(ar->hw, msdu);
+	ieee80211_tx_status(ar->ah->hw, msdu);
 }
 
 static void
@@ -684,7 +684,7 @@ static void ath12k_dp_tx_complete_msdu(s
 	status.rates = &rate;
 	spin_unlock_bh(&ab->base_lock);
 
-	ieee80211_tx_status_ext(ar->hw, &status);
+	ieee80211_tx_status_ext(ar->ah->hw, &status);
 
 
 exit:
--- a/drivers/net/wireless/ath/ath12k/testmode.c
+++ b/drivers/net/wireless/ath/ath12k/testmode.c
@@ -38,7 +38,7 @@ void ath12k_fwlog_write(struct ath12k_ba
 		}
 	}
 
-	nl_skb = cfg80211_testmode_alloc_event_skb(ar->hw->wiphy, len, GFP_ATOMIC);
+	nl_skb = cfg80211_testmode_alloc_event_skb(ar->ah->hw->wiphy, len, GFP_ATOMIC);
 
 	if (!nl_skb) {
 		ath12k_warn(ab,  "failed to allocate skb for fwlog event\n");
@@ -74,7 +74,7 @@ bool ath12k_tm_event_wmi(struct ath12k *
 
 	consumed = true;
 
-	nl_skb = cfg80211_testmode_alloc_event_skb(ar->hw->wiphy,
+	nl_skb = cfg80211_testmode_alloc_event_skb(ar->ah->hw->wiphy,
 						   2 * sizeof(u32) + skb->len,
 						   GFP_ATOMIC);
 	if (!nl_skb) {
@@ -128,7 +128,7 @@ static int ath12k_tm_cmd_get_version(str
 		   ATH12K_TESTMODE_VERSION_MAJOR,
 		   ATH12K_TESTMODE_VERSION_MINOR);
 
-	skb = cfg80211_testmode_alloc_reply_skb(ar->hw->wiphy,
+	skb = cfg80211_testmode_alloc_reply_skb(ar->ah->hw->wiphy,
 						nla_total_size(sizeof(u32)));
 	if (!skb)
 		return -ENOMEM;
