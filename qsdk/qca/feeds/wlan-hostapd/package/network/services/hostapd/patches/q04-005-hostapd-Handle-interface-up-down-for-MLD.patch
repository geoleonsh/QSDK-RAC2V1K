From f44077849c72fc0958a604cc50ee987ffe5f3e9b Mon Sep 17 00:00:00 2001
From: Sriram R <quic_srirrama@quicinc.com>
Date: Fri, 6 Jan 2023 10:58:02 +0530
Subject: [PATCH] hostapd: Handle interface up/down for MLD

When the interface is brought down, the kernel stops all
the link bss and removes the link. This change adds
support for hostapd to free all sta and make change
to all hapd state. Similarly, on reenabling the interface
we need to add all links and reenable the beacon back.

Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
---
 src/ap/drv_callbacks.c | 92 +++++++++++++++++++++++++++++++-----------
 1 file changed, 69 insertions(+), 23 deletions(-)

--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -1967,6 +1967,81 @@ err:
 #endif /* CONFIG_OWE */
 
 
+static void hostpad_if_disable(struct hostapd_data *hapd)
+{
+	hostapd_free_stas(hapd);
+	wpa_msg(hapd->msg_ctx, MSG_INFO, INTERFACE_DISABLED);
+	hapd->disabled = 1;
+}
+
+
+static void hostpad_if_enable(struct hostapd_data *hapd)
+{
+	wpa_msg(hapd->msg_ctx, MSG_INFO, INTERFACE_ENABLED);
+	if (hapd->disabled && hapd->started) {
+		hapd->disabled = 0;
+		/*
+		 * Try to re-enable interface if the driver stopped it
+		 * when the interface got disabled.
+		 */
+		hostapd_reconfig_wpa(hapd);
+		if (hapd->wpa_auth)
+			wpa_auth_reconfig_group_keys(hapd->wpa_auth);
+		else
+			hostapd_reconfig_encryption(hapd);
+		hapd->reenable_beacon = 1;
+		ieee802_11_set_beacon(hapd);
+#ifdef NEED_AP_MLME
+	} else if (hapd->disabled && hapd->iface->cac_started) {
+		wpa_printf(MSG_DEBUG, "DFS: restarting pending CAC");
+		hostapd_handle_dfs(hapd->iface);
+#endif /* NEED_AP_MLME */
+	}
+}
+
+
+static void hostapd_mld_if_disable(struct hostapd_mld *mld)
+{
+	struct hostapd_data *hapd;
+
+	for (hapd = mld->bss; hapd != NULL; hapd = hapd->nbss)
+		hostpad_if_disable(hapd);
+}
+
+
+static void hostapd_mld_if_enable(struct hostapd_mld *mld)
+{
+	struct wpa_driver_link_params params;
+	struct hostapd_data *hapd;
+	bool cac_enabled_hapd_found = false;
+
+	/* Re add all the links corresponding to the link bss
+	 * before starting each, so that drivers can sync and wait
+	 */
+	for (hapd = mld->bss; hapd != NULL; hapd = hapd->nbss) {
+		params.link_id = hapd->iface->mlo_link_id;
+		params.link_addr = hapd->conf->bssid;
+		hostapd_drv_add_link(hapd, &params);
+	}
+
+	/* Check if any link bss was going through active CAC, in that case,
+	 * partner links would have not started beaconing and we can only
+	 * start the CAC again */
+	for (hapd = mld->bss; hapd != NULL; hapd = hapd->nbss) {
+		if (hapd->disabled && hapd->iface->cac_started) {
+			hostpad_if_enable(hapd);
+			cac_enabled_hapd_found = true;
+		}
+	}
+
+	if (cac_enabled_hapd_found)
+		return;
+
+	for (hapd = mld->bss; hapd != NULL; hapd = hapd->nbss)
+		hostpad_if_enable(hapd);
+}
+
+
 void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
 			  union wpa_event_data *data)
 {
@@ -2173,31 +2248,16 @@ void hostapd_wpa_event(void *ctx, enum w
 		break;
 #endif /* NEED_AP_MLME */
 	case EVENT_INTERFACE_ENABLED:
-		wpa_msg(hapd->msg_ctx, MSG_INFO, INTERFACE_ENABLED);
-		if (hapd->disabled && hapd->started) {
-			hapd->disabled = 0;
-			/*
-			 * Try to re-enable interface if the driver stopped it
-			 * when the interface got disabled.
-			 */
-			hostapd_reconfig_wpa(hapd);
-			if (hapd->wpa_auth)
-				wpa_auth_reconfig_group_keys(hapd->wpa_auth);
-			else
-				hostapd_reconfig_encryption(hapd);
-			hapd->reenable_beacon = 1;
-			ieee802_11_set_beacon(hapd);
-#ifdef NEED_AP_MLME
-		} else if (hapd->disabled && hapd->iface->cac_started) {
-			wpa_printf(MSG_DEBUG, "DFS: restarting pending CAC");
-			hostapd_handle_dfs(hapd->iface);
-#endif /* NEED_AP_MLME */
-		}
+		if (hapd->mld)
+			hostapd_mld_if_enable(hapd->mld);
+		else
+			hostpad_if_enable(hapd);
 		break;
 	case EVENT_INTERFACE_DISABLED:
-		hostapd_free_stas(hapd);
-		wpa_msg(hapd->msg_ctx, MSG_INFO, INTERFACE_DISABLED);
-		hapd->disabled = 1;
+		if (hapd->mld)
+			hostapd_mld_if_disable(hapd->mld);
+		else
+			hostpad_if_disable(hapd);
 		break;
 #ifdef CONFIG_ACS
 	case EVENT_ACS_CHANNEL_SELECTED:
