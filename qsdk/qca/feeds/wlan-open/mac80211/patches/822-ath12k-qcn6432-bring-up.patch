From 5b766e8d004dcaa844a4dd3fdfefcf81fa4c4e4c Mon Sep 17 00:00:00 2001
From: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
Date: Tue, 18 Jul 2023 13:47:12 +0530
Subject: [PATCH] ath12k: qcn6432 bring up

Add qcn6432 platform support.
qcn6432 has a hybrid architecture which is enumerated as
pci device by Q6 and as ahb device on host. Device BAR
addressed is received through qmi handshake. Interrupts
are MSI based. DP and CE register read and write happens
using static window.

Signed-off-by: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/Makefile   |   1 +
 drivers/net/wireless/ath/ath12k/ahb.c      |  43 +-
 drivers/net/wireless/ath/ath12k/ahb.h      |   5 +
 drivers/net/wireless/ath/ath12k/ce.c       |   6 +-
 drivers/net/wireless/ath/ath12k/ce.h       |   1 +
 drivers/net/wireless/ath/ath12k/core.c     |   1 +
 drivers/net/wireless/ath/ath12k/core.h     |  38 +-
 drivers/net/wireless/ath/ath12k/coredump.c |   2 +-
 drivers/net/wireless/ath/ath12k/debugfs.c  |   9 +-
 drivers/net/wireless/ath/ath12k/dp.c       |   7 +-
 drivers/net/wireless/ath/ath12k/hal.c      |  61 +-
 drivers/net/wireless/ath/ath12k/hal.h      |   9 +
 drivers/net/wireless/ath/ath12k/hif.h      |  19 +
 drivers/net/wireless/ath/ath12k/hw.c       | 167 +++-
 drivers/net/wireless/ath/ath12k/hw.h       |   1 +
 drivers/net/wireless/ath/ath12k/mhi.c      |   6 +-
 drivers/net/wireless/ath/ath12k/pci.c      | 620 +-------------
 drivers/net/wireless/ath/ath12k/pci.h      |  22 -
 drivers/net/wireless/ath/ath12k/pcic.c     | 905 +++++++++++++++++++++
 drivers/net/wireless/ath/ath12k/pcic.h     |  75 ++
 drivers/net/wireless/ath/ath12k/qmi.c      | 214 ++++-
 drivers/net/wireless/ath/ath12k/qmi.h      |  17 +
 22 files changed, 1596 insertions(+), 633 deletions(-)
 create mode 100644 drivers/net/wireless/ath/ath12k/pcic.c
 create mode 100644 drivers/net/wireless/ath/ath12k/pcic.h

diff --git a/drivers/net/wireless/ath/ath12k/Makefile b/drivers/net/wireless/ath/ath12k/Makefile
index 2595ec8..eae8c84 100644
--- a/drivers/net/wireless/ath/ath12k/Makefile
+++ b/drivers/net/wireless/ath/ath12k/Makefile
@@ -19,6 +19,7 @@ ath12k-y += core.o \
 	    hw.o \
 	    wow.o \
 	    mhi.o \
+	    pcic.o \
 	    pci.o \
 	    dp_mon.o \
 	    vendor.o \
diff --git a/drivers/net/wireless/ath/ath12k/ahb.c b/drivers/net/wireless/ath/ath12k/ahb.c
index ac48593..e1176a4 100644
--- a/drivers/net/wireless/ath/ath12k/ahb.c
+++ b/drivers/net/wireless/ath/ath12k/ahb.c
@@ -5,7 +5,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/platform_device.h>
 #include <linux/of_device.h>
 #include <linux/of.h>
 #include <linux/dma-mapping.h>
@@ -14,6 +13,7 @@
 #include "ahb.h"
 #include "debug.h"
 #include "hif.h"
+#include "pcic.h"
 #include <linux/remoteproc.h>
 #include <linux/soc/qcom/smem.h>
 #include <linux/soc/qcom/smem_state.h>
@@ -22,6 +22,9 @@ static const struct of_device_id ath12k_ahb_of_match[] = {
 	{ .compatible = "qcom,ipq5332-wifi",
 	  .data = (void *)ATH12K_HW_IPQ5332_HW10,
 	},
+	{ .compatible = "qcom,qcn6432-wifi",
+	  .data = (void *)ATH12K_HW_QCN6432_HW10,
+	},
 	{ }
 };
 
@@ -405,6 +408,7 @@ static void ath12k_ahb_init_qmi_ce_config(struct ath12k_base *ab)
 	cfg->svc_to_ce_map_len = ab->hw_params->svc_to_ce_map_len;
 	cfg->svc_to_ce_map = ab->hw_params->svc_to_ce_map;
 	ab->qmi.service_ins_id = ab->hw_params->qmi_service_ins_id;
+	ab->qmi.service_ins_id += ab->userpd_id;
 }
 
 static void ath12k_ahb_free_ext_irq(struct ath12k_base *ab)
@@ -426,6 +430,9 @@ static void ath12k_ahb_free_irq(struct ath12k_base *ab)
 	int irq_idx;
 	int i;
 
+	if (ab->hif.bus == ATH12K_BUS_HYBRID)
+		return ath12k_pcic_free_hybrid_irq(ab);
+
 	for (i = 0; i < ab->hw_params->ce_count; i++) {
 		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
 			continue;
@@ -568,6 +575,9 @@ static int ath12k_ahb_config_irq(struct ath12k_base *ab)
 	int irq, irq_idx, i;
 	int ret;
 
+	if (ab->hif.bus == ATH12K_BUS_HYBRID)
+		return ath12k_pcic_config_hybrid_irq(ab);
+
 	/* Configure CE irqs */
 	for (i = 0; i < ab->hw_params->ce_count; i++) {
 		struct ath12k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];
@@ -664,6 +674,23 @@ static const struct ath12k_hif_ops ath12k_ahb_hif_ops_ipq5332 = {
 	.ssr_notifier_unreg = ath12k_ahb_ssr_notifier_unreg,
 };
 
+static const struct ath12k_hif_ops ath12k_ahb_hif_ops_qcn6432 = {
+	.start = ath12k_pcic_start,
+	.stop = ath12k_pcic_stop,
+	.cmem_read32 = ath12k_pcic_cmem_read32,
+	.cmem_write32 = ath12k_pcic_cmem_write32,
+	.power_down = ath12k_ahb_power_down,
+	.power_up = ath12k_ahb_power_up,
+	.read32 = ath12k_pcic_ipci_read32,
+	.write32 = ath12k_pcic_ipci_write32,
+	.irq_enable = ath12k_pcic_ext_irq_enable,
+	.irq_disable = ath12k_pcic_ext_irq_disable,
+	.get_msi_address =  ath12k_pcic_get_msi_address,
+	.get_user_msi_vector = ath12k_pcic_get_user_msi_assignment,
+	.config_static_window = ath12k_pcic_config_static_window,
+	.get_msi_irq = ath12k_pcic_get_msi_irq,
+	.map_service_to_pipe = ath12k_pcic_map_service_to_pipe,
+};
 
 static int ath12k_core_get_rproc(struct ath12k_base *ab)
 {
@@ -734,6 +761,8 @@ static int ath12k_ahb_setup_resources(struct ath12k_base *ab)
 	struct resource *mem_res;
 	void __iomem *mem;
 
+	if (ab->hif.bus == ATH12K_BUS_HYBRID)
+		return 0;
 
 	mem = devm_platform_get_and_ioremap_resource(pdev, 0, &mem_res);
 	if (IS_ERR(mem)) {
@@ -952,7 +981,8 @@ static int ath12k_ahb_probe(struct platform_device *pdev)
 	const struct ath12k_hif_ops *hif_ops;
 	struct device *dev = &pdev->dev;
 	enum ath12k_hw_rev hw_rev;
-	int ret, userpd_id;
+	struct ath12k_bus_params *bus_params;
+	int ret, userpd_id, bus_type;
 
 	of_id = of_match_device(ath12k_ahb_of_match, &pdev->dev);
 	if (!of_id) {
@@ -967,6 +997,13 @@ static int ath12k_ahb_probe(struct platform_device *pdev)
 	switch (hw_rev) {
 	case ATH12K_HW_IPQ5332_HW10:
 		hif_ops = &ath12k_ahb_hif_ops_ipq5332;
+		bus_params = &ath12k_ahb_bus_params;
+		bus_type = ATH12K_BUS_AHB;
+		break;
+	case ATH12K_HW_QCN6432_HW10:
+		hif_ops = &ath12k_ahb_hif_ops_qcn6432;
+		bus_params = &ath12k_internal_pci_bus_params;
+		bus_type = ATH12K_BUS_HYBRID;
 		break;
 	default:
 		dev_err(&pdev->dev, "Unsupported device type %d\n", hw_rev);
@@ -980,7 +1017,7 @@ static int ath12k_ahb_probe(struct platform_device *pdev)
 	}
 
 	ab = ath12k_core_alloc(&pdev->dev, sizeof(struct ath12k_ahb),
-			       ATH12K_BUS_AHB, &ath12k_ahb_bus_params);
+			       bus_type, bus_params);
 	if (!ab) {
 		dev_err(&pdev->dev, "failed to allocate ath12k base\n");
 		return -ENOMEM;
diff --git a/drivers/net/wireless/ath/ath12k/ahb.h b/drivers/net/wireless/ath/ath12k/ahb.h
index 5abf8e2..d2c81da 100644
--- a/drivers/net/wireless/ath/ath12k/ahb.h
+++ b/drivers/net/wireless/ath/ath12k/ahb.h
@@ -84,4 +84,9 @@ static const struct ath12k_bus_params ath12k_ahb_bus_params = {
 	.fixed_mem_region = true,
 };
 
+static const struct ath12k_bus_params ath12k_internal_pci_bus_params = {
+	.fixed_bdf_addr = false,
+	.fixed_mem_region = true,
+};
+
 #endif
diff --git a/drivers/net/wireless/ath/ath12k/ce.c b/drivers/net/wireless/ath/ath12k/ce.c
index 68a361b..e2567ab 100644
--- a/drivers/net/wireless/ath/ath12k/ce.c
+++ b/drivers/net/wireless/ath/ath12k/ce.c
@@ -321,6 +321,7 @@ const struct ce_attr ath12k_host_ce_config_ipq5332[] = {
 	},
 };
 
+
 static int ath12k_ce_rx_buf_enqueue_pipe(struct ath12k_ce_pipe *pipe,
 					 struct sk_buff *skb, dma_addr_t paddr)
 {
@@ -600,7 +601,10 @@ static void ath12k_ce_srng_msi_ring_params_setup(struct ath12k_base *ab, u32 ce_
 
 	ring_params->msi_addr = addr_lo;
 	ring_params->msi_addr |= (dma_addr_t)(((uint64_t)addr_hi) << 32);
-	ring_params->msi_data = (msi_data_idx % msi_data_count) + msi_data_start;
+	if (ab->hif.bus == ATH12K_BUS_HYBRID)
+		ring_params->msi_data = ab->ipci.ce_msi_data[ce_id];
+	else
+		ring_params->msi_data = (msi_data_idx % msi_data_count) + msi_data_start;
 	ring_params->flags |= HAL_SRNG_FLAGS_MSI_INTR;
 }
 
diff --git a/drivers/net/wireless/ath/ath12k/ce.h b/drivers/net/wireless/ath/ath12k/ce.h
index f709167..2e44e9f 100644
--- a/drivers/net/wireless/ath/ath12k/ce.h
+++ b/drivers/net/wireless/ath/ath12k/ce.h
@@ -8,6 +8,7 @@
 #define ATH12K_CE_H
 
 #define CE_COUNT_MAX 16
+#define ATH12K_QCN6432_CE_COUNT 12
 
 /* Byte swap data words */
 #define CE_ATTR_BYTE_SWAP_DATA 2
diff --git a/drivers/net/wireless/ath/ath12k/core.c b/drivers/net/wireless/ath/ath12k/core.c
index 5c9930c..ad8b3f7 100644
--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -3257,6 +3257,7 @@ int ath12k_core_init(struct ath12k_base *ab)
 	/* Register a notifier after core init
 	 * to be called on fw crash
 	 */
+	init_waitqueue_head(&ab->ipci.gic_msi_waitq);
 	ab->ssr_nb.notifier_call = ath12k_core_ssr_notifier_cb;
 	ab->atomic_ssr_nb.notifier_call = ath12k_core_atomic_ssr_notifier_cb;
 	ret = ath12k_hif_ssr_notifier_reg(ab);
diff --git a/drivers/net/wireless/ath/ath12k/core.h b/drivers/net/wireless/ath/ath12k/core.h
index fbca6c4..0743ba6 100644
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -156,6 +156,7 @@ enum ath12k_hw_rev {
 	ATH12K_HW_QCN9274_HW20,
 	ATH12K_HW_WCN7850_HW20,
 	ATH12K_HW_IPQ5332_HW10,
+	ATH12K_HW_QCN6432_HW10,
 };
 
 #define ATH12K_DIAG_HW_ID_OFFSET 16
@@ -196,6 +197,23 @@ struct ath12k_ext_irq_grp {
 
 #define HE_PPET16_PPET8_SIZE            8
 
+enum ath12k_msi_supported_hw {
+	ATH12K_MSI_CONFIG_PCI,
+	ATH12K_MSI_CONFIG_IPCI,
+};
+
+struct ath12k_msi_user {
+	char *name;
+	int num_vectors;
+	u32 base_vector;
+};
+
+struct ath12k_msi_config {
+	int total_vectors;
+	int total_users;
+	struct ath12k_msi_user *users;
+};
+
 /* 802.11ax PPE (PPDU packet Extension) threshold */
 struct he_ppe_threshold {
 	u32 numss_m1;
@@ -1272,6 +1290,14 @@ enum ath12k_mlo_recovery_mode {
 	ATH12K_MLO_RECOVERY_MODE1 = 2,
 };
 
+struct ath12k_internal_pci {
+        bool gic_enabled;
+        wait_queue_head_t gic_msi_waitq;
+        u32 dp_msi_data[ATH12K_EXT_IRQ_GRP_NUM_MAX];
+        u32 ce_msi_data[ATH12K_QCN6432_CE_COUNT];
+        u32 dp_irq_num[ATH12K_EXT_IRQ_GRP_NUM_MAX];
+};
+
 struct ath12k_mlo_dp_umac_reset {
         atomic_t response_chip;
         spinlock_t lock;
@@ -1488,7 +1514,15 @@ struct ath12k_base {
 #endif
 
 	int userpd_id;
-
+	struct {
+		const struct ath12k_msi_config *config;
+		u32 ep_base_data;
+		u32 irqs[32];
+		u32 addr_lo;
+		u32 addr_hi;
+	} msi;
+
+	struct ath12k_internal_pci ipci;
 	u32 chwidth_num_peer_caps;
 	struct ath12k_dp_umac_reset dp_umac_reset;
 
@@ -1726,6 +1760,8 @@ static inline const char *ath12k_bus_str(enum ath12k_bus bus)
 		return "pci";
 	case ATH12K_BUS_AHB:
 		return "ahb";
+	case ATH12K_BUS_HYBRID:
+		return "ahb";
 	}
 
 	return "unknown";
diff --git a/drivers/net/wireless/ath/ath12k/coredump.c b/drivers/net/wireless/ath/ath12k/coredump.c
index 3bdf5ef..71f3e5f 100644
--- a/drivers/net/wireless/ath/ath12k/coredump.c
+++ b/drivers/net/wireless/ath/ath12k/coredump.c
@@ -118,7 +118,7 @@ void ath12k_coredump_build_inline(struct ath12k_base *ab,
 		sizeof(file_data->df_magic));
 	file_data->len = cpu_to_le32(header_size);
 	file_data->version = cpu_to_le32(ATH12K_FW_CRASH_DUMP_V2);
-	if (ab->hif.bus == ATH12K_BUS_AHB) {
+	if (ab->hif.bus == ATH12K_BUS_AHB || ab->hif.bus == ATH12K_BUS_HYBRID) {
 		file_data->chip_id = ab->qmi.target.chip_id;
 		file_data->qrtr_id = ab->qmi.service_ins_id;
 		file_data->bus_id = ab->userpd_id;
diff --git a/drivers/net/wireless/ath/ath12k/debugfs.c b/drivers/net/wireless/ath/ath12k/debugfs.c
index 4295e70..84b84fc 100644
--- a/drivers/net/wireless/ath/ath12k/debugfs.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs.c
@@ -2373,8 +2373,13 @@ int ath12k_debugfs_soc_create(struct ath12k_base *ab)
 	if (!(IS_ERR_OR_NULL(ab->debugfs_soc)))
 		return 0;
 
-	snprintf(soc_name, sizeof(soc_name), "%s_%s", ab->hw_params->name,
-		 dev_name(ab->dev));
+	if (ab->userpd_id) {
+		snprintf(soc_name, sizeof(soc_name), "%s_%d",
+			 ab->hw_params->name, ab->userpd_id);
+	} else {
+		snprintf(soc_name, sizeof(soc_name), "%s_%s", ab->hw_params->name,
+			 dev_name(ab->dev));
+	}
 
 	ab->debugfs_soc = debugfs_create_dir(soc_name, debugfs_ath12k);
 
diff --git a/drivers/net/wireless/ath/ath12k/dp.c b/drivers/net/wireless/ath/ath12k/dp.c
index 4e585bd..6926597 100644
--- a/drivers/net/wireless/ath/ath12k/dp.c
+++ b/drivers/net/wireless/ath/ath12k/dp.c
@@ -310,8 +310,11 @@ static void ath12k_dp_srng_msi_setup(struct ath12k_base *ab,
 
 	ring_params->msi_addr = addr_lo;
 	ring_params->msi_addr |= (dma_addr_t)(((uint64_t)addr_hi) << 32);
-	ring_params->msi_data = (msi_group_number % msi_data_count)
-		+ msi_data_start;
+	if (ab->hif.bus == ATH12K_BUS_HYBRID)
+		ring_params->msi_data = ab->ipci.dp_msi_data[msi_group_number];
+	else
+		ring_params->msi_data = (msi_group_number % msi_data_count)
+			+ msi_data_start;
 	ring_params->flags |= HAL_SRNG_FLAGS_MSI_INTR;
 
 	vector = msi_irq_start  + (msi_group_number % msi_data_count);
diff --git a/drivers/net/wireless/ath/ath12k/hal.c b/drivers/net/wireless/ath/ath12k/hal.c
index 4f994e6..f039003 100644
--- a/drivers/net/wireless/ath/ath12k/hal.c
+++ b/drivers/net/wireless/ath/ath12k/hal.c
@@ -831,6 +831,55 @@ const struct hal_ops hal_qcn9274_ops = {
 	.hal_get_tqm_scratch_reg = ath12k_hal_qcn9274_get_tqm_scratch_reg,
 };
 
+const struct hal_ops hal_qcn6432_ops = {
+	.rx_desc_get_first_msdu = ath12k_hw_qcn9274_rx_desc_get_first_msdu,
+	.rx_desc_get_last_msdu = ath12k_hw_qcn9274_rx_desc_get_last_msdu,
+	.rx_desc_get_l3_pad_bytes = ath12k_hw_qcn9274_rx_desc_get_l3_pad_bytes,
+	.rx_desc_encrypt_valid = ath12k_hw_qcn9274_rx_desc_encrypt_valid,
+	.rx_desc_get_encrypt_type = ath12k_hw_qcn9274_rx_desc_get_encrypt_type,
+	.rx_desc_get_decap_type = ath12k_hw_qcn9274_rx_desc_get_decap_type,
+	.rx_desc_get_mesh_ctl = ath12k_hw_qcn9274_rx_desc_get_mesh_ctl,
+	.rx_desc_get_mpdu_seq_ctl_vld = ath12k_hw_qcn9274_rx_desc_get_mpdu_seq_ctl_vld,
+	.rx_desc_get_mpdu_fc_valid = ath12k_hw_qcn9274_rx_desc_get_mpdu_fc_valid,
+	.rx_desc_get_mpdu_start_seq_no = ath12k_hw_qcn9274_rx_desc_get_mpdu_start_seq_no,
+	.rx_desc_get_msdu_len = ath12k_hw_qcn9274_rx_desc_get_msdu_len,
+	.rx_desc_get_msdu_sgi = ath12k_hw_qcn9274_rx_desc_get_msdu_sgi,
+	.rx_desc_get_msdu_rate_mcs = ath12k_hw_qcn9274_rx_desc_get_msdu_rate_mcs,
+	.rx_desc_get_msdu_rx_bw = ath12k_hw_qcn9274_rx_desc_get_msdu_rx_bw,
+	.rx_desc_get_msdu_freq = ath12k_hw_qcn9274_rx_desc_get_msdu_freq,
+	.rx_desc_get_msdu_pkt_type = ath12k_hw_qcn9274_rx_desc_get_msdu_pkt_type,
+	.rx_desc_get_msdu_nss = ath12k_hw_qcn9274_rx_desc_get_msdu_nss,
+	.rx_desc_get_mpdu_tid = ath12k_hw_qcn9274_rx_desc_get_mpdu_tid,
+	.rx_desc_get_mpdu_peer_id = ath12k_hw_qcn9274_rx_desc_get_mpdu_peer_id,
+	.rx_desc_copy_end_tlv = ath12k_hw_qcn9274_rx_desc_copy_end_tlv,
+	.rx_desc_get_mpdu_ppdu_id = ath12k_hw_qcn9274_rx_desc_get_mpdu_ppdu_id,
+	.rx_desc_set_msdu_len = ath12k_hw_qcn9274_rx_desc_set_msdu_len,
+	.rx_desc_get_msdu_payload = ath12k_hw_qcn9274_rx_desc_get_msdu_payload,
+	.rx_desc_get_mpdu_start_offset = ath12k_hw_qcn9274_rx_desc_get_mpdu_start_offset,
+	.rx_desc_get_msdu_end_offset = ath12k_hw_qcn9274_rx_desc_get_msdu_end_offset,
+	.rx_desc_get_msdu_intra_bss_bit = ath12k_hw_qcn9274_rx_desc_get_msdu_intra_bss_bit,
+	.rx_desc_mac_addr2_valid = ath12k_hw_qcn9274_rx_desc_mac_addr2_valid,
+	.rx_desc_mpdu_start_addr2 = ath12k_hw_qcn9274_rx_desc_mpdu_start_addr2,
+	.rx_desc_is_mcbc = ath12k_hw_qcn9274_rx_desc_is_mcbc,
+	.rx_desc_get_dot11_hdr = ath12k_hw_qcn9274_rx_desc_get_dot11_hdr,
+	.rx_desc_get_crypto_header = ath12k_hw_qcn9274_rx_desc_get_crypto_hdr,
+	.create_srng_config = ath12k_hal_srng_create_config_qcn9274,
+	.tcl_to_wbm_rbm_map = ath12k_hal_qcn9274_tcl_to_wbm_rbm_map,
+	.dp_rx_h_msdu_done = ath12k_hw_qcn9274_dp_rx_h_msdu_done,
+	.dp_rx_h_l4_cksum_fail = ath12k_hw_qcn9274_dp_rx_h_l4_cksum_fail,
+	.dp_rx_h_ip_cksum_fail = ath12k_hw_qcn9274_dp_rx_h_ip_cksum_fail,
+	.dp_rx_h_is_decrypted = ath12k_hw_qcn9274_dp_rx_h_is_decrypted,
+	.dp_rx_h_mpdu_err = ath12k_hw_qcn9274_dp_rx_h_mpdu_err,
+	.rx_desc_get_ip_valid = ath12k_hal_qcn9274_rx_desc_get_ip_valid,
+	.rxdma_ring_wmask_rx_mpdu_start = ath12k_hal_rx_mpdu_start_wmask_get,
+	.rxdma_ring_wmask_rx_msdu_end = ath12k_hal_rx_msdu_end_wmask_get,
+	.rx_desc_get_msdu_src_link_id = ath12k_hw_qcn9274_rx_desc_get_msdu_src_link,
+	.rx_get_desc_info = ath12k_hw_qcn9274_get_rx_desc_info,
+	.rx_get_desc_msdulen_l3pad = ath12k_hw_qcn9274_get_rx_msdulen_l3pad,
+	.rx_desc_get_first_last_msdu = ath12k_hw_qcn9274_get_rx_first_last_msdu,
+};
+
+
 static bool ath12k_hw_wcn7850_rx_desc_get_first_msdu(struct hal_rx_desc *desc)
 {
 	return !!le16_get_bits(desc->u.wcn7850.msdu_end.info5,
@@ -2261,14 +2310,16 @@ int ath12k_hal_srng_setup_idx(struct ath12k_base *ab, enum hal_ring_type type,
 				srng->u.src_ring.hp_addr =
 					(u32 *)((unsigned long)ab->mem + reg_base);
 				if (type  == HAL_TCL_DATA) {
-					if (ab->hif.bus == ATH12K_BUS_PCI)
+					if (ab->hif.bus == ATH12K_BUS_PCI ||
+					    ab->hif.bus == ATH12K_BUS_HYBRID){
 						srng->u.src_ring.hp_addr_direct =
 							(u32 *)((unsigned long)ab->mem +
 							HAL_DP_REG_WINDOW_OFFSET +
 							(reg_base & WINDOW_RANGE_MASK));
-					else
+					} else {
 						srng->u.src_ring.hp_addr_direct =
 							srng->u.src_ring.hp_addr;
+					}
 				}
 			} else {
 					ath12k_dbg(ab, ATH12K_DBG_HAL,
@@ -2311,15 +2362,17 @@ int ath12k_hal_srng_setup_idx(struct ath12k_base *ab, enum hal_ring_type type,
 					(u32 *)((unsigned long)ab->mem + reg_base +
 					(HAL_REO1_RING_TP - HAL_REO1_RING_HP));
 				if (type  == HAL_WBM2SW_RELEASE) {
-					if (ab->hif.bus == ATH12K_BUS_PCI)
+					if (ab->hif.bus == ATH12K_BUS_PCI ||
+					    ab->hif.bus == ATH12K_BUS_HYBRID) {
 						srng->u.dst_ring.tp_addr_direct =
 							(u32 *)((unsigned long)ab->mem +
 							(reg_base & WINDOW_RANGE_MASK) +
 							HAL_DP_REG_WINDOW_OFFSET +
 							(HAL_REO1_RING_TP - HAL_REO1_RING_HP));
-					else
+					} else {
 						srng->u.dst_ring.tp_addr_direct =
 							srng->u.dst_ring.tp_addr;
+					}
 				}
 			} else {
 					ath12k_dbg(ab, ATH12K_DBG_HAL,
diff --git a/drivers/net/wireless/ath/ath12k/hal.h b/drivers/net/wireless/ath/ath12k/hal.h
index 6c38ae9..f1674fc 100644
--- a/drivers/net/wireless/ath/ath12k/hal.h
+++ b/drivers/net/wireless/ath/ath12k/hal.h
@@ -204,6 +204,7 @@ struct ath12k_dp_rx_info;
 #define HAL_REO1_REO2PPE_DST_VAL		0x2000
 #define HAL_REO1_REO2PPE_DST_INFO		0x00000cf0
 
+/* REO2SW(x) R2 ring pointers (head/tail) address */
 /* REO2SW(x) R2 ring pointers (head/tail) address */
 #define HAL_REO1_RING_HP			0x00003048
 #define HAL_REO1_RING_TP			0x0000304c
@@ -437,6 +438,13 @@ struct ath12k_dp_rx_info;
 #define HAL_IPQ5332_PMM_REG_BASE	0xCB500FC
 #define HAL_IPQ5332_PMM_SIZE		0x100
 
+#define HAL_QCN6432_CE_WFSS_REG_BASE	0x1B80000
+#define HAL_QCN6432_CE_SIZE		0x200000
+
+#define HAL_QCN6432_CMEM_REG_BASE	0x00100000
+#define HAL_QCN6432_CMEM_SIZE		0x40000
+#define HAL_QCN6432_CMEM_BASE		0x100000
+
 enum hal_srng_ring_id {
 	HAL_SRNG_RING_ID_REO2SW0 = 0,
 	HAL_SRNG_RING_ID_REO2SW1,
@@ -1196,6 +1204,7 @@ struct hal_ops {
 
 extern const struct hal_ops hal_qcn9274_ops;
 extern const struct hal_ops hal_wcn7850_ops;
+extern const struct hal_ops hal_qcn6432_ops;
 
 u32 ath12k_hal_reo_qdesc_size(u32 ba_window_size, u8 tid);
 void ath12k_hal_reo_qdesc_setup(void *vaddr, int tid, u32 ba_window_size,
diff --git a/drivers/net/wireless/ath/ath12k/hif.h b/drivers/net/wireless/ath/ath12k/hif.h
index 53993d7..9b7567b 100644
--- a/drivers/net/wireless/ath/ath12k/hif.h
+++ b/drivers/net/wireless/ath/ath12k/hif.h
@@ -36,6 +36,9 @@ struct ath12k_hif_ops {
 	void (*get_ce_msi_idx)(struct ath12k_base *ab, u32 ce_id, u32 *msi_idx);
 	int (*ssr_notifier_reg)(struct ath12k_base *ab);
 	int (*ssr_notifier_unreg)(struct ath12k_base *ab);
+	void (*config_static_window)(struct ath12k_base *ab);
+	int (*get_msi_irq)(struct ath12k_base *ab, unsigned int vector);
+
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	int (*ppeds_register_interrupts)(struct ath12k_base *ab, int type, int vector,
 					 int ring_num);
@@ -231,6 +234,22 @@ static inline void ath12k_hif_power_down(struct ath12k_base *ab)
 	ab->hif.ops->power_down(ab);
 }
 
+static inline void ath12k_hif_config_static_window(struct ath12k_base *ab)
+{
+	if (!ab->hif.ops->config_static_window)
+		return;
+
+	ab->hif.ops->config_static_window(ab);
+}
+
+static inline int ath12k_hif_get_msi_irq(struct ath12k_base *ab, unsigned int vector)
+{
+        if (!ab->hif.ops->get_msi_irq)
+                return -EOPNOTSUPP;
+
+        return ab->hif.ops->get_msi_irq(ab, vector);
+}
+
 static inline int ath12k_hif_dp_umac_reset_irq_config(struct ath12k_base *ab)
 {
 	if (ab->hif.ops->dp_umac_reset_irq_config)
diff --git a/drivers/net/wireless/ath/ath12k/hw.c b/drivers/net/wireless/ath/ath12k/hw.c
index 6f37c6c..09eb43e 100644
--- a/drivers/net/wireless/ath/ath12k/hw.c
+++ b/drivers/net/wireless/ath/ath12k/hw.c
@@ -1257,6 +1257,96 @@ static const struct ath12k_hw_regs wcn7850_regs = {
 	.hal_umac_ce1_dest_reg_base = 0x01b83000,
 };
 
+const struct ath12k_hw_regs qcn6432_regs = {
+	/* SW2TCL(x) R0 ring configuration address */
+	.hal_tcl1_ring_id = 0x00000918,
+	.hal_tcl1_ring_misc = 0x00000920,
+	.hal_tcl1_ring_tp_addr_lsb = 0x0000092c,
+	.hal_tcl1_ring_tp_addr_msb = 0x00000930,
+	.hal_tcl1_ring_consumer_int_setup_ix0 = 0x00000940,
+	.hal_tcl1_ring_consumer_int_setup_ix1 = 0x00000944,
+	.hal_tcl1_ring_msi1_base_lsb = 0x00000958,
+	.hal_tcl1_ring_msi1_base_msb = 0x0000095c,
+	.hal_tcl1_ring_base_lsb = 0x00000910,
+	.hal_tcl1_ring_base_msb = 0x00000914,
+	.hal_tcl1_ring_msi1_data = 0x00000960,
+	.hal_tcl2_ring_base_lsb = 0x00000988,
+	.hal_tcl_ring_base_lsb = 0x00000b68,
+
+	/* TCL STATUS ring address */
+	.hal_tcl_status_ring_base_lsb = 0x00000d48,
+
+	/* REO DEST ring address */
+	.hal_reo2_ring_base = 0x00000578,
+	.hal_reo1_misc_ctrl_addr = 0x00000b9c,
+	.hal_reo1_sw_cookie_cfg0 = 0x0000006c,
+	.hal_reo1_sw_cookie_cfg1 = 0x00000070,
+	.hal_reo1_qdesc_lut_base0 = 0x00000074,
+	.hal_reo1_qdesc_lut_base1 = 0x00000078,
+	.hal_reo1_qdesc_addr_read = 0x0000007c,
+	.hal_reo1_qdesc_max_peerid = 0x00000088,
+	.hal_reo1_ring_base_lsb = 0x00000500,
+	.hal_reo1_ring_base_msb = 0x00000504,
+	.hal_reo1_ring_id = 0x00000508,
+	.hal_reo1_ring_misc = 0x00000510,
+	.hal_reo1_ring_hp_addr_lsb = 0x00000514,
+	.hal_reo1_ring_hp_addr_msb = 0x00000518,
+	.hal_reo1_ring_producer_int_setup = 0x00000524,
+	.hal_reo1_ring_msi1_base_lsb = 0x00000548,
+	.hal_reo1_ring_msi1_base_msb = 0x0000054C,
+	.hal_reo1_ring_msi1_data = 0x00000550,
+	.hal_reo1_aging_thres_ix0 = 0x00000B28,
+	.hal_reo1_aging_thres_ix1 = 0x00000B2C,
+	.hal_reo1_aging_thres_ix2 = 0x00000B30,
+	.hal_reo1_aging_thres_ix3 = 0x00000B34,
+
+	/* REO Exception ring address */
+	.hal_reo2_sw0_ring_base = 0x000008c0,
+
+	/* REO Reinject ring address */
+	.hal_sw2reo_ring_base = 0x00000320,
+	.hal_sw2reo1_ring_base = 0x00000398,
+
+	/* REO cmd ring address */
+	.hal_reo_cmd_ring_base = 0x000002A8,
+
+	/* REO status ring address */
+	.hal_reo_status_ring_base = 0x00000aa0,
+
+	/* WBM idle link ring address */
+	.hal_wbm_idle_ring_base_lsb = 0x00000d3c,
+	.hal_wbm_idle_ring_misc_addr = 0x00000d4c,
+	.hal_wbm_r0_idle_list_cntl_addr = 0x00000240,
+	.hal_wbm_r0_idle_list_size_addr = 0x00000244,
+	.hal_wbm_scattered_ring_base_lsb = 0x00000250,
+	.hal_wbm_scattered_ring_base_msb = 0x00000254,
+	.hal_wbm_scattered_desc_head_info_ix0 = 0x00000260,
+	.hal_wbm_scattered_desc_head_info_ix1   = 0x00000264,
+	.hal_wbm_scattered_desc_tail_info_ix0 = 0x00000270,
+	.hal_wbm_scattered_desc_tail_info_ix1 = 0x00000274,
+	.hal_wbm_scattered_desc_ptr_hp_addr = 0x0000027c,
+
+	/* SW2WBM release ring address */
+	.hal_wbm_sw_release_ring_base_lsb = 0x0000037c,
+
+	/* WBM2SW release ring address */
+	.hal_wbm0_release_ring_base_lsb = 0x00000e08,
+	.hal_wbm1_release_ring_base_lsb = 0x00000e80,
+
+       /* reo2ppe ring base address */
+        .hal_reo2ppe_ring_base = 0x00000938,
+
+        /* PCIe base address */
+        .pcie_qserdes_sysclk_en_sel = 0x01e0c0a8,
+        .pcie_pcs_osc_dtct_config_base = 0x01e0d45c,
+
+	/* CE base address */
+	.hal_umac_ce0_src_reg_base = 0x01B80000,
+	.hal_umac_ce0_dest_reg_base = 0x01B81000,
+	.hal_umac_ce1_src_reg_base =  0x01B82000,
+	.hal_umac_ce1_dest_reg_base =  0x01B83000,
+};
+
 static const struct ath12k_hw_hal_params ath12k_hw_hal_params_qcn9274 = {
 	.rx_buf_rbm = HAL_RX_BUF_RBM_SW3_BM,
 	.wbm2sw_cc_enable = HAL_WBM_SW_COOKIE_CONV_CFG_WBM2SW0_EN |
@@ -1696,7 +1786,7 @@ static struct ath12k_hw_params ath12k_hw_params[] = {
 		.supports_monitor = true,
 
 		.idle_ps = false,
-		.cold_boot_calib = true,
+		.cold_boot_calib = false,
 		.download_calib = true,
 		.supports_suspend = false,
 		.tcl_ring_retry = true,
@@ -1736,6 +1826,81 @@ static struct ath12k_hw_params ath12k_hw_params[] = {
 		.en_fwlog = true,
 		.support_umac_reset = false,
 	},
+	{
+		.name = "qcn6432 hw1.0",
+		.hw_rev = ATH12K_HW_QCN6432_HW10,
+		.fw = {
+		        .dir = "QCN6432/hw1.0",
+		        .board_size = 256 * 1024,
+		        .cal_offset = 128 * 1024,
+		},
+		.max_radios = 1,
+		.single_pdev_only = false,
+		.qmi_service_ins_id = ATH12K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6432,
+		.internal_sleep_clock = false,
+
+		.hw_ops = &ipq5332_ops,
+		.regs = &qcn6432_regs,
+		.ring_mask = &ath12k_hw_ring_mask_ipq5332,
+
+		.host_ce_config = ath12k_host_ce_config_ipq5332,
+		.ce_count = 12,
+		.target_ce_config = ath12k_target_ce_config_wlan_ipq5332,
+		.target_ce_count = 12,
+		.svc_to_ce_map = ath12k_target_service_to_ce_map_wlan_ipq5332,
+		.svc_to_ce_map_len = 19,
+
+		.hal_params = &ath12k_hw_hal_params_ipq5332,
+
+		.rxdma1_enable = true,
+		.num_rxmda_per_pdev = 1,
+		.num_rxdma_dst_ring = 0,
+		.rx_mac_buf_ring = false,
+		.vdev_start_delay = false,
+		.fixed_fw_mem = false,
+		.smp2p_wow_exit = false,
+
+		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
+					BIT(NL80211_IFTYPE_AP) |
+					BIT(NL80211_IFTYPE_MESH_POINT),
+		.supports_monitor = true,
+
+		.idle_ps = false,
+		.cold_boot_calib = false,
+		.download_calib = true,
+		.supports_suspend = false,
+		.tcl_ring_retry = true,
+		.reoq_lut_support = true,
+		.supports_shadow_regs = false,
+
+		.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9274),
+		.num_tcl_banks = 48,
+		.max_tx_ring = 4,
+		.static_window_map = true,
+
+		.wmi_init = ath12k_wmi_init_ipq5332,
+
+		.hal_ops = &hal_qcn6432_ops,
+
+		.supports_ap_ps = true,
+		.credit_flow = false,
+		.wakeup_mhi = false,
+		.alloc_cacheable_memory = true,
+		.spectral = {
+			.fft_sz = 7,
+			.fft_pad_sz = 0,
+			.summary_pad_sz = 16,
+			.fft_hdr_len = 24,
+			.max_fft_bins = 512,
+			.fragment_160mhz = false,
+		},
+		.max_mlo_peer = ATH12K_MAX_MLO_PEER,
+		.num_local_link = 0,
+		.m3_fw_support = false,
+		.compact_rx_tlv = true,
+		.send_platform_model = true,
+		.en_fwlog = false,
+	},
 };
 
 void ath12k_dp_reset_interrupt_mask(struct ath12k_base *ab)
diff --git a/drivers/net/wireless/ath/ath12k/hw.h b/drivers/net/wireless/ath/ath12k/hw.h
index 415aa46..91b18fc 100644
--- a/drivers/net/wireless/ath/ath12k/hw.h
+++ b/drivers/net/wireless/ath/ath12k/hw.h
@@ -115,6 +115,7 @@ enum ath12k_hw_rate_ofdm {
 enum ath12k_bus {
 	ATH12K_BUS_PCI,
 	ATH12K_BUS_AHB,
+	ATH12K_BUS_HYBRID,
 };
 
 /* Regular 12 Host DP interrupts + 3 PPEDS interrupts + 1 DP UMAC RESET interrupt*/
diff --git a/drivers/net/wireless/ath/ath12k/mhi.c b/drivers/net/wireless/ath/ath12k/mhi.c
index 280556b..8fabc92 100644
--- a/drivers/net/wireless/ath/ath12k/mhi.c
+++ b/drivers/net/wireless/ath/ath12k/mhi.c
@@ -14,6 +14,8 @@
 #include "debug.h"
 #include "mhi.h"
 #include "pci.h"
+#include "pcic.h"
+#include "hif.h"
 
 #define MHI_TIMEOUT_DEFAULT_MS	90000
 #define OTP_INVALID_BOARD_ID	0xFFFF
@@ -263,7 +265,7 @@ static int ath12k_mhi_get_msi(struct ath12k_pci *ab_pci)
 	int ret, num_vectors, i;
 	int *irq;
 
-	ret = ath12k_pci_get_user_msi_assignment(ab,
+	ret = ath12k_pcic_get_user_msi_assignment(ab,
 						 "MHI", &num_vectors,
 						 &user_base_data, &base_vector);
 	if (ret)
@@ -277,7 +279,7 @@ static int ath12k_mhi_get_msi(struct ath12k_pci *ab_pci)
 		return -ENOMEM;
 
 	for (i = 0; i < num_vectors; i++)
-		irq[i] = ath12k_pci_get_msi_irq(ab->dev,
+		irq[i] = ath12k_hif_get_msi_irq(ab,
 						base_vector + i);
 
 	ab_pci->mhi_ctrl->irq = irq;
diff --git a/drivers/net/wireless/ath/ath12k/pci.c b/drivers/net/wireless/ath/ath12k/pci.c
index 5ed5f61..fa384ca 100644
--- a/drivers/net/wireless/ath/ath12k/pci.c
+++ b/drivers/net/wireless/ath/ath12k/pci.c
@@ -5,27 +5,17 @@
  */
 
 #include <linux/module.h>
-#include <linux/msi.h>
-#include <linux/pci.h>
 #include <linux/of.h>
 
 #include "pci.h"
-#include "core.h"
-#include "hif.h"
 #include "mhi.h"
 #include "debug.h"
 #include "ppe.h"
+#include "pcic.h"
 
 #define ATH12K_PCI_BAR_NUM		0
 #define ATH12K_PCI_DMA_MASK		32
 
-#define ATH12K_PCI_IRQ_CE0_OFFSET		3
-
-#define WINDOW_ENABLE_BIT		0x40000000
-#define WINDOW_REG_ADDRESS		0x310c
-#define WINDOW_VALUE_MASK		GENMASK(24, 19)
-#define WINDOW_START			0x80000
-#define WINDOW_RANGE_MASK		GENMASK(18, 0)
 #define WINDOW_STATIC_MASK		GENMASK(31, 6)
 
 #define TCSR_SOC_HW_VERSION		0x1B00000
@@ -44,27 +34,15 @@
 #define PCIE_PCIE_LOCAL_REG_PCIE_LOCAL_RSV0	0x1E03164
 #define QRTR_INSTANCE_MASK			0x000000FF
 #define ATH12K_MAX_PCI_DOMAINS		0x5
-#define DP_IRQ_NAME_LEN 20
 
 /* choose a little lower value for tx completion processing
  * to give priority for enqueue */
-unsigned int tx_comp_budget = 0x7F;
-EXPORT_SYMBOL(tx_comp_budget);
-module_param_named(tx_comp_budget, tx_comp_budget, uint, 0644);
-MODULE_PARM_DESC(tx_comp_budget, "tx_comp_budget");
-
-char dp_irq_name[ATH12K_MAX_PCI_DOMAINS + 1][ATH12K_EXT_IRQ_DP_NUM_VECTORS][DP_IRQ_NAME_LEN] = {};
 
 unsigned int ath12k_fw_mem_seg;
 EXPORT_SYMBOL(ath12k_fw_mem_seg);
 module_param_named(fw_mem_seg, ath12k_fw_mem_seg, uint, 0644);
 MODULE_PARM_DESC(fw_mem_seg, "Enable/Disable FW segmentted memory");
 
-unsigned int ath12k_napi_poll_budget = 0x7f;
-EXPORT_SYMBOL(ath12k_napi_poll_budget);
-module_param_named(napi_budget, ath12k_napi_poll_budget, uint, 0644);
-MODULE_PARM_DESC(napi_budget, "Napi budget processing per rx intr");
-
 #ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
 extern int ath12k_mlo_capable;
 extern int g_bonded_interface_model;
@@ -86,79 +64,6 @@ static const struct ath12k_bus_params ath12k_pci_bus_params = {
 	.fixed_bdf_addr = false,
 };
 
-/* TODO: revisit IRQ mapping for new SRNG's */
-static const struct ath12k_msi_config ath12k_msi_config[] = {
-	{
-		/* MSI spec expects number of interrupts to be a power of 2 */
-		.total_vectors = 32,
-		.total_users = 3,
-		.users = (struct ath12k_msi_user[]) {
-			{ .name = "MHI", .num_vectors = 3, .base_vector = 0 },
-			{ .name = "CE", .num_vectors = 5, .base_vector = 3 },
-			{ .name = "DP", .num_vectors = 16, .base_vector = 8 },
-		},
-	},
-};
-
-static const char *irq_name[ATH12K_IRQ_NUM_MAX] = {
-	"bhi",
-	"mhi-er0",
-	"mhi-er1",
-	"ce0",
-	"ce1",
-	"ce2",
-	"ce3",
-	"ce4",
-	"ce5",
-	"ce6",
-	"ce7",
-	"ce8",
-	"ce9",
-	"ce10",
-	"ce11",
-	"ce12",
-	"ce13",
-	"ce14",
-	"ce15",
-	"host2wbm-desc-feed",
-	"host2reo-re-injection",
-	"host2reo-command",
-	"host2rxdma-monitor-ring3",
-	"host2rxdma-monitor-ring2",
-	"host2rxdma-monitor-ring1",
-	"reo2ost-exception",
-	"wbm2host-rx-release",
-	"reo2host-status",
-	"reo2host-destination-ring4",
-	"reo2host-destination-ring3",
-	"reo2host-destination-ring2",
-	"reo2host-destination-ring1",
-	"rxdma2host-monitor-destination-mac3",
-	"rxdma2host-monitor-destination-mac2",
-	"rxdma2host-monitor-destination-mac1",
-	"ppdu-end-interrupts-mac3",
-	"ppdu-end-interrupts-mac2",
-	"ppdu-end-interrupts-mac1",
-	"rxdma2host-monitor-status-ring-mac3",
-	"rxdma2host-monitor-status-ring-mac2",
-	"rxdma2host-monitor-status-ring-mac1",
-	"host2rxdma-host-buf-ring-mac3",
-	"host2rxdma-host-buf-ring-mac2",
-	"host2rxdma-host-buf-ring-mac1",
-	"rxdma2host-destination-ring-mac3",
-	"rxdma2host-destination-ring-mac2",
-	"rxdma2host-destination-ring-mac1",
-	"host2tcl-input-ring4",
-	"host2tcl-input-ring3",
-	"host2tcl-input-ring2",
-	"host2tcl-input-ring1",
-	"wbm2host-tx-completions-ring4",
-	"wbm2host-tx-completions-ring3",
-	"wbm2host-tx-completions-ring2",
-	"wbm2host-tx-completions-ring1",
-	"tcl2host-status-ring",
-};
-
 static void ath12k_pci_select_window(struct ath12k_pci *ab_pci, u32 offset)
 {
 	struct ath12k_base *ab = ab_pci->ab;
@@ -180,8 +85,9 @@ static void ath12k_pci_select_window(struct ath12k_pci *ab_pci, u32 offset)
 	}
 }
 
-static void ath12k_pci_select_static_window(struct ath12k_pci *ab_pci)
+static void ath12k_pci_select_static_window(struct ath12k_base *ab)
 {
+	struct ath12k_pci *ab_pci = ath12k_pci_priv(ab);
 	u32 umac_window = u32_get_bits(HAL_SEQ_WCSS_UMAC_OFFSET, WINDOW_VALUE_MASK);
 	u32 ce_window = u32_get_bits(HAL_CE_WFSS_CE_REG_BASE, WINDOW_VALUE_MASK);
 	u32 window;
@@ -192,24 +98,7 @@ static void ath12k_pci_select_static_window(struct ath12k_pci *ab_pci)
 	ab_pci->register_window = window;
 	spin_unlock_bh(&ab_pci->window_lock);
 
-	iowrite32(WINDOW_ENABLE_BIT | window, ab_pci->ab->mem + WINDOW_REG_ADDRESS);
-}
-
-static u32 ath12k_pci_get_window_start(struct ath12k_base *ab,
-				       u32 offset)
-{
-	u32 window_start;
-
-	/* If offset lies within DP register range, use 3rd window */
-	if ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) < WINDOW_RANGE_MASK)
-		window_start = 3 * WINDOW_START;
-	/* If offset lies within CE register range, use 2nd window */
-	else if ((offset ^ HAL_CE_WFSS_CE_REG_BASE) < WINDOW_RANGE_MASK)
-		window_start = 2 * WINDOW_START;
-	else
-		window_start = WINDOW_START;
-
-	return window_start;
+	iowrite32(WINDOW_ENABLE_BIT | window, ab->mem + WINDOW_REG_ADDRESS);
 }
 
 static void ath12k_pci_soc_global_reset(struct ath12k_base *ab)
@@ -340,275 +229,6 @@ static void ath12k_pci_sw_reset(struct ath12k_base *ab, bool power_on)
 	ath12k_mhi_set_mhictrl_reset(ab);
 }
 
-static void ath12k_pci_free_ext_irq(struct ath12k_base *ab)
-{
-	int i, j;
-
-	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
-		struct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
-
-		for (j = 0; j < irq_grp->num_irq; j++)
-			free_irq(ab->irq_num[irq_grp->irqs[j]], irq_grp);
-
-		netif_napi_del(&irq_grp->napi);
-	}
-}
-
-static void ath12k_pci_free_irq(struct ath12k_base *ab)
-{
-	int i, irq_idx;
-
-	for (i = 0; i < ab->hw_params->ce_count; i++) {
-		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
-			continue;
-		irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;
-		free_irq(ab->irq_num[irq_idx], &ab->ce.ce_pipe[i]);
-	}
-
-	ath12k_pci_free_ext_irq(ab);
-}
-
-static void ath12k_pci_ce_irq_enable(struct ath12k_base *ab, u16 ce_id)
-{
-	u32 irq_idx;
-
-	irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + ce_id;
-	enable_irq(ab->irq_num[irq_idx]);
-}
-
-static void ath12k_pci_ce_irq_disable(struct ath12k_base *ab, u16 ce_id)
-{
-	u32 irq_idx;
-
-	irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + ce_id;
-	disable_irq_nosync(ab->irq_num[irq_idx]);
-}
-
-static void ath12k_pci_ce_irqs_disable(struct ath12k_base *ab)
-{
-	int i;
-
-	for (i = 0; i < ab->hw_params->ce_count; i++) {
-		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
-			continue;
-		ath12k_pci_ce_irq_disable(ab, i);
-	}
-}
-
-static void ath12k_pci_sync_ce_irqs(struct ath12k_base *ab)
-{
-	int i;
-	int irq_idx;
-
-	for (i = 0; i < ab->hw_params->ce_count; i++) {
-		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
-			continue;
-
-		irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;
-		synchronize_irq(ab->irq_num[irq_idx]);
-	}
-}
-
-static void ath12k_pci_ce_tasklet(struct tasklet_struct *t)
-{
-	struct ath12k_ce_pipe *ce_pipe = from_tasklet(ce_pipe, t, intr_tq);
-
-	ath12k_ce_per_engine_service(ce_pipe->ab, ce_pipe->pipe_num);
-
-	ath12k_pci_ce_irq_enable(ce_pipe->ab, ce_pipe->pipe_num);
-}
-
-static irqreturn_t ath12k_pci_ce_interrupt_handler(int irq, void *arg)
-{
-	struct ath12k_ce_pipe *ce_pipe = arg;
-
-	/* last interrupt received for this CE */
-	ce_pipe->timestamp = jiffies;
-
-	ath12k_pci_ce_irq_disable(ce_pipe->ab, ce_pipe->pipe_num);
-	tasklet_schedule(&ce_pipe->intr_tq);
-
-	return IRQ_HANDLED;
-}
-
-static void ath12k_pci_ext_grp_disable(struct ath12k_ext_irq_grp *irq_grp)
-{
-	int i;
-
-	for (i = 0; i < irq_grp->num_irq; i++)
-		disable_irq_nosync(irq_grp->ab->irq_num[irq_grp->irqs[i]]);
-}
-
-static void __ath12k_pci_ext_irq_disable(struct ath12k_base *sc)
-{
-	int i;
-
-	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
-		struct ath12k_ext_irq_grp *irq_grp = &sc->ext_irq_grp[i];
-
-		ath12k_pci_ext_grp_disable(irq_grp);
-
-		napi_synchronize(&irq_grp->napi);
-		napi_disable(&irq_grp->napi);
-	}
-}
-
-static void ath12k_pci_ext_grp_enable(struct ath12k_ext_irq_grp *irq_grp)
-{
-	int i;
-
-	for (i = 0; i < irq_grp->num_irq; i++)
-		enable_irq(irq_grp->ab->irq_num[irq_grp->irqs[i]]);
-}
-
-static void ath12k_pci_sync_ext_irqs(struct ath12k_base *ab)
-{
-	int i, j, irq_idx;
-
-	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
-		struct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
-
-		for (j = 0; j < irq_grp->num_irq; j++) {
-			irq_idx = irq_grp->irqs[j];
-			synchronize_irq(ab->irq_num[irq_idx]);
-		}
-	}
-}
-
-static int ath12k_pci_ext_grp_napi_poll(struct napi_struct *napi, int budget)
-{
-	struct ath12k_ext_irq_grp *irq_grp = container_of(napi,
-						struct ath12k_ext_irq_grp,
-						napi);
-	struct ath12k_base *ab = irq_grp->ab;
-	int work_done;
-
-	work_done = ath12k_dp_service_srng(ab, irq_grp, budget);
-	if (work_done < budget) {
-		napi_complete_done(napi, work_done);
-		ath12k_pci_ext_grp_enable(irq_grp);
-	}
-
-	if (work_done > budget)
-		work_done = budget;
-
-	return work_done;
-}
-
-static irqreturn_t ath12k_pci_ext_interrupt_handler(int irq, void *arg)
-{
-	struct ath12k_ext_irq_grp *irq_grp = arg;
-
-	ath12k_dbg(irq_grp->ab, ATH12K_DBG_PCI, "ext irq:%d\n", irq);
-
-	/* last interrupt received for this group */
-	irq_grp->timestamp = jiffies;
-
-	ath12k_pci_ext_grp_disable(irq_grp);
-
-	napi_schedule(&irq_grp->napi);
-
-	return IRQ_HANDLED;
-}
-
-static int ath12k_pci_ext_irq_config(struct ath12k_base *ab)
-{
-	int i, j, ret, num_vectors = 0;
-	u32 user_base_data = 0, base_vector = 0, base_idx, budget;
-	struct ath12k_pci *ar_pci = (struct ath12k_pci *)ab->drv_priv;
-
-	base_idx = ATH12K_PCI_IRQ_CE0_OFFSET + CE_COUNT_MAX;
-	ret = ath12k_pci_get_user_msi_assignment(ab, "DP",
-						 &num_vectors,
-						 &user_base_data,
-						 &base_vector);
-	if (ret < 0)
-		return ret;
-
-	if (ath12k_napi_poll_budget < NAPI_POLL_WEIGHT)
-		ath12k_napi_poll_budget = NAPI_POLL_WEIGHT;
-
-	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
-		struct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
-		u32 num_irq = 0;
-
-		irq_grp->ab = ab;
-		irq_grp->grp_id = i;
-		init_dummy_netdev(&irq_grp->napi_ndev);
-
-		if (ab->hw_params->ring_mask->rx_mon_dest[i])
-			budget = NAPI_POLL_WEIGHT;
-		else
-			budget = ath12k_napi_poll_budget;
-
-		/* Apply a reduced budget for tx completion to prioritize tx
-		 * enqueue operation */
-		if (ab->hw_params->ring_mask->tx[i])
-			budget = tx_comp_budget;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
-		netif_napi_add(&irq_grp->napi_ndev, &irq_grp->napi,
-			       ath12k_pci_ext_grp_napi_poll, budget);
-#else
-		 netif_napi_add_weight(&irq_grp->napi_ndev, &irq_grp->napi,
-                               ath12k_pci_ext_grp_napi_poll,budget);
-#endif
-
-		if (ab->hw_params->ring_mask->tx[i] ||
-		    ab->hw_params->ring_mask->rx[i] ||
-		    ab->hw_params->ring_mask->rx_err[i] ||
-		    ab->hw_params->ring_mask->rx_wbm_rel[i] ||
-		    ab->hw_params->ring_mask->reo_status[i] ||
-		    ab->hw_params->ring_mask->host2rxdma[i] ||
-		    ab->hw_params->ring_mask->ppe2tcl[i] ||
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-		    ab->hw_params->ring_mask->wbm2sw6_ppeds_tx_cmpln[i] ||
-#endif
-		    ab->hw_params->ring_mask->reo2ppe[i] ||
-		    ab->hw_params->ring_mask->rx_mon_dest[i]) {
-			num_irq = 1;
-		}
-
-		irq_grp->num_irq = num_irq;
-		irq_grp->irqs[0] = base_idx + i;
-
-		for (j = 0; j < irq_grp->num_irq; j++) {
-			int irq_idx = irq_grp->irqs[j];
-			int vector = (i % num_vectors) + base_vector;
-			int irq = ath12k_pci_get_msi_irq(ab->dev, vector);
-			u8 bus_id = pci_domain_nr(ar_pci->pdev->bus);
-			if (bus_id > ATH12K_MAX_PCI_DOMAINS) {
-				ath12k_warn(ab, ATH12K_DBG_PCI, "bus_id:%d\n",
-					    bus_id);
-				bus_id = ATH12K_MAX_PCI_DOMAINS;
-			}
-
-			ab->irq_num[irq_idx] = irq;
-
-			ath12k_dbg(ab, ATH12K_DBG_PCI,
-				   "irq:%d group:%d\n", irq, i);
-
-			scnprintf(dp_irq_name[bus_id][i], DP_IRQ_NAME_LEN,
-				"pci%u_wlan_dp_%u", bus_id, i);
-			ath12k_dbg(ab, ATH12K_DBG_PCI,
-				"PCI bus id: pci:%d IRQ Name:%s\n",
-						bus_id, dp_irq_name[bus_id][i]);
-			irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);
-			ret = request_irq(irq, ath12k_pci_ext_interrupt_handler,
-					  IRQF_SHARED,
-					  dp_irq_name[bus_id][i], irq_grp);
-			if (ret) {
-				ath12k_err(ab, "failed request irq %d: %d\n",
-					   vector, ret);
-				return ret;
-			}
-
-			disable_irq_nosync(ab->irq_num[irq_idx]);
-		}
-	}
-
-	return 0;
-}
-
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 int ath12k_pci_ppeds_register_interrupts(struct ath12k_base *ab, int type, int vector,
 					int ring_num)
@@ -623,7 +243,7 @@ int ath12k_pci_ppeds_register_interrupts(struct ath12k_base *ab, int type, int v
 	    ring_num == HAL_WBM2SW_PPEDS_TX_CMPLN_RING_NUM)) {
 		return 0;
 	}
-	irq = ath12k_pci_get_msi_irq(ab->dev, vector);
+	irq = ath12k_hif_get_msi_irq(ab, vector);
 
 	irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);
 	if (type == HAL_PPE2TCL) {
@@ -685,55 +305,12 @@ void ath12k_pci_ppeds_free_interrupts(struct ath12k_base *ab)
 }
 #endif
 
-static int ath12k_pci_config_irq(struct ath12k_base *ab)
+int ath12k_pci_get_msi_irq(struct ath12k_base *ab, unsigned int vector)
 {
-	struct ath12k_ce_pipe *ce_pipe;
-	u32 msi_data_start;
-	u32 msi_data_count, msi_data_idx;
-	u32 msi_irq_start;
-	unsigned int msi_data;
-	int irq, i, ret, irq_idx;
-
-	ret = ath12k_pci_get_user_msi_assignment(ab,
-						 "CE", &msi_data_count,
-						 &msi_data_start, &msi_irq_start);
-	if (ret)
-		return ret;
-
-	/* Configure CE irqs */
-
-	for (i = 0, msi_data_idx = 0; i < ab->hw_params->ce_count; i++) {
-		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
-			continue;
-
-		msi_data = (msi_data_idx % msi_data_count) + msi_irq_start;
-		irq = ath12k_pci_get_msi_irq(ab->dev, msi_data);
-		ce_pipe = &ab->ce.ce_pipe[i];
-
-		irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;
-
-		tasklet_setup(&ce_pipe->intr_tq, ath12k_pci_ce_tasklet);
-
-		ret = request_irq(irq, ath12k_pci_ce_interrupt_handler,
-				  IRQF_SHARED, irq_name[irq_idx],
-				  ce_pipe);
-		if (ret) {
-			ath12k_err(ab, "failed to request irq %d: %d\n",
-				   irq_idx, ret);
-			return ret;
-		}
-
-		ab->irq_num[irq_idx] = irq;
-		msi_data_idx++;
-
-		ath12k_pci_ce_irq_disable(ab, i);
-	}
-
-	ret = ath12k_pci_ext_irq_config(ab);
-	if (ret)
-		return ret;
+	struct device *dev = ab->dev;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 
-	return 0;
+	return pci_irq_vector(pci_dev, vector);
 }
 
 static void ath12k_umac_reset_tasklet_handler(struct tasklet_struct *t)
@@ -769,14 +346,14 @@ static int ath12k_dp_umac_pci_config_irq(struct ath12k_base *ab)
         int irq, ret;
 	struct ath12k_dp_umac_reset *umac_reset = &ab->dp_umac_reset;
 
-        ret = ath12k_pci_get_user_msi_assignment(ab,
+        ret = ath12k_pcic_get_user_msi_assignment(ab,
                                                  "DP", &msi_data_count,
                                                  &msi_data_start, &msi_irq_start);
         if (ret)
                 return ret;
 
 	msi_data = (umac_reset->intr_offset % msi_data_count) + msi_irq_start;
-	irq = ath12k_pci_get_msi_irq(ab->dev, msi_data);
+	irq = ath12k_pci_get_msi_irq(ab, msi_data);
 	umac_reset->irq_num = irq;
 	tasklet_setup(&umac_reset->intr_tq, ath12k_umac_reset_tasklet_handler);
 
@@ -818,17 +395,6 @@ static void ath12k_pci_init_qmi_ce_config(struct ath12k_base *ab)
 	ab->qmi.service_ins_id += ab_pci->instance;
 }
 
-static void ath12k_pci_ce_irqs_enable(struct ath12k_base *ab)
-{
-	int i;
-
-	for (i = 0; i < ab->hw_params->ce_count; i++) {
-		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
-			continue;
-		ath12k_pci_ce_irq_enable(ab, i);
-	}
-}
-
 static void ath12k_pci_msi_config(struct ath12k_pci *ab_pci, bool enable)
 {
 	struct pci_dev *dev = ab_pci->pdev;
@@ -857,7 +423,7 @@ static void ath12k_pci_msi_disable(struct ath12k_pci *ab_pci)
 static int ath12k_pci_msi_alloc(struct ath12k_pci *ab_pci)
 {
 	struct ath12k_base *ab = ab_pci->ab;
-	const struct ath12k_msi_config *msi_config = ab_pci->msi_config;
+	const struct ath12k_msi_config *msi_config = ab->msi.config;
 	struct msi_desc *msi_desc;
 	int num_vectors;
 	int ret;
@@ -885,7 +451,7 @@ static int ath12k_pci_msi_alloc(struct ath12k_pci *ab_pci)
 		goto free_msi_vector;
 	}
 
-	ab_pci->msi_ep_base_data = msi_desc->msg.data;
+	ab->msi.ep_base_data = msi_desc->msg.data;
 #if LINUX_VERSION_IS_GEQ(5,10,0)
 	if (msi_desc->pci.msi_attrib.is_64)
 #else
@@ -893,7 +459,7 @@ static int ath12k_pci_msi_alloc(struct ath12k_pci *ab_pci)
 #endif
 		set_bit(ATH12K_PCI_FLAG_IS_MSI_64, &ab_pci->flags);
 
-	ath12k_dbg(ab, ATH12K_DBG_PCI, "msi base data is %d\n", ab_pci->msi_ep_base_data);
+	ath12k_dbg(ab, ATH12K_DBG_PCI, "msi base data is %d\n", ab->msi.ep_base_data);
 
 	return 0;
 
@@ -1047,105 +613,6 @@ static void ath12k_pci_aspm_restore(struct ath12k_pci *ab_pci)
 					   ab_pci->link_ctl);
 }
 
-static void ath12k_pci_kill_tasklets(struct ath12k_base *ab)
-{
-	int i;
-
-	for (i = 0; i < ab->hw_params->ce_count; i++) {
-		struct ath12k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];
-
-		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
-			continue;
-
-		tasklet_kill(&ce_pipe->intr_tq);
-	}
-}
-
-static void ath12k_pci_ce_irq_disable_sync(struct ath12k_base *ab)
-{
-	ath12k_pci_ce_irqs_disable(ab);
-	ath12k_pci_sync_ce_irqs(ab);
-	ath12k_pci_kill_tasklets(ab);
-}
-
-int ath12k_pci_map_service_to_pipe(struct ath12k_base *ab, u16 service_id,
-				   u8 *ul_pipe, u8 *dl_pipe)
-{
-	const struct service_to_pipe *entry;
-	bool ul_set = false, dl_set = false;
-	int i;
-
-	for (i = 0; i < ab->hw_params->svc_to_ce_map_len; i++) {
-		entry = &ab->hw_params->svc_to_ce_map[i];
-
-		if (__le32_to_cpu(entry->service_id) != service_id)
-			continue;
-
-		switch (__le32_to_cpu(entry->pipedir)) {
-		case PIPEDIR_NONE:
-			break;
-		case PIPEDIR_IN:
-			WARN_ON(dl_set);
-			*dl_pipe = __le32_to_cpu(entry->pipenum);
-			dl_set = true;
-			break;
-		case PIPEDIR_OUT:
-			WARN_ON(ul_set);
-			*ul_pipe = __le32_to_cpu(entry->pipenum);
-			ul_set = true;
-			break;
-		case PIPEDIR_INOUT:
-			WARN_ON(dl_set);
-			WARN_ON(ul_set);
-			*dl_pipe = __le32_to_cpu(entry->pipenum);
-			*ul_pipe = __le32_to_cpu(entry->pipenum);
-			dl_set = true;
-			ul_set = true;
-			break;
-		}
-	}
-
-	if (WARN_ON(!ul_set || !dl_set))
-		return -ENOENT;
-
-	return 0;
-}
-
-int ath12k_pci_get_msi_irq(struct device *dev, unsigned int vector)
-{
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-
-	return pci_irq_vector(pci_dev, vector);
-}
-
-int ath12k_pci_get_user_msi_assignment(struct ath12k_base *ab, char *user_name,
-				       int *num_vectors, u32 *user_base_data,
-				       u32 *base_vector)
-{
-	struct ath12k_pci *ab_pci = ath12k_pci_priv(ab);
-	const struct ath12k_msi_config *msi_config = ab_pci->msi_config;
-	int idx;
-
-	for (idx = 0; idx < msi_config->total_users; idx++) {
-		if (strcmp(user_name, msi_config->users[idx].name) == 0) {
-			*num_vectors = msi_config->users[idx].num_vectors;
-			*user_base_data = msi_config->users[idx].base_vector
-				+ ab_pci->msi_ep_base_data;
-			*base_vector = msi_config->users[idx].base_vector;
-
-			ath12k_dbg(ab, ATH12K_DBG_PCI, "Assign MSI to user: %s, num_vectors: %d, user_base_data: %u, base_vector: %u\n",
-				   user_name, *num_vectors, *user_base_data,
-				   *base_vector);
-
-			return 0;
-		}
-	}
-
-	ath12k_err(ab, "Failed to find MSI assignment for %s!\n", user_name);
-
-	return -EINVAL;
-}
-
 void ath12k_pci_get_msi_address(struct ath12k_base *ab, u32 *msi_addr_lo,
 				u32 *msi_addr_hi)
 {
@@ -1182,30 +649,12 @@ void ath12k_pci_get_ce_msi_idx(struct ath12k_base *ab, u32 ce_id,
 
 void ath12k_pci_hif_ce_irq_enable(struct ath12k_base *ab)
 {
-	ath12k_pci_ce_irqs_enable(ab);
+	ath12k_pcic_ce_irqs_enable(ab);
 }
 
 void ath12k_pci_hif_ce_irq_disable(struct ath12k_base *ab)
 {
-	ath12k_pci_ce_irq_disable_sync(ab);
-}
-
-void ath12k_pci_ext_irq_enable(struct ath12k_base *ab)
-{
-	int i;
-
-	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
-		struct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
-
-		napi_enable(&irq_grp->napi);
-		ath12k_pci_ext_grp_enable(irq_grp);
-	}
-}
-
-void ath12k_pci_ext_irq_disable(struct ath12k_base *ab)
-{
-	__ath12k_pci_ext_irq_disable(ab);
-	ath12k_pci_sync_ext_irqs(ab);
+	ath12k_pcic_ce_irq_disable_sync(ab);
 }
 
 int ath12k_pci_hif_suspend(struct ath12k_base *ab)
@@ -1226,12 +675,6 @@ int ath12k_pci_hif_resume(struct ath12k_base *ab)
 	return 0;
 }
 
-void ath12k_pci_stop(struct ath12k_base *ab)
-{
-	ath12k_pci_ce_irq_disable_sync(ab);
-	ath12k_ce_cleanup_pipes(ab);
-}
-
 int ath12k_pci_start(struct ath12k_base *ab)
 {
 	struct ath12k_pci *ab_pci = ath12k_pci_priv(ab);
@@ -1240,9 +683,7 @@ int ath12k_pci_start(struct ath12k_base *ab)
 
 	ath12k_pci_aspm_restore(ab_pci);
 
-	ath12k_pci_ce_irqs_enable(ab);
-	ath12k_ce_rx_post_buf(ab);
-
+	ath12k_pcic_start(ab);
 	return 0;
 }
 
@@ -1274,7 +715,7 @@ u32 ath12k_pci_read32(struct ath12k_base *ab, u32 offset)
 		/* TODO: */
 		if (offset == TCSR_SOC_HW_VERSION ||
 		    ab->hw_params->static_window_map)
-			window_start = ath12k_pci_get_window_start(ab, offset);
+			window_start = ath12k_pcic_get_window_start(ab, offset);
 		else
 			window_start = WINDOW_START;
 
@@ -1327,7 +768,7 @@ void ath12k_pci_write32(struct ath12k_base *ab, u32 offset, u32 value)
 		iowrite32(value, ab->mem + offset);
 	} else {
 		if (ab->hw_params->static_window_map)
-			window_start = ath12k_pci_get_window_start(ab, offset);
+			window_start = ath12k_pcic_get_window_start(ab, offset);
 		else
 			window_start = WINDOW_START;
 
@@ -1386,7 +827,7 @@ int ath12k_pci_power_up(struct ath12k_base *ab)
 	}
 
 	if (ab->hw_params->static_window_map)
-		ath12k_pci_select_static_window(ab_pci);
+		ath12k_pci_select_static_window(ab);
 
 	return 0;
 }
@@ -1410,18 +851,18 @@ void ath12k_pci_power_down(struct ath12k_base *ab)
 
 static const struct ath12k_hif_ops ath12k_pci_hif_ops = {
 	.start = ath12k_pci_start,
-	.stop = ath12k_pci_stop,
+	.stop = ath12k_pcic_stop,
 	.read32 = ath12k_pci_read32,
 	.write32 = ath12k_pci_write32,
 	.power_down = ath12k_pci_power_down,
 	.power_up = ath12k_pci_power_up,
 	.suspend = ath12k_pci_hif_suspend,
 	.resume = ath12k_pci_hif_resume,
-	.irq_enable = ath12k_pci_ext_irq_enable,
-	.irq_disable = ath12k_pci_ext_irq_disable,
+	.irq_enable = ath12k_pcic_ext_irq_enable,
+	.irq_disable = ath12k_pcic_ext_irq_disable,
 	.get_msi_address =  ath12k_pci_get_msi_address,
-	.get_user_msi_vector = ath12k_pci_get_user_msi_assignment,
-	.map_service_to_pipe = ath12k_pci_map_service_to_pipe,
+	.get_user_msi_vector = ath12k_pcic_get_user_msi_assignment,
+	.map_service_to_pipe = ath12k_pcic_map_service_to_pipe,
 	.ce_irq_enable = ath12k_pci_hif_ce_irq_enable,
 	.ce_irq_disable = ath12k_pci_hif_ce_irq_disable,
 	.get_ce_msi_idx = ath12k_pci_get_ce_msi_idx,
@@ -1434,6 +875,7 @@ static const struct ath12k_hif_ops ath12k_pci_hif_ops = {
 	.dp_umac_reset_irq_config = ath12k_dp_umac_pci_config_irq,
 	.dp_umac_reset_enable_irq = ath12k_dp_umac_reset_enable_irq,
 	.dp_umac_reset_free_irq = ath12k_dp_umac_reset_free_irq,
+	.get_msi_irq =  ath12k_pci_get_msi_irq,
 };
 
 static int ath12k_pci_probe(struct pci_dev *pdev,
@@ -1495,7 +937,7 @@ static int ath12k_pci_probe(struct pci_dev *pdev,
 
 	switch (pci_dev->device) {
 	case QCN9274_DEVICE_ID:
-		ab_pci->msi_config = &ath12k_msi_config[0];
+		ab->msi.config = &ath12k_msi_config[ATH12K_MSI_CONFIG_PCI];
 		ath12k_pci_read_hw_version(ab, &soc_hw_version_major,
 					   &soc_hw_version_minor);
 
@@ -1505,7 +947,7 @@ static int ath12k_pci_probe(struct pci_dev *pdev,
 			ab->hw_rev = ATH12K_HW_QCN9274_HW10;
 		break;
 	case WCN7850_DEVICE_ID:
-		ab_pci->msi_config = &ath12k_msi_config[0];
+		ab->msi.config = &ath12k_msi_config[ATH12K_MSI_CONFIG_PCI];
 		ab->hw_rev = ATH12K_HW_WCN7850_HW20;
 		break;
 
@@ -1544,7 +986,7 @@ static int ath12k_pci_probe(struct pci_dev *pdev,
 
 	ath12k_pci_init_qmi_ce_config(ab);
 
-	ret = ath12k_pci_config_irq(ab);
+	ret = ath12k_pcic_config_irq(ab);
 	if (ret) {
 		ath12k_err(ab, "failed to config irq: %d\n", ret);
 		goto err_ce_free;
@@ -1559,7 +1001,7 @@ static int ath12k_pci_probe(struct pci_dev *pdev,
 	return 0;
 
 err_free_irq:
-	ath12k_pci_free_irq(ab);
+	ath12k_pcic_free_irq(ab);
 
 err_ce_free:
 	ath12k_ce_free_pipes(ab);
@@ -1603,7 +1045,7 @@ static void ath12k_pci_remove(struct pci_dev *pdev)
 qmi_fail:
 	ath12k_mhi_unregister(ab_pci);
 
-	ath12k_pci_free_irq(ab);
+	ath12k_pcic_free_irq(ab);
 	ath12k_pci_msi_free(ab_pci);
 	ath12k_pci_free_region(ab_pci);
 
diff --git a/drivers/net/wireless/ath/ath12k/pci.h b/drivers/net/wireless/ath/ath12k/pci.h
index ffa8155..607383c 100644
--- a/drivers/net/wireless/ath/ath12k/pci.h
+++ b/drivers/net/wireless/ath/ath12k/pci.h
@@ -74,18 +74,6 @@ enum ppeds_irq_type {
 	PPEDS_IRQ_PPE_WBM2SW_REL,
 };
 
-struct ath12k_msi_user {
-	char *name;
-	int num_vectors;
-	u32 base_vector;
-};
-
-struct ath12k_msi_config {
-	int total_vectors;
-	int total_users;
-	struct ath12k_msi_user *users;
-};
-
 enum ath12k_pci_flags {
 	ATH12K_PCI_FLAG_INIT_DONE,
 	ATH12K_PCI_FLAG_IS_MSI_64,
@@ -97,7 +85,6 @@ struct ath12k_pci {
 	struct ath12k_base *ab;
 	u16 dev_id;
 	char amss_path[100];
-	u32 msi_ep_base_data;
 	struct mhi_controller *mhi_ctrl;
 	const struct ath12k_msi_config *msi_config;
 	unsigned long mhi_state;
@@ -117,25 +104,16 @@ static inline struct ath12k_pci *ath12k_pci_priv(struct ath12k_base *ab)
 	return (struct ath12k_pci *)ab->drv_priv;
 }
 
-int ath12k_pci_get_user_msi_assignment(struct ath12k_base *ab, char *user_name,
-				       int *num_vectors, u32 *user_base_data,
-				       u32 *base_vector);
-int ath12k_pci_get_msi_irq(struct device *dev, unsigned int vector);
 void ath12k_pci_write32(struct ath12k_base *ab, u32 offset, u32 value);
 u32 ath12k_pci_read32(struct ath12k_base *ab, u32 offset);
-int ath12k_pci_map_service_to_pipe(struct ath12k_base *ab, u16 service_id,
-				   u8 *ul_pipe, u8 *dl_pipe);
 void ath12k_pci_get_msi_address(struct ath12k_base *ab, u32 *msi_addr_lo,
 				u32 *msi_addr_hi);
 void ath12k_pci_get_ce_msi_idx(struct ath12k_base *ab, u32 ce_id,
 			       u32 *msi_idx);
 void ath12k_pci_hif_ce_irq_enable(struct ath12k_base *ab);
 void ath12k_pci_hif_ce_irq_disable(struct ath12k_base *ab);
-void ath12k_pci_ext_irq_enable(struct ath12k_base *ab);
-void ath12k_pci_ext_irq_disable(struct ath12k_base *ab);
 int ath12k_pci_hif_suspend(struct ath12k_base *ab);
 int ath12k_pci_hif_resume(struct ath12k_base *ab);
-void ath12k_pci_stop(struct ath12k_base *ab);
 int ath12k_pci_start(struct ath12k_base *ab);
 int ath12k_pci_power_up(struct ath12k_base *ab);
 void ath12k_pci_power_down(struct ath12k_base *ab);
diff --git a/drivers/net/wireless/ath/ath12k/pcic.c b/drivers/net/wireless/ath/ath12k/pcic.c
new file mode 100644
index 0000000..406c648
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/pcic.c
@@ -0,0 +1,905 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2019-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2021-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#include <linux/module.h>
+#include "core.h"
+#include "pcic.h"
+#include "debug.h"
+
+unsigned int tx_comp_budget = 0x7F;
+module_param_named(tx_comp_budget, tx_comp_budget, uint, 0644);
+MODULE_PARM_DESC(tx_comp_budget, "tx_comp_budget");
+
+unsigned int ath12k_napi_poll_budget = 0x7f;
+module_param_named(napi_budget, ath12k_napi_poll_budget, uint, 0644);
+MODULE_PARM_DESC(napi_budget, "Napi budget processing per rx intr");
+
+static const char *irq_name[ATH12K_IRQ_NUM_MAX] = {
+	"bhi",
+	"mhi-er0",
+	"mhi-er1",
+	"ce0",
+	"ce1",
+	"ce2",
+	"ce3",
+	"ce4",
+	"ce5",
+	"ce6",
+	"ce7",
+	"ce8",
+	"ce9",
+	"ce10",
+	"ce11",
+	"ce12",
+	"ce13",
+	"ce14",
+	"ce15",
+	"host2wbm-desc-feed",
+	"host2reo-re-injection",
+	"host2reo-command",
+	"host2rxdma-monitor-ring3",
+	"host2rxdma-monitor-ring2",
+	"host2rxdma-monitor-ring1",
+	"reo2ost-exception",
+	"wbm2host-rx-release",
+	"reo2host-status",
+	"reo2host-destination-ring4",
+	"reo2host-destination-ring3",
+	"reo2host-destination-ring2",
+	"reo2host-destination-ring1",
+	"rxdma2host-monitor-destination-mac3",
+	"rxdma2host-monitor-destination-mac2",
+	"rxdma2host-monitor-destination-mac1",
+	"ppdu-end-interrupts-mac3",
+	"ppdu-end-interrupts-mac2",
+	"ppdu-end-interrupts-mac1",
+	"rxdma2host-monitor-status-ring-mac3",
+	"rxdma2host-monitor-status-ring-mac2",
+	"rxdma2host-monitor-status-ring-mac1",
+	"host2rxdma-host-buf-ring-mac3",
+	"host2rxdma-host-buf-ring-mac2",
+	"host2rxdma-host-buf-ring-mac1",
+	"rxdma2host-destination-ring-mac3",
+	"rxdma2host-destination-ring-mac2",
+	"rxdma2host-destination-ring-mac1",
+	"host2tcl-input-ring4",
+	"host2tcl-input-ring3",
+	"host2tcl-input-ring2",
+	"host2tcl-input-ring1",
+	"wbm2host-tx-completions-ring4",
+	"wbm2host-tx-completions-ring3",
+	"wbm2host-tx-completions-ring2",
+	"wbm2host-tx-completions-ring1",
+	"tcl2host-status-ring",
+};
+
+char dp_irq_name[ATH12K_MAX_PCI_DOMAINS + 1][ATH12K_EXT_IRQ_DP_NUM_VECTORS][DP_IRQ_NAME_LEN] = {};
+char ce_irq_name[ATH12K_MAX_PCI_DOMAINS + 1][ATH12K_IRQ_NUM_MAX][DP_IRQ_NAME_LEN] = {};
+
+
+void ath12k_pcic_config_static_window(struct ath12k_base *ab)
+{
+	u32 umac_window = u32_get_bits(HAL_SEQ_WCSS_UMAC_OFFSET, WINDOW_VALUE_MASK);
+	u32 ce_window = u32_get_bits(HAL_CE_WFSS_CE_REG_BASE, WINDOW_VALUE_MASK);
+	u32 window;
+
+	window = (umac_window << 12) | (ce_window << 6);
+
+	iowrite32(WINDOW_ENABLE_BIT | window, ab->mem + WINDOW_REG_ADDRESS);
+}
+
+static void ath12k_pcic_select_static_window(struct ath12k_base *ab, u32 addr)
+{
+        u32 curr_window, cur_val, prev_window = 0;
+        volatile u32 read_val = 0;
+        int retry = 0;
+	u32 window = u32_get_bits(addr, WINDOW_VALUE_MASK);
+
+        prev_window = readl_relaxed(ab->mem + WINDOW_REG_ADDRESS);
+
+        /* Clear out last 6 bits of window register */
+        prev_window = prev_window & ~(0x3f);
+
+        /* Write the new last 6 bits of window register. Only window 1 values
+         * are changed. Window 2 and 3 are unaffected.
+         */
+        curr_window = prev_window | window;
+
+        /* Skip writing into window register if the read value
+         * is same as calculated value.
+         */
+        if (curr_window == prev_window)
+                return;
+
+        cur_val = WINDOW_ENABLE_BIT | curr_window;
+        writel_relaxed(cur_val, ab->mem + WINDOW_REG_ADDRESS);
+
+        read_val = readl_relaxed(ab->mem + WINDOW_REG_ADDRESS);
+
+        /* If value written is not yet reflected, wait till it is reflected */
+        while ((read_val != cur_val) && (retry < 10)) {
+                mdelay(1);
+                read_val = readl_relaxed(ab->mem + WINDOW_REG_ADDRESS);
+                retry++;
+        }
+	if ( retry == 10)
+		ath12k_warn(ab, "Failed to set static window for cmem init\n");
+}
+
+u32 ath12k_pcic_cmem_read32(struct ath12k_base *ab, u32 addr)
+{
+	u32 val;
+
+        if (addr < WINDOW_START) {
+                return readl_relaxed(ab->mem + addr);
+        }
+
+        ath12k_pcic_select_static_window(ab, addr);
+
+        val = readl_relaxed(ab->mem + WINDOW_START +
+                             (addr & WINDOW_RANGE_MASK));
+
+        return val;
+}
+
+void ath12k_pcic_cmem_write32(struct ath12k_base *ab, u32 addr,
+					   u32 value)
+{
+
+	if (addr < WINDOW_START) {
+                writel_relaxed(value, ab->mem + addr);
+                return;
+        }
+
+        ath12k_pcic_select_static_window(ab, addr);
+
+        writel_relaxed(value, ab->mem + WINDOW_START +
+                       (addr & WINDOW_RANGE_MASK));
+}
+
+u32 ath12k_pcic_get_window_start(struct ath12k_base *ab,
+				       u32 offset)
+{
+	u32 window_start;
+
+	/* If offset lies within DP register range, use 3rd window */
+	if ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) < WINDOW_RANGE_MASK)
+		window_start = 3 * WINDOW_START;
+	/* If offset lies within CE register range, use 2nd window */
+	else if ((offset ^ HAL_CE_WFSS_CE_REG_BASE) < WINDOW_RANGE_MASK)
+		window_start = 2 * WINDOW_START;
+	else
+		window_start = WINDOW_START;
+
+	return window_start;
+}
+
+static void ath12k_pcic_free_ext_irq(struct ath12k_base *ab)
+{
+	int i, j;
+
+	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
+		struct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
+
+		for (j = 0; j < irq_grp->num_irq; j++)
+			free_irq(ab->irq_num[irq_grp->irqs[j]], irq_grp);
+
+		netif_napi_del(&irq_grp->napi);
+	}
+}
+
+void ath12k_pcic_free_irq(struct ath12k_base *ab)
+{
+	int i, irq_idx;
+
+	for (i = 0; i < ab->hw_params->ce_count; i++) {
+		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
+			continue;
+		irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;
+		free_irq(ab->irq_num[irq_idx], &ab->ce.ce_pipe[i]);
+	}
+
+	ath12k_pcic_free_ext_irq(ab);
+}
+
+void ath12k_pcic_free_hybrid_irq(struct ath12k_base *ab)
+{
+        struct platform_device *pdev = ab->pdev;
+
+        ath12k_pcic_free_irq(ab);
+        platform_msi_domain_free_irqs(&pdev->dev);
+}
+
+static void ath12k_pcic_ce_irq_enable(struct ath12k_base *ab, u16 ce_id)
+{
+	u32 irq_idx;
+
+	irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + ce_id;
+	enable_irq(ab->irq_num[irq_idx]);
+}
+
+static void ath12k_pcic_ce_irq_disable(struct ath12k_base *ab, u16 ce_id)
+{
+	u32 irq_idx;
+
+	irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + ce_id;
+	disable_irq_nosync(ab->irq_num[irq_idx]);
+}
+
+static void ath12k_pcic_ce_irqs_disable(struct ath12k_base *ab)
+{
+	int i;
+
+	for (i = 0; i < ab->hw_params->ce_count; i++) {
+		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
+			continue;
+		ath12k_pcic_ce_irq_disable(ab, i);
+	}
+}
+
+static void ath12k_pcic_ce_tasklet(struct tasklet_struct *t)
+{
+	struct ath12k_ce_pipe *ce_pipe = from_tasklet(ce_pipe, t, intr_tq);
+
+	ath12k_ce_per_engine_service(ce_pipe->ab, ce_pipe->pipe_num);
+
+	ath12k_pcic_ce_irq_enable(ce_pipe->ab, ce_pipe->pipe_num);
+}
+
+static irqreturn_t ath12k_pcic_ce_interrupt_handler(int irq, void *arg)
+{
+	struct ath12k_ce_pipe *ce_pipe = arg;
+
+	/* last interrupt received for this CE */
+	ce_pipe->timestamp = jiffies;
+
+	ath12k_pcic_ce_irq_disable(ce_pipe->ab, ce_pipe->pipe_num);
+	tasklet_schedule(&ce_pipe->intr_tq);
+
+	return IRQ_HANDLED;
+}
+
+static void ath12k_pcic_ext_grp_disable(struct ath12k_ext_irq_grp *irq_grp)
+{
+	int i;
+
+	for (i = 0; i < irq_grp->num_irq; i++)
+		disable_irq_nosync(irq_grp->ab->irq_num[irq_grp->irqs[i]]);
+}
+
+static void __ath12k_pcic_ext_irq_disable(struct ath12k_base *sc)
+{
+	int i;
+
+	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
+		struct ath12k_ext_irq_grp *irq_grp = &sc->ext_irq_grp[i];
+
+		ath12k_pcic_ext_grp_disable(irq_grp);
+
+		napi_synchronize(&irq_grp->napi);
+		napi_disable(&irq_grp->napi);
+	}
+}
+
+static void ath12k_pcic_ext_grp_enable(struct ath12k_ext_irq_grp *irq_grp)
+{
+	int i;
+
+	for (i = 0; i < irq_grp->num_irq; i++)
+		enable_irq(irq_grp->ab->irq_num[irq_grp->irqs[i]]);
+}
+
+static void ath12k_pcic_sync_ext_irqs(struct ath12k_base *ab)
+{
+	int i, j, irq_idx;
+
+	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
+		struct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
+
+		for (j = 0; j < irq_grp->num_irq; j++) {
+			irq_idx = irq_grp->irqs[j];
+			synchronize_irq(ab->irq_num[irq_idx]);
+		}
+	}
+}
+
+static int ath12k_pcic_ext_grp_napi_poll(struct napi_struct *napi, int budget)
+{
+	struct ath12k_ext_irq_grp *irq_grp = container_of(napi,
+						struct ath12k_ext_irq_grp,
+						napi);
+	struct ath12k_base *ab = irq_grp->ab;
+	int work_done;
+
+	work_done = ath12k_dp_service_srng(ab, irq_grp, budget);
+	if (work_done < budget) {
+		napi_complete_done(napi, work_done);
+		ath12k_pcic_ext_grp_enable(irq_grp);
+	}
+
+	if (work_done > budget)
+		work_done = budget;
+
+	return work_done;
+}
+
+static irqreturn_t ath12k_pcic_ext_interrupt_handler(int irq, void *arg)
+{
+	struct ath12k_ext_irq_grp *irq_grp = arg;
+
+	ath12k_dbg(irq_grp->ab, ATH12K_DBG_PCI, "ext irq:%d\n", irq);
+
+	/* last interrupt received for this group */
+	irq_grp->timestamp = jiffies;
+
+	ath12k_pcic_ext_grp_disable(irq_grp);
+
+	napi_schedule(&irq_grp->napi);
+
+	return IRQ_HANDLED;
+}
+
+void ath12k_pcic_ce_irqs_enable(struct ath12k_base *ab)
+{
+	int i;
+
+	for (i = 0; i < ab->hw_params->ce_count; i++) {
+		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
+			continue;
+		ath12k_pcic_ce_irq_enable(ab, i);
+	}
+}
+
+static int ath12k_pcic_ext_config_gic_msi_irq(struct ath12k_base *ab, struct platform_device *pdev,
+                struct msi_desc *msi_desc, int i)
+{
+        u32 user_base_data = 0, base_vector = 0, base_idx;
+        struct ath12k_ext_irq_grp *irq_grp;
+        int j, budget, ret = 0, num_vectors = 0;
+        u8 userpd_id;
+        u32 num_irq = 0;
+
+        userpd_id = ab->userpd_id;
+        base_idx = ATH12K_PCI_IRQ_CE0_OFFSET + CE_COUNT_MAX;
+        ret = ath12k_pcic_get_user_msi_assignment(ab, "DP",
+						 &num_vectors, &user_base_data,
+						 &base_vector);
+        if (ret < 0)
+                return ret;
+
+        irq_grp = &ab->ext_irq_grp[i];
+        irq_grp->ab = ab;
+        irq_grp->grp_id = i;
+        init_dummy_netdev(&irq_grp->napi_ndev);
+
+	if (ab->hw_params->ring_mask->rx_mon_dest[i])
+		budget = NAPI_POLL_WEIGHT;
+	else
+		budget = ath12k_napi_poll_budget;
+
+	/* Apply a reduced budget for tx completion to prioritize tx
+	 * enqueue operation */
+	if (ab->hw_params->ring_mask->tx[i])
+		budget = tx_comp_budget;
+
+        netif_napi_add(&irq_grp->napi_ndev, &irq_grp->napi,
+                        ath12k_pcic_ext_grp_napi_poll, budget);
+
+        if (ab->hw_params->ring_mask->tx[i] ||
+            ab->hw_params->ring_mask->rx[i] ||
+            ab->hw_params->ring_mask->rx_err[i] ||
+            ab->hw_params->ring_mask->rx_wbm_rel[i] ||
+            ab->hw_params->ring_mask->reo_status[i] ||
+            ab->hw_params->ring_mask->host2rxdma[i] ||
+	    ab->hw_params->ring_mask->ppe2tcl[i] ||
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	    ab->hw_params->ring_mask->wbm2sw6_ppeds_tx_cmpln[i] ||
+#endif
+	    ab->hw_params->ring_mask->reo2ppe[i] ||
+	    ab->hw_params->ring_mask->rx_mon_dest[i]) {
+                num_irq = 1;
+        }
+
+        irq_grp->num_irq = num_irq;
+        irq_grp->irqs[0] = base_idx + i;
+
+        for (j = 0; j < irq_grp->num_irq; j++) {
+                int irq_idx = irq_grp->irqs[j];
+                int vector = (i % num_vectors);
+
+		scnprintf(dp_irq_name[userpd_id][i], DP_IRQ_NAME_LEN,
+                                "pci%u_wlan_dp_%u", userpd_id, i);
+                irq_set_status_flags(msi_desc->irq, IRQ_DISABLE_UNLAZY);
+                ret = devm_request_irq(&pdev->dev, msi_desc->irq,
+                                ath12k_pcic_ext_interrupt_handler,
+                                IRQF_SHARED, dp_irq_name[userpd_id][i],
+                                irq_grp);
+                if (ret) {
+                        ath12k_err(ab, "failed request irq %d: %d\n",
+                                        irq_idx, ret);
+                        return ret;
+                }
+                ab->irq_num[irq_idx] = msi_desc->irq;
+                ab->ipci.dp_irq_num[vector] = msi_desc->irq;
+                ab->ipci.dp_msi_data[i] = msi_desc->msg.data;
+                disable_irq_nosync(ab->irq_num[irq_idx]);
+        }
+        return ret;
+}
+
+static int ath12k_pcic_config_gic_msi_irq(struct ath12k_base *ab, struct platform_device *pdev,
+                struct msi_desc *msi_desc, int i)
+{
+        struct ath12k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];
+        int irq_idx, ret;
+	u8 userpd_id = ab->userpd_id;
+
+        tasklet_setup(&ce_pipe->intr_tq, ath12k_pcic_ce_tasklet);
+        irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;
+
+	scnprintf(ce_irq_name[userpd_id][irq_idx], DP_IRQ_NAME_LEN,
+                                "pci%u_wlan_ce_%u", userpd_id, irq_idx);
+
+        ret = devm_request_irq(&pdev->dev, msi_desc->irq,
+                        ath12k_pcic_ce_interrupt_handler,
+                        IRQF_SHARED, ce_irq_name[userpd_id][irq_idx],
+                        ce_pipe);
+        if (ret) {
+                ath12k_warn(ab, "failed to request irq %d: %d\n",
+                                irq_idx, ret);
+                return ret;
+        }
+        ab->irq_num[irq_idx] = msi_desc->irq;
+        ab->ipci.ce_msi_data[i] = msi_desc->msg.data;
+        ath12k_pcic_ce_irq_disable(ab, i);
+
+        return ret;
+}
+
+static void ath12k_pcic_kill_tasklets(struct ath12k_base *ab)
+{
+	int i;
+
+	for (i = 0; i < ab->hw_params->ce_count; i++) {
+		struct ath12k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];
+
+		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
+			continue;
+
+		tasklet_kill(&ce_pipe->intr_tq);
+	}
+}
+
+static void ath12k_pci_sync_ce_irqs(struct ath12k_base *ab)
+{
+	int i;
+	int irq_idx;
+
+	for (i = 0; i < ab->hw_params->ce_count; i++) {
+		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
+			continue;
+
+		irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;
+		synchronize_irq(ab->irq_num[irq_idx]);
+	}
+}
+
+void ath12k_pcic_ce_irq_disable_sync(struct ath12k_base *ab)
+{
+	ath12k_pcic_ce_irqs_disable(ab);
+	ath12k_pci_sync_ce_irqs(ab);
+	ath12k_pcic_kill_tasklets(ab);
+}
+
+int ath12k_pcic_map_service_to_pipe(struct ath12k_base *ab, u16 service_id,
+				   u8 *ul_pipe, u8 *dl_pipe)
+{
+	const struct service_to_pipe *entry;
+	bool ul_set = false, dl_set = false;
+	int i;
+
+	for (i = 0; i < ab->hw_params->svc_to_ce_map_len; i++) {
+		entry = &ab->hw_params->svc_to_ce_map[i];
+
+		if (__le32_to_cpu(entry->service_id) != service_id)
+			continue;
+
+		switch (__le32_to_cpu(entry->pipedir)) {
+		case PIPEDIR_NONE:
+			break;
+		case PIPEDIR_IN:
+			WARN_ON(dl_set);
+			*dl_pipe = __le32_to_cpu(entry->pipenum);
+			dl_set = true;
+			break;
+		case PIPEDIR_OUT:
+			WARN_ON(ul_set);
+			*ul_pipe = __le32_to_cpu(entry->pipenum);
+			ul_set = true;
+			break;
+		case PIPEDIR_INOUT:
+			WARN_ON(dl_set);
+			WARN_ON(ul_set);
+			*dl_pipe = __le32_to_cpu(entry->pipenum);
+			*ul_pipe = __le32_to_cpu(entry->pipenum);
+			dl_set = true;
+			ul_set = true;
+			break;
+		}
+	}
+
+	if (WARN_ON(!ul_set || !dl_set))
+		return -ENOENT;
+
+	return 0;
+}
+
+int
+ath12k_pcic_get_msi_irq(struct ath12k_base *ab, unsigned int vector)
+{
+        return ab->msi.irqs[vector];
+}
+
+int ath12k_pcic_get_user_msi_assignment(struct ath12k_base *ab, char *user_name,
+				       int *num_vectors, u32 *user_base_data,
+				       u32 *base_vector)
+{
+	const struct ath12k_msi_config *msi_config = ab->msi.config;
+	int idx;
+
+	for (idx = 0; idx < msi_config->total_users; idx++) {
+		if (strcmp(user_name, msi_config->users[idx].name) == 0) {
+			*num_vectors = msi_config->users[idx].num_vectors;
+			*user_base_data = msi_config->users[idx].base_vector
+				+ ab->msi.ep_base_data;
+			*base_vector = msi_config->users[idx].base_vector;
+
+			ath12k_dbg(ab, ATH12K_DBG_PCI, "Assign MSI to user: %s, num_vectors: %d, user_base_data: %u, base_vector: %u\n",
+				   user_name, *num_vectors, *user_base_data,
+				   *base_vector);
+
+			return 0;
+		}
+	}
+
+	ath12k_err(ab, "Failed to find MSI assignment for %s!\n", user_name);
+
+	return -EINVAL;
+}
+
+void ath12k_pcic_get_msi_address(struct ath12k_base *ab, u32 *msi_addr_lo,
+                                     u32 *msi_addr_hi)
+{
+        *msi_addr_lo = ab->msi.addr_lo;
+        *msi_addr_hi = ab->msi.addr_hi;
+}
+
+void ath12k_pcic_ext_irq_enable(struct ath12k_base *ab)
+{
+	int i;
+
+	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
+		struct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
+
+		napi_enable(&irq_grp->napi);
+		ath12k_pcic_ext_grp_enable(irq_grp);
+	}
+}
+
+void ath12k_pcic_ext_irq_disable(struct ath12k_base *ab)
+{
+	__ath12k_pcic_ext_irq_disable(ab);
+	ath12k_pcic_sync_ext_irqs(ab);
+}
+
+void ath12k_pcic_stop(struct ath12k_base *ab)
+{
+	ath12k_pcic_ce_irq_disable_sync(ab);
+	ath12k_ce_cleanup_pipes(ab);
+}
+
+int ath12k_pcic_start(struct ath12k_base *ab)
+{
+	ath12k_pcic_ce_irqs_enable(ab);
+	ath12k_ce_rx_post_buf(ab);
+
+	return 0;
+}
+
+u32 ath12k_pcic_ipci_read32(struct ath12k_base *ab, u32 offset)
+{
+	u32 val, window_start;
+
+	window_start = ath12k_pcic_get_window_start(ab, offset);
+	val = ioread32(ab->mem + window_start +
+		       (offset & WINDOW_RANGE_MASK));
+
+	return val;
+}
+
+void ath12k_pcic_ipci_write32(struct ath12k_base *ab, u32 offset, u32 value)
+{
+	u32 window_start;
+
+	window_start = ath12k_pcic_get_window_start(ab, offset);
+	iowrite32(value, ab->mem + window_start +
+		  (offset & WINDOW_RANGE_MASK));
+}
+
+static int ath12k_pci_ext_irq_config(struct ath12k_base *ab)
+{
+	int i, j, ret, num_vectors = 0;
+	u32 user_base_data = 0, base_vector = 0, base_idx, budget;
+	struct ath12k_pci *ar_pci = (struct ath12k_pci *)ab->drv_priv;
+
+	base_idx = ATH12K_PCI_IRQ_CE0_OFFSET + CE_COUNT_MAX;
+	ret = ath12k_pcic_get_user_msi_assignment(ab, "DP",
+						 &num_vectors,
+						 &user_base_data,
+						 &base_vector);
+	if (ret < 0)
+		return ret;
+
+	if (ath12k_napi_poll_budget < NAPI_POLL_WEIGHT)
+		ath12k_napi_poll_budget = NAPI_POLL_WEIGHT;
+
+	for (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {
+		struct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
+		u32 num_irq = 0;
+
+		irq_grp->ab = ab;
+		irq_grp->grp_id = i;
+		init_dummy_netdev(&irq_grp->napi_ndev);
+
+		if (ab->hw_params->ring_mask->rx_mon_dest[i])
+			budget = NAPI_POLL_WEIGHT;
+		else
+			budget = ath12k_napi_poll_budget;
+
+		/* Apply a reduced budget for tx completion to prioritize tx
+		 * enqueue operation */
+		if (ab->hw_params->ring_mask->tx[i])
+			budget = tx_comp_budget;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
+		netif_napi_add(&irq_grp->napi_ndev, &irq_grp->napi,
+			       ath12k_pcic_ext_grp_napi_poll, budget);
+#else
+		 netif_napi_add_weight(&irq_grp->napi_ndev, &irq_grp->napi,
+                               ath12k_pcic_ext_grp_napi_poll,budget);
+#endif
+
+		if (ab->hw_params->ring_mask->tx[i] ||
+		    ab->hw_params->ring_mask->rx[i] ||
+		    ab->hw_params->ring_mask->rx_err[i] ||
+		    ab->hw_params->ring_mask->rx_wbm_rel[i] ||
+		    ab->hw_params->ring_mask->reo_status[i] ||
+		    ab->hw_params->ring_mask->host2rxdma[i] ||
+		    ab->hw_params->ring_mask->ppe2tcl[i] ||
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+		    ab->hw_params->ring_mask->wbm2sw6_ppeds_tx_cmpln[i] ||
+#endif
+		    ab->hw_params->ring_mask->reo2ppe[i] ||
+		    ab->hw_params->ring_mask->rx_mon_dest[i]) {
+			num_irq = 1;
+		}
+
+		irq_grp->num_irq = num_irq;
+		irq_grp->irqs[0] = base_idx + i;
+
+		for (j = 0; j < irq_grp->num_irq; j++) {
+			int irq_idx = irq_grp->irqs[j];
+			int vector = (i % num_vectors) + base_vector;
+			int irq = ath12k_hif_get_msi_irq(ab, vector);
+			u8 bus_id = pci_domain_nr(ar_pci->pdev->bus);
+			if (bus_id > ATH12K_MAX_PCI_DOMAINS) {
+				ath12k_warn(ab, ATH12K_DBG_PCI, "bus_id:%d\n",
+					    bus_id);
+				bus_id = ATH12K_MAX_PCI_DOMAINS;
+			}
+
+			ab->irq_num[irq_idx] = irq;
+
+			ath12k_dbg(ab, ATH12K_DBG_PCI,
+				   "irq:%d group:%d\n", irq, i);
+
+			scnprintf(dp_irq_name[bus_id][i], DP_IRQ_NAME_LEN,
+				"pci%u_wlan_dp_%u", bus_id, i);
+			ath12k_dbg(ab, ATH12K_DBG_PCI,
+				"PCI bus id: pci:%d IRQ Name:%s\n",
+						bus_id, dp_irq_name[bus_id][i]);
+			irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);
+			ret = request_irq(irq, ath12k_pcic_ext_interrupt_handler,
+					  IRQF_SHARED,
+					  dp_irq_name[bus_id][i], irq_grp);
+			if (ret) {
+				ath12k_err(ab, "failed request irq %d: %d\n",
+					   vector, ret);
+				return ret;
+			}
+
+			disable_irq_nosync(ab->irq_num[irq_idx]);
+		}
+	}
+
+	return 0;
+}
+
+int ath12k_pcic_config_irq(struct ath12k_base *ab)
+{
+	struct ath12k_ce_pipe *ce_pipe;
+	u32 msi_data_start;
+	u32 msi_data_count, msi_data_idx;
+	u32 msi_irq_start;
+	unsigned int msi_data;
+	int irq, i, ret, irq_idx;
+
+	ret = ath12k_pcic_get_user_msi_assignment(ab,
+						 "CE", &msi_data_count,
+						 &msi_data_start, &msi_irq_start);
+	if (ret)
+		return ret;
+
+	/* Configure CE irqs */
+
+	for (i = 0, msi_data_idx = 0; i < ab->hw_params->ce_count; i++) {
+		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
+			continue;
+
+		msi_data = (msi_data_idx % msi_data_count) + msi_irq_start;
+		irq = ath12k_hif_get_msi_irq(ab, msi_data);
+		ce_pipe = &ab->ce.ce_pipe[i];
+
+		irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;
+
+		tasklet_setup(&ce_pipe->intr_tq, ath12k_pcic_ce_tasklet);
+
+		ret = request_irq(irq, ath12k_pcic_ce_interrupt_handler,
+				  IRQF_SHARED, irq_name[irq_idx],
+				  ce_pipe);
+		if (ret) {
+			ath12k_err(ab, "failed to request irq %d: %d\n",
+				   irq_idx, ret);
+			return ret;
+		}
+
+		ab->irq_num[irq_idx] = irq;
+		msi_data_idx++;
+
+		ath12k_pcic_ce_irq_disable(ab, i);
+	}
+
+	ret = ath12k_pci_ext_irq_config(ab);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void ath12k_msi_msg_handler(struct msi_desc *desc, struct msi_msg *msg)
+{
+        desc->msg.address_lo = msg->address_lo;
+        desc->msg.address_hi = msg->address_hi;
+        desc->msg.data = msg->data;
+}
+
+int ath12k_pcic_config_hybrid_irq(struct ath12k_base *ab)
+{
+	int ret;
+	struct platform_device *pdev = ab->pdev;
+	struct msi_desc *msi_desc;
+	bool ce_done = false;
+	int user_base_data, base_vector, num_vectors = 0;
+	int i = 0, j = 0, k = 0;
+
+	if (ab->userpd_id != USERPD_1 &&
+	    ab->userpd_id != USERPD_2) {
+		ath12k_warn(ab, "ath12k userpd invalid %d\n", ab->userpd_id);
+		return -ENODEV;
+	}
+
+	ab->msi.config = &ath12k_msi_config[ATH12K_MSI_CONFIG_IPCI];
+
+	ret = platform_msi_domain_alloc_irqs(&pdev->dev, ab->msi.config->total_vectors,
+					     ath12k_msi_msg_handler);
+
+	if (ret) {
+		ath12k_warn(ab, "failed to alloc irqs %d ab %pM\n", ret, ab);
+		return ret;
+	}
+
+	//TODO: Need to optimize the below code to have one loop
+	for_each_msi_entry(msi_desc, &pdev->dev) {
+		ret = ath12k_pcic_get_user_msi_assignment(ab, "CE", &num_vectors,
+                                                         &user_base_data, &base_vector);
+                if (ret < 0)
+                        return ret;
+
+		if (i < base_vector) {
+			i++;
+			continue;
+		}
+		if (j < ab->hw_params->ce_count && i < (num_vectors + base_vector)) {
+			while(j < ab->hw_params->ce_count &&
+			      ath12k_ce_get_attr_flags(ab, j) & CE_ATTR_DIS_INTR) {
+				++j;
+			}
+
+			ret = ath12k_pcic_config_gic_msi_irq(ab, pdev, msi_desc, j);
+			if (ret) {
+				ath12k_warn(ab, "failed to request irq %d\n", ret);
+				return ret;
+			}
+
+			if (j == 0) {
+				ab->msi.addr_lo = msi_desc->msg.address_lo;
+				ab->msi.addr_hi = msi_desc->msg.address_hi;
+				ab->msi.ep_base_data = msi_desc->msg.data;
+				ath12k_info(ab, "msi ep base data %d\n", ab->msi.ep_base_data);
+			}
+
+			j++;
+			if (j != ab->hw_params->ce_count)
+				ce_done = false;
+
+		} else {
+			ret = ath12k_pcic_ext_config_gic_msi_irq(ab, pdev, msi_desc, k);
+			if (ret) {
+				ath12k_warn(ab, "failed to config ext msi irq %d\n", ret);
+				return ret;
+			}
+			k++;
+		}
+		i++;
+	}
+
+	i = 0;
+
+	for_each_msi_entry(msi_desc, &pdev->dev) {
+		ret = ath12k_pcic_get_user_msi_assignment(ab, "CE", &num_vectors,
+							  &user_base_data, &base_vector);
+		if (ret < 0)
+                        return ret;
+
+                if (i < base_vector) {
+                        i++;
+                        continue;
+		}
+		if (i < (num_vectors + base_vector)) {
+			if (!ce_done  && j < ab->hw_params->ce_count) {
+				while(j < ab->hw_params->ce_count &&
+				      ath12k_ce_get_attr_flags(ab, j) & CE_ATTR_DIS_INTR) {
+					j++;
+				}
+				if (j == ab->hw_params->ce_count) {
+					ce_done = true;
+					i++;
+					continue;
+				}
+
+				ret = ath12k_pcic_config_gic_msi_irq(ab, pdev, msi_desc, j);
+				if (ret) {
+					ath12k_warn(ab, "failed to request irq %d\n", ret);
+					return ret;
+				}
+				j++;
+			}
+		} else {
+			if (k >= ATH12K_EXT_IRQ_GRP_NUM_MAX)
+				break;
+			ret = ath12k_pcic_ext_config_gic_msi_irq(ab, pdev, msi_desc, k);
+			if (ret) {
+				ath12k_warn(ab, "failed to config ext msi irq %d\n", ret);
+				return ret;
+			}
+			k++;
+		}
+		i++;
+	}
+	ab->ipci.gic_enabled = 1;
+	wake_up(&ab->ipci.gic_msi_waitq);
+
+	return ret;
+}
diff --git a/drivers/net/wireless/ath/ath12k/pcic.h b/drivers/net/wireless/ath/ath12k/pcic.h
new file mode 100644
index 0000000..52a42d0
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/pcic.h
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2019-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2021-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef _ATH11K_PCI_CMN_H
+#define _ATH11K_PCI_CMN_H
+
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include "core.h"
+#include "hif.h"
+#include <linux/msi.h>
+
+#define ATH12K_PCI_IRQ_CE0_OFFSET		3
+
+#define WINDOW_ENABLE_BIT		0x40000000
+#define WINDOW_REG_ADDRESS		0x310c
+#define WINDOW_VALUE_MASK		GENMASK(24, 19)
+#define WINDOW_START			0x80000
+#define WINDOW_RANGE_MASK		GENMASK(18, 0)
+
+#define ATH12K_MAX_PCI_DOMAINS          0x5
+#define DP_IRQ_NAME_LEN 20
+
+static const struct ath12k_msi_config ath12k_msi_config[] = {
+        {
+                /* MSI spec expects number of interrupts to be a power of 2 */
+                .total_vectors = 32,
+                .total_users = 3,
+                .users = (struct ath12k_msi_user[]) {
+                        { .name = "MHI", .num_vectors = 3, .base_vector = 0 },
+                        { .name = "CE", .num_vectors = 5, .base_vector = 3 },
+                        { .name = "DP", .num_vectors = 16, .base_vector = 8 },
+                },
+        },
+        {
+                .total_vectors = 14,
+                .total_users = 3,
+                .users = (struct ath12k_msi_user[]) {
+			{ .name = "QDSS", .num_vectors = 1, .base_vector = 0 },
+                        { .name = "CE", .num_vectors = 5, .base_vector = 1 },
+                        { .name = "DP", .num_vectors = 8, .base_vector = 6 },
+                },
+        },
+
+};
+
+int ath12k_pcic_start(struct ath12k_base *ab);
+void ath12k_pcic_stop(struct ath12k_base *ab);
+void ath12k_pcic_ipci_write32(struct ath12k_base *ab, u32 offset, u32 value);
+u32 ath12k_pcic_ipci_read32(struct ath12k_base *ab, u32 offset);
+int ath12k_pcic_get_user_msi_assignment(struct ath12k_base *ab, char *user_name,
+                                        int *num_vectors, u32 *user_base_data,
+                                        u32 *base_vector);
+void ath12k_pcic_get_msi_address(struct ath12k_base *ab, u32 *msi_addr_lo,
+                                 u32 *msi_addr_hi);
+void ath12k_pcic_config_static_window(struct ath12k_base *ab);
+int ath12k_pcic_map_service_to_pipe(struct ath12k_base *ab, u16 service_id,
+                                   u8 *ul_pipe, u8 *dl_pipe);
+void ath12k_pcic_free_hybrid_irq(struct ath12k_base *ab);
+void ath12k_pcic_cmem_write32(struct ath12k_base *ab, u32 addr,
+					   u32 value);
+u32 ath12k_pcic_cmem_read32(struct ath12k_base *ab, u32 addr);
+void ath12k_pcic_ext_irq_enable(struct ath12k_base *ab);
+void ath12k_pcic_ext_irq_disable(struct ath12k_base *ab);
+u32 ath12k_pcic_get_window_start(struct ath12k_base *ab, u32 offset);
+void ath12k_pcic_ce_irqs_enable(struct ath12k_base *ab);
+void ath12k_pcic_ce_irq_disable_sync(struct ath12k_base *ab);
+int ath12k_pcic_get_msi_irq(struct ath12k_base *ab, unsigned int vector);
+int ath12k_pcic_config_hybrid_irq(struct ath12k_base *ab);
+int ath12k_pcic_config_irq(struct ath12k_base *ab);
+void ath12k_pcic_free_irq(struct ath12k_base *ab);
+#endif
diff --git a/drivers/net/wireless/ath/ath12k/qmi.c b/drivers/net/wireless/ath/ath12k/qmi.c
index 6e598e8..98ceb78 100644
--- a/drivers/net/wireless/ath/ath12k/qmi.c
+++ b/drivers/net/wireless/ath/ath12k/qmi.c
@@ -1286,6 +1286,68 @@ static struct qmi_elem_info qmi_wlanfw_cap_req_msg_v01_ei[] = {
 	},
 };
 
+static struct qmi_elem_info qmi_wlanfw_device_info_req_msg_v01_ei[] = {
+	{
+		.data_type      = QMI_EOTI,
+		.array_type     = NO_ARRAY,
+		.tlv_type       = QMI_COMMON_TLV_TYPE,
+	},
+};
+
+struct qmi_elem_info qmi_wlanfw_device_info_resp_msg_v01_ei[] = {
+        {
+                .data_type      = QMI_STRUCT,
+                .elem_len       = 1,
+                .elem_size      = sizeof(struct qmi_response_type_v01),
+                .array_type     = NO_ARRAY,
+                .tlv_type       = 0x02,
+                .offset         = offsetof(struct qmi_wlanfw_device_info_resp_msg_v01,
+                                           resp),
+                .ei_array       = qmi_response_type_v01_ei,
+        },
+        {
+                .data_type      = QMI_OPT_FLAG,
+                .elem_len       = 1,
+                .elem_size      = sizeof(u8),
+                .array_type     = NO_ARRAY,
+                .tlv_type       = 0x10,
+                .offset         = offsetof(struct qmi_wlanfw_device_info_resp_msg_v01,
+                                           bar_addr_valid),
+        },
+        {
+                .data_type      = QMI_UNSIGNED_8_BYTE,
+                .elem_len       = 1,
+                .elem_size      = sizeof(u64),
+                .array_type     = NO_ARRAY,
+                .tlv_type       = 0x10,
+                .offset         = offsetof(struct qmi_wlanfw_device_info_resp_msg_v01,
+                                           bar_addr),
+        },
+        {
+                .data_type      = QMI_OPT_FLAG,
+                .elem_len       = 1,
+                .elem_size      = sizeof(u8),
+                .array_type     = NO_ARRAY,
+                .tlv_type       = 0x11,
+		.offset		= offsetof(struct qmi_wlanfw_device_info_resp_msg_v01,
+					   bar_size_valid),
+	},
+	{
+		.data_type	= QMI_UNSIGNED_4_BYTE,
+		.elem_len	= 1,
+		.elem_size	= sizeof(u32),
+		.array_type	= NO_ARRAY,
+		.tlv_type	= 0x11,
+		.offset		= offsetof(struct qmi_wlanfw_device_info_resp_msg_v01,
+					   bar_size),
+        },
+        {
+                .data_type      = QMI_EOTI,
+                .array_type     = NO_ARRAY,
+                .tlv_type       = QMI_COMMON_TLV_TYPE,
+        },
+};
+
 static struct qmi_elem_info qmi_wlanfw_rf_chip_info_s_v01_ei[] = {
 	{
 		.data_type	= QMI_UNSIGNED_4_BYTE,
@@ -4199,7 +4261,8 @@ skip_mlo_mem_init:
 		case CALDB_MEM_REGION_TYPE:
 			if (ath12k_cold_boot_cal &&
 			    ab->hw_params->cold_boot_calib) {
-				if (ab->hif.bus == ATH12K_BUS_AHB) {
+				if (ab->hif.bus == ATH12K_BUS_AHB ||
+				    ab->hif.bus == ATH12K_BUS_HYBRID) {
 					if (of_property_read_u32_array(dev->of_node,
 								       "qcom,caldb-addr", caldb_location,
 								       ARRAY_SIZE(caldb_location))) {
@@ -4263,6 +4326,22 @@ skip_mlo_mem_init:
 				} else {
 					ab->qmi.target_mem[idx].paddr = m3_dump.start;
 				}
+			} else if (ab->hif.bus == ATH12K_BUS_HYBRID) {
+				if (ab->userpd_id == USERPD_1)
+					dev_node = of_find_node_by_name(NULL, "m3_dump_qcn6432_1");
+				else if (ab->userpd_id == USERPD_2)
+					dev_node = of_find_node_by_name(NULL, "m3_dump_qcn6432_2");
+
+				if (of_address_to_resource(dev_node, 0, &m3_dump)) {
+					ath12k_err(ab, "M3_MEM_REGION Not defined in device_tree\n");
+					ret = -EINVAL;
+					goto out;
+				} else {
+					ab->qmi.target_mem[idx].paddr = m3_dump.start;
+				}
+
+			} else {
+				sz += ab->qmi.target_mem[i].size;
 			}
                         ab->qmi.target_mem[idx].v.ioaddr =
                                         ioremap(ab->qmi.target_mem[idx].paddr,
@@ -4271,7 +4350,6 @@ skip_mlo_mem_init:
 					ab->qmi.target_mem[i].size;
                         ab->qmi.target_mem[idx].type =
 					ab->qmi.target_mem[i].type;
-			sz += ab->qmi.target_mem[i].size;
 			idx++;
 			break;
 		case MLO_GLOBAL_MEM_REGION_TYPE:
@@ -4303,7 +4381,6 @@ skip_mlo_mem_init:
 				goto out;
                         }
 			ab->qmi.target_mem[idx].paddr = bdf_location[0];
-
 			ab->qmi.target_mem[idx].v.ioaddr =
 					ioremap(ab->qmi.target_mem[idx].paddr,
 						ab->qmi.target_mem[i].size);
@@ -5273,7 +5350,7 @@ int ath12k_qmi_pci_alloc_qdss_mem(struct ath12k_qmi *qmi)
 
 		ab->hremote_node = of_parse_phandle(dev->of_node, "memory-region", 0);
 		if (!ab->hremote_node) {
-			ath12k_warn(ab, "qmi fail to get hremote_node\n");
+			ath12k_warn(ab, "qmi fail to get hremote_node for pci device\n");
 			return ret;
 		}
 
@@ -5310,6 +5387,25 @@ int ath12k_qmi_pci_alloc_qdss_mem(struct ath12k_qmi *qmi)
 	return 0;
 }
 
+static
+struct device_node *ath12k_get_etr_dev_node(struct ath12k_base *ab)
+{
+	struct device_node *dev_node = NULL;
+
+	if (ab->userpd_id) {
+		if (ab->userpd_id == USERPD_1)
+			dev_node = of_find_node_by_name(NULL,
+							"q6_qcn6432_etr_1");
+		else if (ab->userpd_id == USERPD_2)
+			dev_node = of_find_node_by_name(NULL,
+							"q6_qcn6432_etr_2");
+	} else {
+		dev_node = of_find_node_by_name(NULL, "q6_etr_dump");
+	}
+
+	return dev_node;
+}
+
 int ath12k_qmi_qdss_mem_alloc(struct ath12k_qmi *qmi)
 {
 	int ret, i;
@@ -5319,7 +5415,8 @@ int ath12k_qmi_qdss_mem_alloc(struct ath12k_qmi *qmi)
 
 	switch (ab->hif.bus) {
 	case ATH12K_BUS_AHB:
-		dev_node = of_find_node_by_name(NULL, "q6_etr_dump");
+	case ATH12K_BUS_HYBRID:
+		dev_node = ath12k_get_etr_dev_node(ab);
 		if (!dev_node) {
 			ath12k_err(ab, "No q6_etr_dump available in dts\n");
 			return -ENODEV;
@@ -5451,6 +5548,84 @@ static void ath12k_qmi_event_qdss_trace_req_mem_hdlr(struct ath12k_qmi *qmi)
 	ath12k_dbg(ab, ATH12K_DBG_QMI, "QDSS configuration is completed and trace started\n");
 }
 
+static int ath12k_qmi_request_device_info(struct ath12k_base *ab)
+{
+        struct qmi_wlanfw_device_info_req_msg_v01 req;
+        struct qmi_wlanfw_device_info_resp_msg_v01 resp;
+        struct qmi_txn txn = {};
+        void *bar_addr_va = NULL;
+        int ret = 0;
+
+        /*device info message only supported for internal-PCI devices */
+        if (ab->hw_rev != ATH12K_HW_QCN6432_HW10)
+                return 0;
+
+        memset(&req, 0, sizeof(req));
+        memset(&resp, 0, sizeof(resp));
+
+        ret = qmi_txn_init(&ab->qmi.handle, &txn,
+                           qmi_wlanfw_device_info_resp_msg_v01_ei, &resp);
+        if (ret < 0)
+                goto out;
+
+        ret = qmi_send_request(&ab->qmi.handle, NULL, &txn,
+                               QMI_WLANFW_DEVICE_INFO_REQ_V01,
+                               QMI_WLANFW_DEVICE_INFO_REQ_MSG_V01,
+                               qmi_wlanfw_device_info_req_msg_v01_ei, &req);
+        if (ret < 0) {
+                ath12k_warn(ab, "qmi failed to send target device info request, err = %d\n",
+                            ret);
+                goto out;
+        }
+
+        ret = qmi_txn_wait(&txn, msecs_to_jiffies(ATH12K_QMI_WLANFW_TIMEOUT_MS));
+        if (ret < 0) {
+                ath12k_warn(ab, "qmi failed target device info request %d\n", ret);
+                goto out;
+        }
+
+        if (resp.resp.result != QMI_RESULT_SUCCESS_V01) {
+                ath12k_warn(ab, "qmi device info req failed, result: %d, err: %d\n",
+                            resp.resp.result, resp.resp.error);
+                ret = -EINVAL;
+                goto out;
+        }
+
+        if (!resp.bar_addr_valid || !resp.bar_size_valid) {
+                ath12k_warn(ab, "qmi device info response invalid, result: %d, err: %d\n",
+                            resp.resp.result, resp.resp.error);
+                ret = -EINVAL;
+                goto out;
+        }
+        if (!resp.bar_addr ||
+            resp.bar_size != QCN6432_DEVICE_BAR_SIZE) {
+                ath12k_warn(ab, "qmi device info invalid addr and size, result: %d, err: %d\n",
+                            resp.resp.result, resp.resp.error);
+                ret = -EINVAL;
+                goto out;
+        }
+
+        bar_addr_va = ioremap_nocache(resp.bar_addr, resp.bar_size);
+
+        if (!bar_addr_va) {
+                ath12k_warn(ab, "qmi device info ioremap failed\n");
+                ab->mem_len = 0;
+                ret = -EIO;
+                goto out;
+        }
+
+        ab->mem = bar_addr_va;
+        ab->mem_len = resp.bar_size;
+
+        ath12k_dbg(ab, ATH12K_DBG_QMI, "Device BAR Info pa: 0x%llx, va: 0x%p, size: 0x%lx\n",
+                   resp.bar_addr, ab->mem, ab->mem_len);
+
+        ath12k_hif_config_static_window(ab);
+        return 0;
+out:
+        return ret;
+}
+
 static int ath12k_qmi_event_load_bdf(struct ath12k_qmi *qmi)
 {
 	struct ath12k_base *ab = qmi->ab;
@@ -5462,6 +5637,12 @@ static int ath12k_qmi_event_load_bdf(struct ath12k_qmi *qmi)
 		return ret;
 	}
 
+	ret = ath12k_qmi_request_device_info(ab);
+	if (ret < 0) {
+		ath12k_warn(ab, "qmi failed to req device info:%d\n", ret);
+		return ret;
+	}
+
 	if (!ab->bus_params.fixed_bdf_addr) {
 		ret = ath12k_qmi_load_bdf_qmi(ab, ATH12K_QMI_BDF_TYPE_REGDB);
 		if (ret < 0) {
@@ -5824,6 +6005,23 @@ static const struct qmi_ops ath12k_qmi_ops = {
 	.del_server = ath12k_qmi_ops_del_server,
 };
 
+static int ath12k_wait_for_gic_msi(struct ath12k_base *ab)
+{
+	int timeout;
+
+	if (ab->hw_rev != ATH12K_HW_QCN6432_HW10)
+		return 0;
+
+	timeout = wait_event_timeout(ab->ipci.gic_msi_waitq,
+				     (ab->ipci.gic_enabled == 1),
+				     ATH12K_RCV_GIC_MSI_HDLR_DELAY);
+	if (timeout <= 0) {
+		ath12k_warn(ab, "Receive gic msi handler timed out\n");
+		return -ETIMEDOUT;
+	}
+	return 0;
+}
+
 static void ath12k_qmi_driver_event_work(struct work_struct *work)
 {
 	struct ath12k_qmi *qmi = container_of(work, struct ath12k_qmi,
@@ -5882,6 +6080,12 @@ static void ath12k_qmi_driver_event_work(struct work_struct *work)
 				clear_bit(ATH12K_FLAG_CRASH_FLUSH,
 					  &ab->dev_flags);
 				clear_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags);
+				ret = ath12k_wait_for_gic_msi(ab);
+				if (ret) {
+					ath12k_warn(ab, "failed to get qgic handler for dev %d ret: %d\n",
+						    ab->hw_rev, ret);
+					break;
+				}
 				ret = ath12k_core_qmi_firmware_ready(ab);
 				if (ret) {
 					ath12k_warn(ab, "failed to init after firmware ready: %d\n", ret);
diff --git a/drivers/net/wireless/ath/ath12k/qmi.h b/drivers/net/wireless/ath/ath12k/qmi.h
index ce128bf..86115bd 100644
--- a/drivers/net/wireless/ath/ath12k/qmi.h
+++ b/drivers/net/wireless/ath/ath12k/qmi.h
@@ -22,6 +22,7 @@
 
 #define ATH12K_QMI_WLFW_SERVICE_INS_ID_V01_QCN9274	0x07
 #define ATH12K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ5332	0x2
+#define ATH12K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6432	0x60
 #define ATH12K_QMI_WLANFW_MAX_TIMESTAMP_LEN_V01	32
 #define ATH12K_QMI_RESP_LEN_MAX			8192
 #define ATH12K_QMI_WLANFW_MAX_NUM_MEM_SEG_V01	52
@@ -53,6 +54,8 @@
 #define ATH12K_BOARD_ID_DEFAULT	0xFF
 
 #define ATH12K_QMI_INVALID_RADIO	0xFF
+#define QCN6432_DEVICE_BAR_SIZE		0x200000
+#define ATH12K_RCV_GIC_MSI_HDLR_DELAY		(3 * HZ)
 
 /* userpd_id in multi pd arch */
 enum userpd_id {
@@ -486,6 +489,8 @@ struct qmi_wlanfw_fw_cold_cal_done_ind_msg_v01 {
 #define QMI_WLANFW_CAP_RESP_MSG_V01_MAX_LEN	207
 #define QMI_WLANFW_CAP_REQ_V01			0x0024
 #define QMI_WLANFW_CAP_RESP_V01			0x0024
+#define QMI_WLANFW_DEVICE_INFO_REQ_V01		0x004C
+#define QMI_WLANFW_DEVICE_INFO_REQ_MSG_V01	0
 
 enum qmi_wlanfw_pipedir_enum_v01 {
 	QMI_WLFW_PIPEDIR_NONE_V01 = 0,
@@ -597,6 +602,18 @@ struct qmi_wlanfw_cap_req_msg_v01 {
 	char placeholder;
 };
 
+struct qmi_wlanfw_device_info_req_msg_v01 {
+	char placeholder;
+};
+
+struct qmi_wlanfw_device_info_resp_msg_v01 {
+	struct qmi_response_type_v01 resp;
+	u64 bar_addr;
+	u32 bar_size;
+	u8 bar_addr_valid;
+	u8 bar_size_valid;
+};
+
 #define QMI_WLANFW_BDF_DOWNLOAD_REQ_MSG_V01_MAX_LEN	6182
 #define QMI_WLANFW_BDF_DOWNLOAD_RESP_MSG_V01_MAX_LEN	7
 #define QMI_WLANFW_BDF_DOWNLOAD_RESP_V01		0x0025
-- 
2.17.1

