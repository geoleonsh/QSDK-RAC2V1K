From 0e71a7a40fa0c0f8cc8bcaf748bab7396a2cba85 Mon Sep 17 00:00:00 2001
From: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
Date: Mon, 21 Nov 2022 11:33:53 +0530
Subject: [PATCH] hostapd: create link based hapd ctrl sockets

Create mlo link based control sockets to access the link based commands
through hostapd_cli. This will create the link interfaces in the name of
wlanX_linkX

Ex:
To fetch link 0 status from wlan0 use below command
hostapd_cli -i wlan0 -l 0 status

If link option(-l) is not provided, the first link of the interface will
be selected by default
hostapd_cli -i wlan0 status --> It implies to the first link of wlan0

On failure of link/interface selection, below error will be observed

root@OpenWrt:/# hostapd_cli -i wlan0 -l 2 status
Failed to connect to hostapd - wpa_ctrl_open: No such file or directory

Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
---
 hostapd/hostapd_cli.c | 20 +++++++++++++++++---
 src/ap/hostapd.c      | 11 ++++++++---
 2 files changed, 25 insertions(+), 6 deletions(-)

--- a/hostapd/hostapd_cli.c
+++ b/hostapd/hostapd_cli.c
@@ -54,7 +54,11 @@ static void usage(void)
 	fprintf(stderr, "%s\n", hostapd_cli_version);
 	fprintf(stderr,
 		"\n"
+#ifdef CONFIG_IEEE80211BE
+		"usage: hostapd_cli [-p<path>] [-i<ifname>] [-l<mlo_link_id>] [-hvBr] "
+#else
 		"usage: hostapd_cli [-p<path>] [-i<ifname>] [-hvBr] "
+#endif
 		"[-a<path>] \\\n"
 		"                   [-P<pid file>] [-G<ping interval>] [command..]\n"
 		"\n"
@@ -2109,6 +2113,94 @@ static void hostapd_cli_action(struct wp
 	}
 }
 
+#ifdef CONFIG_IEEE80211BE
+/* Returns the link id from link sock name */
+static int get_link_id(char *d_name)
+{
+	char *ptr;
+
+	ptr = os_strstr(d_name, WPA_CTRL_IFACE_LINK_NAME);
+	if (!ptr) {
+		/* this should not happen */
+		printf("Failed to find the link\n");
+		return -1;
+	}
+	ptr += os_strlen(WPA_CTRL_IFACE_LINK_NAME);
+
+	return atoi(ptr);
+}
+
+static void find_first_link(char *d_name, char *first_link_name)
+{
+	int dir_link_id, first_link = 0;
+	struct dirent *dent;
+	char *ptr;
+
+	ptr = os_strstr(d_name, WPA_CTRL_IFACE_LINK_NAME);
+	if (ptr) {
+		DIR *dir = opendir(ctrl_iface_dir);
+		/* Clear the link idx from the interface name
+		 * to find the least first idx
+		 */
+		*(ptr + os_strlen(WPA_CTRL_IFACE_LINK_NAME)) = '\0';
+
+		if (dir) {
+			while ((dent = readdir(dir))) {
+				/* skip current and parent dir */
+				if (os_strcmp(dent->d_name, ".") == 0 ||
+				    os_strcmp(dent->d_name, "..") == 0)
+					continue;
+				if (!os_strstr(dent->d_name, d_name))
+					continue;
+
+				dir_link_id = get_link_id(dent->d_name);
+				if (dir_link_id == -1)
+					continue;
+
+				/* keep the least first link id */
+				first_link = first_link < dir_link_id ?
+					first_link : dir_link_id;
+			}
+			closedir(dir);
+		}
+		os_snprintf(first_link_name, os_strlen(d_name) + 4, "%s%d",
+				d_name, first_link);
+	} else
+		os_snprintf(first_link_name, os_strlen(d_name) + 2, "%s",
+				d_name);
+}
+
+static bool ctrl_iface_is_mlo(char *d_name, char *ctrl_ifname_sel)
+{
+	struct dirent *dent;
+
+	DIR *dir = opendir(ctrl_iface_dir);
+	if (dir) {
+		while ((dent = readdir(dir))) {
+			/* skip current and parent dir */
+			if (os_strcmp(dent->d_name, ".") == 0 ||
+			    os_strcmp(dent->d_name, "..") == 0)
+				continue;
+
+			/* skip dir which was not selected in caller */
+			if (ctrl_ifname_sel &&
+			    !os_strstr(dent->d_name, ctrl_ifname))
+				continue;
+
+			/* if any one of the selected dir has "*link*" in it
+			 * then we can assume that interface has links
+			 */
+			if (ctrl_ifname_sel &&
+			    !os_strstr(dent->d_name, WPA_CTRL_IFACE_LINK_NAME))
+				continue;
+
+			return true;
+		}
+	}
+
+	return false;
+}
+#endif
 
 int main(int argc, char *argv[])
 {
@@ -2116,12 +2208,20 @@ int main(int argc, char *argv[])
 	int c;
 	int daemonize = 0;
 	int reconnect = 0;
+#ifdef CONFIG_IEEE80211BE
+	int link_id = -1;
+	char buf[128];
+#endif
 
 	if (os_program_init())
 		return -1;
 
 	for (;;) {
+#ifdef CONFIG_IEEE80211BE
+		c = getopt(argc, argv, "a:BhG:i:l:p:P:rs:v");
+#else
 		c = getopt(argc, argv, "a:BhG:i:p:P:rs:v");
+#endif
 		if (c < 0)
 			break;
 		switch (c) {
@@ -2156,6 +2256,16 @@ int main(int argc, char *argv[])
 		case 's':
 			client_socket_dir = optarg;
 			break;
+#ifdef CONFIG_IEEE80211BE
+		case 'l':
+			link_id = atoi(optarg);
+			os_memset(buf, '\0', sizeof(buf));
+			os_snprintf(buf, sizeof(buf), "%s_%s%d",
+					ctrl_ifname, WPA_CTRL_IFACE_LINK_NAME, link_id);
+			os_free(ctrl_ifname);
+			ctrl_ifname = os_strdup(buf);
+			break;
+#endif
 		default:
 			usage();
 			return -1;
@@ -2172,7 +2282,11 @@ int main(int argc, char *argv[])
 		return -1;
 
 	for (;;) {
+#ifdef CONFIG_IEEE80211BE
+		if (ctrl_ifname == NULL || link_id == -1) {
+#else
 		if (ctrl_ifname == NULL) {
+#endif
 			struct dirent *dent;
 			DIR *dir = opendir(ctrl_iface_dir);
 			if (dir) {
@@ -2181,9 +2295,32 @@ int main(int argc, char *argv[])
 					    ||
 					    os_strcmp(dent->d_name, "..") == 0)
 						continue;
+#ifdef CONFIG_IEEE80211BE
+					if (ctrl_ifname &&
+					    !os_strstr(dent->d_name, ctrl_ifname))
+						continue;
+
+					if (ctrl_ifname &&
+					    !ctrl_iface_is_mlo(dent->d_name,
+							       ctrl_ifname)) {
+						break;
+					} else {
+						/* this will sort the link ids and return
+						 * the first link of that interface */
+						os_memset(buf, '\0', sizeof(buf));
+						find_first_link(dent->d_name, buf);
+					}
+#endif
 					printf("Selected interface '%s'\n",
+#ifdef CONFIG_IEEE80211BE
+					       buf);
+					if (ctrl_ifname)
+						os_free(ctrl_ifname);
+					ctrl_ifname = os_strdup(buf);
+#else
 					       dent->d_name);
 					ctrl_ifname = os_strdup(dent->d_name);
+#endif
 					break;
 				}
 				closedir(dir);
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -1619,9 +1619,24 @@ static int start_ctrl_iface(struct hosta
 	for (i = 0; i < iface->num_bss; i++) {
 		struct hostapd_data *hapd = iface->bss[i];
 
-		/* just create for the first link of MLD alone */
-		if (hapd->mld && hapd->mld->bss != hapd)
-			continue;
+#ifdef CONFIG_IEEE80211BE
+		os_memset(hapd->ctrl_sock_iface, '\0',
+				sizeof(hapd->ctrl_sock_iface));
+		os_strlcpy(hapd->ctrl_sock_iface, hapd->conf->iface,
+				sizeof(hapd->ctrl_sock_iface));
+
+		if (hapd->mld) {
+			char buf[128];
+
+			os_memset(buf, '\0', sizeof(buf));
+			os_snprintf(buf, sizeof(buf), "%s_%s%d",
+					hapd->conf->iface, WPA_CTRL_IFACE_LINK_NAME,
+					hapd->iface->mlo_link_id);
+			os_memset(hapd->ctrl_sock_iface, '\0',
+					sizeof(hapd->ctrl_sock_iface));
+			os_strlcpy(hapd->ctrl_sock_iface, buf, sizeof(buf));
+		}
+#endif
 
 		if (iface->interfaces->ctrl_iface_init(hapd)) {
 			wpa_printf(MSG_ERROR,
--- a/src/common/wpa_ctrl.h
+++ b/src/common/wpa_ctrl.h
@@ -657,4 +657,8 @@ char * wpa_ctrl_get_remote_ifname(struct
 }
 #endif
 
+#ifdef CONFIG_IEEE80211BE
+#define WPA_CTRL_IFACE_LINK_NAME	"link"
+#endif
+
 #endif /* WPA_CTRL_H */
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -4256,18 +4256,26 @@ static char * hostapd_ctrl_iface_path(st
 {
 	char *buf;
 	size_t len;
+	char *ctrl_sock_iface;
+
+#ifdef CONFIG_IEEE80211BE
+		ctrl_sock_iface = hapd->ctrl_sock_iface;
+#else
+		ctrl_sock_iface = hapd->conf->iface;
+#endif
 
 	if (hapd->conf->ctrl_interface == NULL)
 		return NULL;
 
 	len = os_strlen(hapd->conf->ctrl_interface) +
-		os_strlen(hapd->conf->iface) + 2;
+		os_strlen(ctrl_sock_iface) + 2;
+
 	buf = os_malloc(len);
 	if (buf == NULL)
 		return NULL;
 
 	os_snprintf(buf, len, "%s/%s",
-		    hapd->conf->ctrl_interface, hapd->conf->iface);
+		    hapd->conf->ctrl_interface, ctrl_sock_iface);
 	buf[len - 1] = '\0';
 	return buf;
 }
@@ -4438,7 +4446,11 @@ fail:
 #endif /* ANDROID */
 
 	if (os_strlen(hapd->conf->ctrl_interface) + 1 +
+#ifdef CONFIG_IEEE80211BE
+	    os_strlen(hapd->ctrl_sock_iface) >= sizeof(addr.sun_path))
+#else
 	    os_strlen(hapd->conf->iface) >= sizeof(addr.sun_path))
+#endif
 		goto fail;
 
 	s = socket(PF_UNIX, SOCK_DGRAM, 0);
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -185,6 +185,7 @@ struct hostapd_data {
 #ifdef CONFIG_IEEE80211BE
 	struct hostapd_mld *mld;
 	struct hostapd_data *nbss; /* Next Link BSS in same MLD */
+	char ctrl_sock_iface[IFNAMSIZ + 1];
 #endif
 	struct hostapd_config *iconf;
 	struct hostapd_bss_config *conf;
