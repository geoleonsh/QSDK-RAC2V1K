From ff3c4e5421e88cd8b5ec3ec0f9ab9c170ac5ecbb Mon Sep 17 00:00:00 2001
From: Sriram R <quic_srirrama@quicinc.com>
Date: Thu, 5 Jan 2023 17:16:43 +0530
Subject: [PATCH] ath12k: changes for handling multi link sta

Add support to create and maintain multi link sta in driver and send
corresponding peer create/assoc/delete commands to the firmware
based on new mac80211 ops to identify change in link sta.

This patch adds,
1. Refactoring of ath12k_mac_op_sta_state and new helpers to handle multi link
sta and non ML sta.
2. MLO Peer create and peer assoc wmi changes
3. HTT MLO peer map and unmap changes
4. Support for ath12k_mac_op_change_sta_links for add/remove link sta

In order to avoid any new locking per ah or add new changes in datapath
related to ML handling, creation/maintenance of new ml peer obj types or
new ML peer list per ah or ath12k_peer obj for ML  is avoided.
Rather the per link peer obj store ml info along with existing info
and can be referred/searched for using ml peer id or addr in current
operating ab itself.
The lookups by id will look for matching link peer id and ml peer id
while looping the list. The ml id starts from 8192 onwards so search
can be optimized specific to ml peer id as well based on arg peer id,
similarly for addr and mld addr.

This can be further optimized to have specific lookup for ml id or
ml addr specific apis and use in dp where the ml and link id/addr
matches for legacy peer types when required.

Things such as creation/deletion of tid queue will be owned
only by primary link peer and skipped for other parnter link peers.

The statemachine changes are restricted to AP mode until testing.

Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/core.h  |  16 +-
 drivers/net/wireless/ath/ath12k/dp.c    |   7 +
 drivers/net/wireless/ath/ath12k/dp.h    |  35 +
 drivers/net/wireless/ath/ath12k/dp_rx.c |  16 +
 drivers/net/wireless/ath/ath12k/mac.c   | 868 ++++++++++++++++++------
 drivers/net/wireless/ath/ath12k/peer.c  | 161 ++++-
 drivers/net/wireless/ath/ath12k/peer.h  |  28 +
 drivers/net/wireless/ath/ath12k/wmi.c   |  82 ++-
 drivers/net/wireless/ath/ath12k/wmi.h   |  39 ++
 9 files changed, 1017 insertions(+), 235 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -52,6 +52,9 @@ extern unsigned int ath12k_mlo_capable;
 
 #define INVALID_CIPHER 0xFFFFFFFF
 
+#define ATH12K_MAX_MLO_PEERS		256
+#define ATH12K_MLO_PEER_ID_INVALID	0xFFFF
+
 enum ath12k_supported_bw {
 	ATH12K_BW_20	= 0,
 	ATH12K_BW_40	= 1,
@@ -553,6 +556,9 @@ struct ath12k_link_sta {
 	struct ath12k_link_vif *arvif;
 	struct ath12k_sta *ahsta;
 
+	/* link address similar to ieee80211_link_sta */
+	u8 addr[ETH_ALEN];
+
 	/* the following are protected by ar->data_lock */
 	u32 changed; /* IEEE80211_RC_* */
 	u32 bw;
@@ -575,7 +581,11 @@ struct ath12k_link_sta {
 
 	u16 tcl_metadata;
 	u32 bw_prev;
-	u8 link_id;
+	u8 link_id; /* IEEE link id */
+	u8 link_idx; /* for fw use only */
+
+	/* For now the assoc link will be considered primary */
+	bool is_assoc_link;
 };
 
 struct ath12k_sta {
@@ -592,6 +602,9 @@ struct ath12k_sta {
 	struct ath12k_link_sta *link[IEEE80211_MLD_MAX_NUM_LINKS];
 	/* indicates bitmap of link sta created in FW */
 	u16 links_map;
+	u16 ml_peer_id;
+	u8 assoc_link_id;
+	u8 num_peer;
  };
 #define ATH12K_HALF_20MHZ_BW 10
 #define ATH12K_5G_MIN_CENTER 4900
@@ -993,6 +1006,7 @@ struct ath12k_hw {
 	u8 supported_band_mask;
 	u8 num_radio;
 	struct ath12k_link_vif *scan_arvif;
+	DECLARE_BITMAP(free_ml_peer_id_map, ATH12K_MAX_MLO_PEERS);
 	struct ath12k radio[0] __aligned(sizeof(void *));
 };
 
--- a/drivers/net/wireless/ath/ath12k/dp.c
+++ b/drivers/net/wireless/ath/ath12k/dp.c
@@ -36,6 +36,11 @@ void ath12k_dp_peer_cleanup(struct ath12
 		return;
 	}
 
+	if (!peer->primary_link) {
+		spin_unlock_bh(&ab->base_lock);
+		return;
+	}
+
 	ath12k_dp_rx_peer_tid_cleanup(ar, peer);
 	crypto_free_shash(peer->tfm_mmic);
 	peer->dp_setup_done = false;
@@ -49,6 +54,8 @@ int ath12k_dp_peer_setup(struct ath12k *
 	u32 reo_dest;
 	int ret = 0, tid;
 
+	/* TODO setup resources only for primary link peer for ML case */
+
 	/* NOTE: reo_dest ring id starts from 1 unlike mac_id which starts from 0 */
 	reo_dest = ar->dp.mac_id + 1;
 	ret = ath12k_wmi_set_peer_param(ar, addr, vdev_id,
--- a/drivers/net/wireless/ath/ath12k/dp.h
+++ b/drivers/net/wireless/ath/ath12k/dp.h
@@ -1248,6 +1248,8 @@ enum htt_t2h_msg_type {
 	HTT_T2H_MSG_TYPE_EXT_STATS_CONF = 0x1c,
 	HTT_T2H_MSG_TYPE_BKPRESSURE_EVENT_IND = 0x24,
 	HTT_T2H_MSG_TYPE_MLO_TIMESTAMP_OFFSET_IND = 0x28,
+	HTT_T2H_MSG_TYPE_MLO_RX_PEER_MAP = 0x29,
+	HTT_T2H_MSG_TYPE_MLO_RX_PEER_UNMAP = 0x2a,
 	HTT_T2H_MSG_TYPE_PEER_MAP3	= 0x2b,
 	HTT_T2H_MSG_TYPE_VDEV_TXRX_STATS_PERIODIC_IND = 0x2c,
 };
@@ -2062,6 +2064,39 @@ static inline void ath12k_dp_get_mac_add
 	memcpy(addr + 4, &addr_h16, ETH_ALEN - 4);
 }
 
+#define ATH12K_ML_PEER_ID		GENMASK(13, 0)
+#define ATH12K_ML_PEER_ID_VALID		BIT(13)
+
+#define ATH12K_HTT_MLO_PEER_MAP_TLV_LINK_INFO_TAG	0
+#define ATH12K_HTT_MAX_MLO_LINKS	3
+#define ATH12K_HTT_MLO_CHIP_ID		GENMASK(2, 0)
+
+struct ath11k_htt_mlo_link_peer_info {
+	struct htt_tlv tlv_hdr;
+	u16 sw_peer_id;
+	u8 vdev_id;
+	u8 chip_id;
+} __packed;
+
+#define ATH12K_HTT_MLO_PEER_MAP_INFO0_PEER_ID		GENMASK(23, 8)
+#define ATH12K_HTT_MLO_PEER_MAP_MAC_ADDR_H16		GENMASK(15, 0)
+
+struct ath11k_htt_mlo_peer_map_msg {
+	u32 info0;
+	struct htt_mac_addr mac_addr;
+	u32 info1;
+	u32 info2;
+	u32 info3;
+	u32 rsvd0;
+	u32 rsvd1;
+	struct ath11k_htt_mlo_link_peer_info link_peer[ATH12K_HTT_MAX_MLO_LINKS];
+} __packed;
+
+#define ATH12K_HTT_MLO_PEER_UNMAP_PEER_ID		GENMASK(23, 8)
+struct ath11k_htt_mlo_peer_unmap_msg {
+	u32 info0;
+} __packed;
+
 int ath12k_dp_service_srng(struct ath12k_base *ab,
 			   struct ath12k_ext_irq_grp *irq_grp,
 			   int budget);
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -1003,6 +1003,11 @@ int ath12k_dp_rx_peer_tid_setup(struct a
 		return -ENOENT;
 	}
 
+	if (!peer->primary_link) {
+		spin_unlock_bh(&ab->base_lock);
+		return 0;
+	}
+
 	if (ab->hw_params->reoq_lut_support && !dp->reoq_lut.vaddr) {
 		spin_unlock_bh(&ab->base_lock);
 		ath12k_warn(ab, "reo qref table is not setup\n");
@@ -2044,6 +2049,12 @@ void ath12k_dp_htt_htc_t2h_msg_handler(s
 				       HTT_T2H_PEER_UNMAP_INFO_PEER_ID);
 		ath12k_peer_unmap_event(ab, peer_id);
 		break;
+	case HTT_T2H_MSG_TYPE_MLO_RX_PEER_MAP:
+		ath12k_peer_mlo_map_event(ab, skb);
+		break;
+	case HTT_T2H_MSG_TYPE_MLO_RX_PEER_UNMAP:
+		ath12k_peer_mlo_unmap_event(ab, skb);
+		break;
 	case HTT_T2H_MSG_TYPE_PPDU_STATS_IND:
 		ath12k_htt_pull_ppdu_stats(ab, skb);
 		break;
@@ -3217,6 +3228,11 @@ int ath12k_dp_rx_peer_frag_setup(struct
 		return -ENOENT;
 	}
 
+	if (!peer->primary_link) {
+		spin_unlock_bh(&ab->base_lock);
+		return 0;
+	}
+
 	for (i = 0; i <= IEEE80211_NUM_TIDS; i++) {
 		rx_tid = &peer->rx_tid[i];
 		rx_tid->ab = ab;
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -1664,7 +1664,7 @@ static void ath12k_peer_assoc_h_basic(st
 	else
 		aid = sta->aid;
 
-	ether_addr_copy(arg->peer_mac, sta->addr);
+	ether_addr_copy(arg->peer_mac, arsta->addr);
 	arg->vdev_id = arvif->vdev_id;
 	arg->peer_associd = aid;
 	arg->auth_flag = true;
@@ -2091,7 +2091,7 @@ static void ath12k_peer_assoc_h_vht(stru
 	if (!user_rate_valid) {
 		ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 			   "Setting vht range MCS value to peer supported nss:%d for peer %pM\n",
-			   sta->deflink.rx_nss, sta->deflink.addr);
+			   sta->deflink.rx_nss, arsta->addr);
 		vht_mcs_mask[sta->deflink.rx_nss - 1] = vht_mcs_mask[vht_nss - 1];
 	}
 
@@ -2149,7 +2149,7 @@ static void ath12k_peer_assoc_h_vht(stru
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		   "mac vht peer %pM max_mpdu %d flags 0x%x nss_override 0x%x\n",
-		   sta->addr, arg->peer_max_mpdu, arg->peer_flags,
+		   arsta->addr, arg->peer_max_mpdu, arg->peer_flags,
 		   arg->peer_bw_rxnss_override);
 }
 
@@ -2378,7 +2378,7 @@ static void ath12k_peer_assoc_h_he(struc
 	if (!user_rate_valid) {
 		ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 			   "Setting he range MCS value to peer supported nss:%d for peer %pM\n",
-			   sta->deflink.rx_nss, sta->deflink.addr);
+			   sta->deflink.rx_nss, arsta->addr);
 		he_mcs_mask[sta->deflink.rx_nss - 1] = he_mcs_mask[he_nss - 1];
 	}
 
@@ -2461,7 +2461,7 @@ static void ath12k_peer_assoc_h_he(struc
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		   "mac he peer %pM nss %d mcs cnt %d nss_override 0x%x\n",
-		   sta->deflink.addr, arg->peer_nss,
+		   arsta->addr, arg->peer_nss,
 		   arg->peer_he_mcs_count,
 		   arg->peer_bw_rxnss_override);
 }
@@ -2723,7 +2723,7 @@ static void ath12k_peer_assoc_h_eht(stru
 	if (!user_rate_valid) {
 		ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 				"Setting eht range MCS value to peer supported nss:%d for peer %pM\n",
-				sta->deflink.rx_nss, sta->deflink.addr);
+				sta->deflink.rx_nss, arsta->addr);
 		eht_mcs_mask[sta->deflink.rx_nss - 1] = eht_mcs_mask[eht_nss - 1];
 	}
 
@@ -2795,7 +2795,7 @@ static void ath12k_peer_assoc_h_eht(stru
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		   "mac he peer %pM nss %d mcs cnt %d ru_punct_bitmap 0x%x\n",
-		   sta->deflink.addr, arg->peer_nss, arg->peer_he_mcs_count, arg->ru_punct_bitmap);
+		   arsta->addr, arg->peer_nss, arg->peer_he_mcs_count, arg->ru_punct_bitmap);
 }
 
 static void ath12k_peer_assoc_h_smps(struct ath12k_link_sta *arsta,
@@ -2872,7 +2872,54 @@ static void ath12k_peer_assoc_h_qos(stru
 	}
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac peer %pM qos %d\n",
-		   sta->addr, arg->qos_flag);
+		   arsta->addr, arg->qos_flag);
+}
+
+static void ath12k_peer_assoc_h_mlo(struct ath12k_link_sta *arsta,
+				    struct peer_assoc_params *arg)
+{
+	struct ath12k_link_vif *arvif;
+	struct ath12k_link_sta *arsta_p;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+	struct peer_assoc_mlo_params *ml = &arg->ml;
+	u8 i = 0, link_id;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	if (!sta->mlo || ahsta->ml_peer_id == ATH12K_MLO_PEER_ID_INVALID)
+		return;
+
+	ml->enabled = true;
+	ml->assoc_link = arsta->is_assoc_link;
+	/* For now considering the primary umac based on assoc link */
+	ml->primary_umac = arsta->is_assoc_link;
+	ml->peer_id_valid = true;
+	ml->logical_link_idx_valid = true;
+
+	ether_addr_copy(ml->mld_addr, sta->addr);
+	ml->logical_link_idx = arsta->link_idx;
+	ml->ml_peer_id = ahsta->ml_peer_id;
+	ml->ieee_link_id = arsta->link_id;
+	ml->num_partner_links = 0;
+
+	for_each_set_bit(link_id, &sta->valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		if (i > ATH12K_WMI_MLO_MAX_LINKS)
+			break;
+		arsta_p = ahsta->link[link_id];
+		arvif = arsta_p->arvif;
+
+		if (arsta_p == arsta)
+			continue;
+		ml->partner_info[i].vdev_id = arvif->vdev_id;
+		ml->partner_info[i].hw_link_id = arvif->ar->pdev->hw_link_id;
+		ml->partner_info[i].assoc_link = arsta_p->is_assoc_link;
+		ml->partner_info[i].primary_umac = arsta_p->is_assoc_link;
+		ml->partner_info[i].logical_link_idx_valid = true;
+		ml->partner_info[i].logical_link_idx = arsta_p->link_idx;
+		ml->num_partner_links++;
+		i++;
+	}
 }
 
 static int ath12k_peer_assoc_qos_ap(struct ath12k *ar,
@@ -2915,26 +2962,26 @@ static int ath12k_peer_assoc_qos_ap(stru
 
 	params.param = WMI_AP_PS_PEER_PARAM_UAPSD;
 	params.value = uapsd;
-	ret = ath12k_wmi_send_set_ap_ps_param_cmd(ar, sta->addr, &params);
+	ret = ath12k_wmi_send_set_ap_ps_param_cmd(ar, arsta->addr, &params);
 	if (ret)
 		goto err;
 
 	params.param = WMI_AP_PS_PEER_PARAM_MAX_SP;
 	params.value = max_sp;
-	ret = ath12k_wmi_send_set_ap_ps_param_cmd(ar, sta->addr, &params);
+	ret = ath12k_wmi_send_set_ap_ps_param_cmd(ar, arsta->addr, &params);
 	if (ret)
 		goto err;
 
 	/* TODO revisit during testing */
 	params.param = WMI_AP_PS_PEER_PARAM_SIFS_RESP_FRMTYPE;
 	params.value = DISABLE_SIFS_RESPONSE_TRIGGER;
-	ret = ath12k_wmi_send_set_ap_ps_param_cmd(ar, sta->addr, &params);
+	ret = ath12k_wmi_send_set_ap_ps_param_cmd(ar, arsta->addr, &params);
 	if (ret)
 		goto err;
 
 	params.param = WMI_AP_PS_PEER_PARAM_SIFS_RESP_UAPSD;
 	params.value = DISABLE_SIFS_RESPONSE_TRIGGER;
-	ret = ath12k_wmi_send_set_ap_ps_param_cmd(ar, sta->addr, &params);
+	ret = ath12k_wmi_send_set_ap_ps_param_cmd(ar, arsta->addr, &params);
 	if (ret)
 		goto err;
 
@@ -3141,7 +3188,7 @@ static void ath12k_peer_assoc_h_phymode(
 	}
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac peer %pM phymode %s\n",
-		   sta->addr, ath12k_wmi_phymode_str(phymode));
+		   arsta->addr, ath12k_wmi_phymode_str(phymode));
 
 	arg->peer_phymode = phymode;
 	WARN_ON(phymode == MODE_UNKNOWN);
@@ -3171,6 +3218,7 @@ static void ath12k_peer_assoc_prepare(st
 	ath12k_peer_assoc_h_eht(ar, arvif, arsta, arg);
 	ath12k_peer_assoc_h_qos(ar, arvif, arsta, arg);
 	ath12k_peer_assoc_h_smps(arsta, arg);
+	ath12k_peer_assoc_h_mlo(arsta, arg);
 
 	arsta->peer_nss = arg->peer_nss;
 
@@ -4872,7 +4920,7 @@ static int ath12k_mac_set_key(struct ath
 	}
 
 	if (sta)
-		peer_addr = sta->addr;
+		peer_addr = arsta->addr;
 	else if (ahvif->vdev_type == WMI_VDEV_TYPE_STA)
 		peer_addr = link_conf->bssid;
 	else
@@ -5111,24 +5159,24 @@ ath12k_mac_set_peer_vht_fixed_rate(struc
 
 	if (!nss) {
 		ath12k_warn(ar->ab, "No single VHT Fixed rate found to set for %pM",
-			    sta->addr);
+			    arsta->addr);
 		return -EINVAL;
 	}
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		   "Setting Fixed VHT Rate for peer %pM. Device will not switch to any other selected rates",
-		   sta->addr);
+		   arsta->addr);
 
 	rate_code = ATH12K_HW_RATE_CODE(vht_rate, nss - 1,
 					WMI_RATE_PREAMBLE_VHT);
-	ret = ath12k_wmi_set_peer_param(ar, sta->addr,
+	ret = ath12k_wmi_set_peer_param(ar, arsta->addr,
 					arvif->vdev_id,
 					WMI_PEER_PARAM_FIXED_RATE,
 					rate_code);
 	if (ret)
 		ath12k_warn(ar->ab,
 			    "failed to update STA %pM Fixed Rate %d: %d\n",
-			     sta->addr, rate_code, ret);
+			     arsta->addr, rate_code, ret);
 
 	return ret;
 }
@@ -5161,7 +5209,7 @@ ath12k_mac_set_peer_he_fixed_rate(struct
 
 	if (!nss) {
 		ath12k_warn(ar->ab, "No single HE Fixed rate found to set for %pM",
-			    sta->deflink.addr);
+			    arsta->addr);
 		return -EINVAL;
 	}
 
@@ -5171,19 +5219,19 @@ ath12k_mac_set_peer_he_fixed_rate(struct
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		   "Setting Fixed HE Rate for peer %pM. Device will not switch to any other selected rates",
-		   sta->deflink.addr);
+		   arsta->addr);
 
 	rate_code = ATH12K_HW_RATE_CODE(he_rate, nss - 1,
 					WMI_RATE_PREAMBLE_HE);
 
-	ret = ath12k_wmi_set_peer_param(ar, sta->deflink.addr,
+	ret = ath12k_wmi_set_peer_param(ar, arsta->addr,
 					arvif->vdev_id,
 					WMI_PEER_PARAM_FIXED_RATE,
 					rate_code);
 	if (ret)
 		ath12k_warn(ar->ab,
 			    "failed to update STA %pM Fixed Rate %d: %d\n",
-			    sta->deflink.addr, rate_code, ret);
+			    arsta->addr, rate_code, ret);
 
 	return ret;
 }
@@ -5271,7 +5319,7 @@ ath12k_mac_set_peer_eht_fixed_rate(struc
 
 	if (!nss) {
 		ath12k_warn(ar->ab, "No single EHT Fixed rate found to set for %pM",
-			    sta->deflink.addr);
+			    arsta->addr);
 		return -EINVAL;
 	}
 
@@ -5281,38 +5329,40 @@ ath12k_mac_set_peer_eht_fixed_rate(struc
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		   "Setting Fixed EHT Rate for peer %pM. Device will not switch to any other selected rates",
-		   sta->deflink.addr);
+		   arsta->addr);
 
 	rate_code = ATH12K_HW_RATE_CODE(eht_rate, nss - 1,
 					WMI_RATE_PREAMBLE_EHT);
 
-	ret = ath12k_wmi_set_peer_param(ar, sta->deflink.addr,
+	ret = ath12k_wmi_set_peer_param(ar, arsta->addr,
 					arvif->vdev_id,
 					WMI_PEER_PARAM_FIXED_RATE,
 					rate_code);
 	if (ret)
 		ath12k_warn(ar->ab,
 			    "failed to update STA %pM Fixed Rate %d: %d\n",
-			    sta->deflink.addr, rate_code, ret);
+			    arsta->addr, rate_code, ret);
 
 	return ret;
 }
 
 static int ath12k_station_assoc(struct ath12k *ar,
-				struct ieee80211_vif *vif,
-				struct ieee80211_sta *sta,
-				bool reassoc, u8 link_id)
+				struct ath12k_link_vif *arvif,
+				struct ath12k_link_sta *arsta,
+				bool reassoc)
 {
-	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
-	struct ath12k_link_vif *arvif = ahvif->link[link_id];
-	struct ath12k_link_sta *arsta;
-	struct ath12k_sta *ahsta;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_vif *vif = ahvif->vif;
+	struct ieee80211_sta *sta;
+	struct ieee80211_link_sta *link_sta;
 	struct peer_assoc_params peer_arg;
 	int ret = 0;
 	struct cfg80211_chan_def def;
 	enum nl80211_band band;
 	struct cfg80211_bitrate_mask *mask;
 	u8 num_vht_rates, num_he_rates, num_eht_rates, num_ht_rates;
+	u8 link_id = arvif->link_id;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -5322,6 +5372,11 @@ static int ath12k_station_assoc(struct a
 	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return -EPERM;
 
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	if (WARN_ON(rcu_access_pointer(sta->link[link_id]) == NULL))
+		return -EINVAL;
+
 	band = def.chan->band;
 	mask = &arvif->bitrate_mask;
 
@@ -5334,13 +5389,13 @@ static int ath12k_station_assoc(struct a
 	ret = ath12k_wmi_send_peer_assoc_cmd(ar, &peer_arg);
 	if (ret) {
 		ath12k_warn(ar->ab, "failed to run peer assoc for STA %pM vdev %i: %d\n",
-			    sta->addr, arvif->vdev_id, ret);
+			    arsta->addr, arvif->vdev_id, ret);
 		return ret;
 	}
 
 	if (!wait_for_completion_timeout(&ar->peer_assoc_done, 1 * HZ)) {
 		ath12k_warn(ar->ab, "failed to get peer assoc conf event for %pM vdev %i\n",
-			    sta->addr, arvif->vdev_id);
+			    arsta->addr, arvif->vdev_id);
 		return -ETIMEDOUT;
 	}
 
@@ -5382,7 +5437,7 @@ static int ath12k_station_assoc(struct a
 	if (reassoc)
 		return 0;
 
-	ret = ath12k_setup_peer_smps(ar, arvif, sta->addr,
+	ret = ath12k_setup_peer_smps(ar, arvif, arsta->addr,
 				     &sta->deflink.ht_cap,
 				     le16_to_cpu(sta->deflink.he_6ghz_capa.capa));
 	if (ret) {
@@ -5402,21 +5457,35 @@ static int ath12k_station_assoc(struct a
 		ret = ath12k_peer_assoc_qos_ap(ar, arvif, arsta);
 		if (ret) {
 			ath12k_warn(ar->ab, "failed to set qos params for STA %pM for vdev %i: %d\n",
-				    sta->addr, arvif->vdev_id, ret);
+				    arsta->addr, arvif->vdev_id, ret);
 			return ret;
 		}
 	}
 
+	spin_lock_bh(&ar->data_lock);
+
+	/* Set arsta bw and prev bw */
+        rcu_read_lock();
+	link_sta = rcu_dereference(sta->link[link_id]);
+	if (link_sta) {
+		arsta->bw = link_sta->bandwidth;
+		arsta->bw_prev = link_sta->bandwidth;
+	} else {
+		ath12k_warn(ar->ab, "failed to get link sta to store bw");
+	}
+	rcu_read_unlock();
+
+	spin_unlock_bh(&ar->data_lock);
+
 	return 0;
 }
 
 static int ath12k_station_disassoc(struct ath12k *ar,
-				   struct ieee80211_vif *vif,
-				   struct ieee80211_sta *sta,
-				   u8 link_id)
+				   struct ath12k_link_vif *arvif,
+				   struct ath12k_link_sta *arsta)
 {
-	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
-	struct ath12k_link_vif *arvif = ahvif->link[link_id];
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
 	int ret = 0;
 
 	lockdep_assert_held(&ar->conf_mutex);
@@ -5424,6 +5493,8 @@ static int ath12k_station_disassoc(struc
 	if (!arvif)
 		return -EINVAL;
 
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
 	if (!sta->wme) {
 		arvif->num_legacy_stations--;
 		ret = ath12k_recalc_rtscts_prot(arvif);
@@ -5434,6 +5505,69 @@ static int ath12k_station_disassoc(struc
 	return 0;
 }
 
+static int ath12k_station_authorize(struct ath12k *ar,
+				    struct ath12k_link_vif *arvif,
+				    struct ath12k_link_sta *arsta)
+{
+	struct ath12k_peer *peer;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+	int ret = 0;
+
+	lockdep_assert_held(&ar->conf_mutex);
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	spin_lock_bh(&ar->ab->base_lock);
+
+	peer = ath12k_peer_find(ar->ab, arvif->vdev_id, arsta->addr);
+	if (peer)
+		peer->is_authorized = true;
+
+	spin_unlock_bh(&ar->ab->base_lock);
+
+	if (ahvif->vif->type == NL80211_IFTYPE_STATION && arvif->is_up) {
+		ret = ath12k_wmi_set_peer_param(ar, arsta->addr,
+						arvif->vdev_id,
+						WMI_PEER_AUTHORIZE,
+						1);
+		if (ret)
+			ath12k_warn(ar->ab, "Unable to authorize peer %pM vdev %d: %d\n",
+				    arsta->addr, arvif->vdev_id, ret);
+	}
+
+	return ret;
+}
+
+static int ath12k_station_unauthorize(struct ath12k *ar,
+				      struct ath12k_link_vif *arvif,
+				      struct ath12k_link_sta *arsta)
+{
+	struct ath12k_peer *peer;
+	int ret = 0;
+
+	lockdep_assert_held(&ar->conf_mutex);
+	spin_lock_bh(&ar->ab->base_lock);
+
+	peer = ath12k_peer_find(ar->ab, arvif->vdev_id, arsta->addr);
+	if (peer)
+		peer->is_authorized = false;
+
+	spin_unlock_bh(&ar->ab->base_lock);
+
+	/* Driver should clear the peer keys during mac80211's ref ptr
+	 * gets cleared in __sta_info_destroy_part2 (trans from
+	 * IEEE80211_STA_AUTHORIZED to IEEE80211_STA_ASSOC)
+	 */
+	ret = ath12k_clear_peer_keys(arvif, arsta->addr);
+	if (ret)
+		ath12k_warn(ar->ab, "failed to clear all peer keys for vdev %i: %d\n",
+				arvif->vdev_id, ret);
+
+	return ret;
+}
+
 static void ath12k_sta_rc_update_wk(struct work_struct *wk)
 {
 	struct ath12k *ar;
@@ -5452,9 +5586,11 @@ static void ath12k_sta_rc_update_wk(stru
 	const struct cfg80211_bitrate_mask *mask;
 	struct peer_assoc_params peer_arg;
 	enum wmi_phy_mode peer_phymode;
+	struct ath12k_sta *ahsta;
 
 	arsta = container_of(wk, struct ath12k_link_sta, update_wk);
-	sta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);
+	ahsta = arsta->ahsta;
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 	arvif = arsta->arvif;
 	ahvif = arvif->ahvif;
 	ar = arvif->ar;
@@ -5499,64 +5635,64 @@ static void ath12k_sta_rc_update_wk(stru
 			 * followed by WMI_PEER_CHWIDTH
 			 */
 			ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac BW upgrade for sta %pM new BW %d, old BW %d\n",
-					sta->addr, bw, bw_prev);
-			err = ath12k_wmi_set_peer_param(ar, sta->addr,
+					arsta->addr, bw, bw_prev);
+			err = ath12k_wmi_set_peer_param(ar, arsta->addr,
 					arvif->vdev_id, WMI_PEER_PHYMODE,
 					peer_phymode);
 			if (err) {
 				ath12k_warn(ar->ab, "failed to update STA %pM peer phymode %d: %d\n",
-						sta->addr, peer_phymode, err);
+						arsta->addr, peer_phymode, err);
 				goto err_rc_bw_changed;
 			}
-			err = ath12k_wmi_set_peer_param(ar, sta->addr,
+			err = ath12k_wmi_set_peer_param(ar, arsta->addr,
 					arvif->vdev_id, WMI_PEER_CHWIDTH,
 					bw);
 			if (err)
 				ath12k_warn(ar->ab, "failed to update STA %pM peer bw %d: %d\n",
-						sta->addr, bw, err);
+						arsta->addr, bw, err);
 		} else {
 			/* BW is downgraded. In this case we send
 			 * WMI_PEER_CHWIDTH followed by WMI_PEER_PHYMODE
 			 */
 			ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac BW downgrade for sta %pM new BW %d,old BW %d\n",
-					sta->addr, bw, bw_prev);
-			err = ath12k_wmi_set_peer_param(ar, sta->addr,
+					arsta->addr, bw, bw_prev);
+			err = ath12k_wmi_set_peer_param(ar, arsta->addr,
 					arvif->vdev_id, WMI_PEER_CHWIDTH,
 					bw);
 			if (err) {
 				ath12k_warn(ar->ab, "failed to update STA %pM peer bw %d: %d\n",
-						sta->addr, bw, err);
+						arsta->addr, bw, err);
 				goto err_rc_bw_changed;
 			}
-			err = ath12k_wmi_set_peer_param(ar, sta->addr,
+			err = ath12k_wmi_set_peer_param(ar, arsta->addr,
 					arvif->vdev_id, WMI_PEER_PHYMODE,
 					peer_phymode);
 			if (err)
 				ath12k_warn(ar->ab, "failed to update STA %pM peer phymode %d: %d\n",
-						sta->addr, peer_phymode, err);
+						arsta->addr, peer_phymode, err);
 		}
 	}
 
 	if (changed & IEEE80211_RC_NSS_CHANGED) {
 		ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac update sta %pM nss %d\n",
-			   sta->addr, nss);
+			   arsta->addr, nss);
 
-		err = ath12k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,
+		err = ath12k_wmi_set_peer_param(ar, arsta->addr, arvif->vdev_id,
 						WMI_PEER_NSS, nss);
 		if (err)
 			ath12k_warn(ar->ab, "failed to update STA %pM nss %d: %d\n",
-				    sta->addr, nss, err);
+				    arsta->addr, nss, err);
 	}
 
 	if (changed & IEEE80211_RC_SMPS_CHANGED) {
 		ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac update sta %pM smps %d\n",
-			   sta->addr, smps);
+			   arsta->addr, smps);
 
-		err = ath12k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,
+		err = ath12k_wmi_set_peer_param(ar, arsta->addr, arvif->vdev_id,
 						WMI_PEER_MIMO_PS_STATE, smps);
 		if (err)
 			ath12k_warn(ar->ab, "failed to update STA %pM smps %d: %d\n",
-				    sta->addr, smps, err);
+				    arsta->addr, smps, err);
 	}
 
 	if (changed & IEEE80211_RC_SUPP_RATES_CHANGED) {
@@ -5601,14 +5737,14 @@ static void ath12k_sta_rc_update_wk(stru
 			 * than peer assoc
 			 */
 
-			err = ath12k_wmi_set_peer_param(ar, sta->deflink.addr,
+			err = ath12k_wmi_set_peer_param(ar, arsta->addr,
 							arvif->vdev_id,
 							WMI_PEER_PARAM_FIXED_RATE,
 							WMI_FIXED_RATE_NONE);
 			if (err)
 				ath12k_warn(ar->ab,
 					    "failed to disable peer fixed rate for STA %pM ret %d\n",
-					    sta->deflink.addr, err);
+					    arsta->addr, err);
 			ath12k_peer_assoc_prepare(ar, arvif, arsta,
 						  &peer_arg, true);
 
@@ -5616,11 +5752,11 @@ static void ath12k_sta_rc_update_wk(stru
 			err = ath12k_wmi_send_peer_assoc_cmd(ar, &peer_arg);
 			if (err)
 				ath12k_warn(ar->ab, "failed to run peer assoc for STA %pM vdev %i: %d\n",
-					    sta->addr, arvif->vdev_id, err);
+					    arsta->addr, arvif->vdev_id, err);
 
 			if (!wait_for_completion_timeout(&ar->peer_assoc_done, 1 * HZ))
 				ath12k_warn(ar->ab, "failed to get peer assoc conf event for %pM vdev %i\n",
-					    sta->addr, arvif->vdev_id);
+					    arsta->addr, arvif->vdev_id);
 		}
 	}
 err_rc_bw_changed:
@@ -5649,14 +5785,14 @@ static void ath12k_sta_set_4addr_wk(stru
 		ar = arvif->ar;
 
 		ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
-			   "setting USE_4ADDR for peer %pM\n", sta->addr);
+			   "setting USE_4ADDR for peer %pM\n", arsta->addr);
 
-		ret = ath12k_wmi_set_peer_param(ar, sta->addr,
+		ret = ath12k_wmi_set_peer_param(ar, arsta->addr,
 						arvif->vdev_id,
 						WMI_PEER_USE_4ADDR, 1);
 		if (ret)
 			ath12k_warn(ar->ab, "failed to set peer %pM 4addr capability: %d\n",
-				    sta->addr, ret);
+				    arsta->addr, ret);
 	}
 }
 
@@ -5701,6 +5837,70 @@ static void ath12k_mac_dec_num_stations(
 	ar->num_stations--;
 }
 
+static void ath12k_mac_station_post_remove(struct ath12k *ar,
+					   struct ath12k_link_vif *arvif,
+					   struct ath12k_link_sta *arsta)
+{
+	struct ath12k_peer *peer;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	ath12k_mac_dec_num_stations(arvif, arsta);
+
+	spin_lock_bh(&ar->ab->base_lock);
+	peer = ath12k_peer_find(ar->ab, arvif->vdev_id, arsta->addr);
+	if (peer && peer->sta == sta) {
+		ath12k_warn(ar->ab, "Found peer entry %pM n vdev %i after it was supposedly removed\n",
+			    arsta->addr, arvif->vdev_id);
+		peer->sta = NULL;
+		list_del(&peer->list);
+		kfree(peer);
+		ar->num_peers--;
+	}
+	spin_unlock_bh(&ar->ab->base_lock);
+
+	kfree(arsta->tx_stats);
+	arsta->tx_stats = NULL;
+
+	kfree(arsta->rx_stats);
+	arsta->rx_stats = NULL;
+	ath12k_mac_ap_ps_recalc(ar);
+	ahsta->ahvif = NULL;
+}
+
+static int ath12k_mac_station_remove(struct ath12k *ar,
+				     struct ath12k_link_vif *arvif,
+				     struct ath12k_link_sta *arsta)
+{
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+	int ret;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	lockdep_assert_held(&ar->conf_mutex);
+
+	/* This would be done separately */
+	if (sta->mlo)
+		return 0;
+
+	ath12k_dp_peer_cleanup(ar, arvif->vdev_id, arsta->addr);
+
+	ret = ath12k_peer_delete(ar, arvif->vdev_id, arsta->addr);
+	if (ret)
+		ath12k_warn(ar->ab, "Failed to delete peer: %pM for VDEV: %d\n",
+			    arsta->addr, arvif->vdev_id);
+	else
+		ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "Removed peer: %pM for VDEV: %d\n",
+			   arsta->addr, arvif->vdev_id);
+
+	ath12k_mac_station_post_remove(ar, arvif, arsta);
+
+ 	return ret;
+}
+
 static int ath12k_mac_station_add(struct ath12k *ar,
 				  struct ath12k_link_vif *arvif,
 				  struct ath12k_link_sta *arsta)
@@ -5710,7 +5910,7 @@ static int ath12k_mac_station_add(struct
 	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k_sta *ahsta = arsta->ahsta;
 	struct ieee80211_sta *sta;
-	struct peer_create_params peer_param;
+	struct peer_create_params peer_param = {0};
 	int ret;
 
 	lockdep_assert_held(&ar->conf_mutex);
@@ -5736,18 +5936,19 @@ static int ath12k_mac_station_add(struct
 	}
 
 	peer_param.vdev_id = arvif->vdev_id;
-	peer_param.peer_addr = sta->addr;
+	peer_param.peer_addr = arsta->addr;
 	peer_param.peer_type = WMI_PEER_TYPE_DEFAULT;
+	peer_param.ml_enabled = sta->mlo;
 
 	ret = ath12k_peer_create(ar, arvif, sta, &peer_param);
 	if (ret) {
 		ath12k_warn(ab, "Failed to add peer: %pM for VDEV: %d\n",
-			    sta->addr, arvif->vdev_id);
+			    arsta->addr, arvif->vdev_id);
 		goto free_rx_stats;
 	}
 
 	ath12k_dbg(ab, ATH12K_DBG_MAC, "Added peer: %pM for VDEV: %d num_stations : %d\n",
-		   sta->addr, arvif->vdev_id, ar->num_stations);
+		   arsta->addr, arvif->vdev_id, ar->num_stations);
 
 	if (ath12k_debugfs_is_extd_tx_stats_enabled(ar) && (!arsta->tx_stats)) {
 		arsta->tx_stats = kzalloc(sizeof(*arsta->tx_stats),
@@ -5766,20 +5967,20 @@ static int ath12k_mac_station_add(struct
 	ath12k_mac_ap_ps_recalc(ar);
 
 	if (ieee80211_vif_is_mesh(vif)) {
-		ret = ath12k_wmi_set_peer_param(ar, sta->addr,
+		ret = ath12k_wmi_set_peer_param(ar, arsta->addr,
 						arvif->vdev_id,
 						WMI_PEER_USE_4ADDR, 1);
 		if (ret) {
 			ath12k_warn(ab, "failed to STA %pM 4addr capability: %d\n",
-				    sta->addr, ret);
+				    arsta->addr, ret);
 			goto free_tx_stats;
 		}
 	}
 
-	ret = ath12k_dp_peer_setup(ar, arvif->vdev_id, sta->addr);
+	ret = ath12k_dp_peer_setup(ar, arvif->vdev_id, arsta->addr);
 	if (ret) {
 		ath12k_warn(ab, "failed to setup dp for peer %pM on vdev %i (%d)\n",
-			    sta->addr, arvif->vdev_id, ret);
+			    arsta->addr, arvif->vdev_id, ret);
 		goto free_tx_stats;
 	}
 
@@ -5793,6 +5994,9 @@ static int ath12k_mac_station_add(struct
 		}
 	}
 
+	INIT_WORK(&arsta->update_wk, ath12k_sta_rc_update_wk);
+
+	ahsta->ahvif = ahvif;
 	return 0;
 
 free_tx_stats:
@@ -5801,7 +6005,7 @@ free_tx_stats:
 	kfree(arsta->wbm_tx_stats);
 	arsta->wbm_tx_stats = NULL;
 free_peer:
-	ath12k_peer_delete(ar, arvif->vdev_id, sta->addr);
+	ath12k_peer_delete(ar, arvif->vdev_id, arsta->addr);
 free_rx_stats:
 	kfree(arsta->rx_stats);
 	arsta->rx_stats = NULL;
@@ -5811,190 +6015,244 @@ exit:
 	return ret;
 }
 
-static int ath12k_mac_op_sta_state(struct ieee80211_hw *hw,
-				   struct ieee80211_vif *vif,
-				   struct ieee80211_sta *sta,
-				   enum ieee80211_sta_state old_state,
-				   enum ieee80211_sta_state new_state)
+static u16 ath12k_mac_alloc_ml_peer_id(struct ath12k_hw *ah)
+{
+
+	u16 ml_peer_id;
+
+	lockdep_assert_held(&ah->conf_mutex);
+
+	for (ml_peer_id = 0; ml_peer_id < ATH12K_MAX_MLO_PEERS; ml_peer_id++) {
+		if (test_bit(ml_peer_id, ah->free_ml_peer_id_map))
+			continue;
+
+		set_bit(ml_peer_id, ah->free_ml_peer_id_map);
+		break;
+	}
+
+	if (ml_peer_id == ATH12K_MAX_MLO_PEERS)
+		ml_peer_id = ATH12K_MLO_PEER_ID_INVALID;
+
+	return ml_peer_id;
+}
+
+static int ath12k_mac_assign_link_sta(struct ath12k_hw *ah,
+				       struct ath12k_sta *ahsta,
+				       struct ath12k_link_sta *arsta,
+				       struct ath12k_vif *ahvif,
+				       u8 link_id)
+{
+	struct ieee80211_link_sta *link_sta;
+	struct ieee80211_sta *sta;
+
+	lockdep_assert_held(&ah->conf_mutex);
+
+	if (!arsta || link_id > IEEE80211_MLD_MAX_NUM_LINKS)
+		return -EINVAL;
+
+	if (WARN_ON(!ahvif->link[link_id]))
+		return -EINVAL;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	memset(arsta, 0, sizeof(*arsta));
+
+	rcu_read_lock();
+	link_sta = rcu_dereference(sta->link[link_id]);
+	if (!link_sta) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
+	ether_addr_copy(arsta->addr, link_sta->addr);
+	rcu_read_unlock();
+
+	/* logical index of the link sta in order of creation */
+	arsta->link_idx = ahsta->num_peer++;
+
+	ahsta->link[link_id] = arsta;
+	ahsta->links_map |= BIT(link_id);
+	arsta->arvif = ahvif->link[link_id];
+	arsta->ahsta = ahsta;
+	arsta->link_id = link_id;
+
+	return 0;
+}
+
+static int ath12k_mac_unassign_link_sta(struct ath12k_hw *ah,
+				       struct ath12k_sta *ahsta,
+				       u8 link_id)
+{
+	lockdep_assert_held(&ah->conf_mutex);
+
+	if (link_id > IEEE80211_MLD_MAX_NUM_LINKS)
+		return -EINVAL;
+
+	ahsta->link[link_id] = NULL;
+	ahsta->links_map &= ~BIT(link_id);
+
+	return 0;
+}
+
+static struct ath12k_link_sta *
+ath12k_mac_alloc_assign_link_sta(struct ath12k_hw *ah, struct ath12k_sta *ahsta,
+				 struct ath12k_vif *ahvif, u8 link_id)
 {
-	struct ath12k_hw *ah = hw->priv;
-	struct ath12k *ar;
-	struct ath12k_link_vif *arvif;
 	struct ath12k_link_sta *arsta;
-	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
-	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
-	struct ath12k_peer *peer;
-	int ret = 0;
 
-	/* TODO handle ML link vif/sta separately */
-	if (vif->valid_links)
-		return 0;
+	lockdep_assert_held(&ah->conf_mutex);
 
-	mutex_lock(&ah->conf_mutex);
+	if (link_id > IEEE80211_MLD_MAX_NUM_LINKS)
+		return NULL;
+
+	if (ahsta->link[link_id]) {
+		WARN_ON(1);
+		return NULL;
+	}
+
+	arsta = kzalloc(sizeof(*arsta), GFP_KERNEL);
+	if (!arsta)
+		return NULL;
+
+	if (ath12k_mac_assign_link_sta(ah, ahsta, arsta, ahvif, link_id)) {
+		kfree(arsta);
+		return NULL;
+	}
+
+	return arsta;
+}
+
+static int ath12k_mac_free_unassign_link_sta(struct ath12k_hw *ah,
+					     struct ath12k_sta *ahsta,
+					     u8 link_id)
+{
+	struct ath12k_link_sta *arsta;
+
+	lockdep_assert_held(&ah->conf_mutex);
+
+	if (link_id > IEEE80211_MLD_MAX_NUM_LINKS)
+		return -EINVAL;
+
+	arsta = ahsta->link[link_id];
+
+	WARN_ON(arsta == NULL);
+
+	ath12k_mac_unassign_link_sta(ah, ahsta, link_id);
+
+	if (arsta != &ahsta->deflink)
+		kfree(arsta);
+
+	return 0;
+}
+
+static void ath12k_mac_ml_station_remove(struct ath12k_vif *ahvif,
+				        struct ath12k_sta *ahsta)
+{
+	struct ieee80211_sta *sta;
+	struct ath12k_hw *ah = ahvif->ah;
+ 	struct ath12k_link_vif *arvif;
+ 	struct ath12k_link_sta *arsta;
+	struct ath12k *ar;
+	u8 link_id;
+
+	lockdep_assert_held(&ah->conf_mutex);
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	ath12k_ml_peer_delete(ahvif, ahsta);
+
+	/* validate link station removal and clear arsta links */
+	for_each_set_bit(link_id, &sta->valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arvif = ahvif->link[link_id];
+		arsta = ahsta->link[link_id];
+
+		if (WARN_ON(!arvif || !arsta))
+			continue;
+
+		ar = arvif->ar;
+
+		mutex_lock(&ar->conf_mutex);
+		ath12k_mac_station_post_remove(ar, arvif, arsta);
+		mutex_unlock(&ar->conf_mutex);
+
+		ath12k_mac_free_unassign_link_sta(ah, ahsta, link_id);
+	}
+	clear_bit(ahsta->ml_peer_id, ah->free_ml_peer_id_map);
+	ahsta->ml_peer_id = ATH12K_MLO_PEER_ID_INVALID;
+}
+
+static int ath12k_mac_handle_link_sta_state(struct ieee80211_hw *hw,
+					    struct ath12k_link_vif *arvif,
+					    struct ath12k_link_sta *arsta,
+					    enum ieee80211_sta_state old_state,
+					    enum ieee80211_sta_state new_state)
+{
+	struct ath12k *ar = arvif->ar;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+	int ret = 0;
 
-	arvif = &ahvif->deflink;
-	arsta = &ahsta->deflink;
-	ar = arvif->ar;
 	if (!ar) {
 		ath12k_err(NULL, "unable to determine device to set sta state\n");
-		mutex_unlock(&ah->conf_mutex);
 		return -EINVAL;
 	}
 
-	/* cancel must be done outside the mutex to avoid deadlock */
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	/* cancel must be done outside the ar mutex to avoid deadlock */
 	if ((old_state == IEEE80211_STA_NONE &&
 	     new_state == IEEE80211_STA_NOTEXIST)) {
+		/* ML sta needs separate handling */
+		if (sta->mlo)
+			return 0;
 		cancel_work_sync(&arsta->update_wk);
-		cancel_work_sync(&ahsta->set_4addr_wk);
-		ahsta->link[0] = NULL;
-		ahsta->links_map = 0;
 	}
 
 	mutex_lock(&ar->conf_mutex);
 
 	if (old_state == IEEE80211_STA_NOTEXIST &&
 	    new_state == IEEE80211_STA_NONE) {
-		ahsta->link[0] = arsta;
-		ahsta->links_map = 1;
-		memset(arsta, 0, sizeof(*arsta));
-		arsta->arvif = arvif;
-		INIT_WORK(&arsta->update_wk, ath12k_sta_rc_update_wk);
-		INIT_WORK(&ahsta->set_4addr_wk, ath12k_sta_set_4addr_wk);
 
 		ret = ath12k_mac_station_add(ar, arvif, arsta);
 		if (ret)
 			ath12k_warn(ar->ab, "Failed to add station: %pM for VDEV: %d\n",
-				    sta->addr, arvif->vdev_id);
+				    arsta->addr, arvif->vdev_id);
 	} else if ((old_state == IEEE80211_STA_NONE &&
 		    new_state == IEEE80211_STA_NOTEXIST)) {
-		ath12k_dp_peer_cleanup(ar, arvif->vdev_id, sta->addr);
-
-		ret = ath12k_peer_delete(ar, arvif->vdev_id, sta->addr);
+		ret = ath12k_mac_station_remove(ar, arvif, arsta);
 		if (ret)
-			ath12k_warn(ar->ab, "Failed to delete peer: %pM for VDEV: %d num_peers : %d\n",
-				    sta->addr, arvif->vdev_id, ar->num_peers);
-		else
-			ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "Removed peer: %pM for VDEV: %d num_peers : %d\n",
-				   sta->addr, arvif->vdev_id, ar->num_peers);
-
-		ath12k_mac_dec_num_stations(arvif, arsta);
-		spin_lock_bh(&ar->ab->base_lock);
-		peer = ath12k_peer_find(ar->ab, arvif->vdev_id, sta->addr);
-		if (peer && peer->sta == sta) {
-			ath12k_warn(ar->ab, "Found peer entry %pM n vdev %d after it was supposedly removed"
-				    " num_peers : %d\n", vif->addr, arvif->vdev_id, ar->num_peers);
-			peer->sta = NULL;
-			list_del(&peer->list);
-			kfree(peer);
-			ar->num_peers--;
-		}
-		spin_unlock_bh(&ar->ab->base_lock);
-
-		kfree(arsta->tx_stats);
-		arsta->tx_stats = NULL;
-		kfree(arsta->wbm_tx_stats);
-		arsta->wbm_tx_stats = NULL;
-
-		kfree(arsta->rx_stats);
-		arsta->rx_stats = NULL;
-		ath12k_mac_ap_ps_recalc(ar);
+			ath12k_warn(ar->ab, "Failed to remove station: %pM for VDEV: %d\n",
+				    arsta->addr, arvif->vdev_id);
+		if (sta->valid_links)
+			ath12k_mac_free_unassign_link_sta(arvif->ahvif->ah,
+							  arsta->ahsta, arsta->link_id);
 	} else if (old_state == IEEE80211_STA_AUTH &&
 		   new_state == IEEE80211_STA_ASSOC &&
 		   (vif->type == NL80211_IFTYPE_AP ||
 		    vif->type == NL80211_IFTYPE_MESH_POINT ||
 		    vif->type == NL80211_IFTYPE_ADHOC)) {
-		ret = ath12k_station_assoc(ar, vif, sta, false, 0);
+		ret = ath12k_station_assoc(ar, arvif, arsta, false);
 		if (ret)
 			ath12k_warn(ar->ab, "Failed to associate station: %pM\n",
-				    sta->addr);
-
-		spin_lock_bh(&ar->data_lock);
-
-		/* Set arsta bw and prev bw */
-		arsta->bw = sta->deflink.bandwidth;
-		arsta->bw_prev = sta->deflink.bandwidth;
-
-		spin_unlock_bh(&ar->data_lock);
+				    arsta->addr);
 	} else if (old_state == IEEE80211_STA_ASSOC &&
 		   new_state == IEEE80211_STA_AUTHORIZED) {
-		spin_lock_bh(&ar->ab->base_lock);
-
-		peer = ath12k_peer_find(ar->ab, arvif->vdev_id, sta->addr);
-		if (peer)
-			peer->is_authorized = true;
-
-		spin_unlock_bh(&ar->ab->base_lock);
-
-		if (vif->type == NL80211_IFTYPE_STATION && arvif->is_up) {
-			ret = ath12k_wmi_set_peer_param(ar, sta->addr,
-							arvif->vdev_id,
-							WMI_PEER_AUTHORIZE,
-							1);
-			if (ret)
-				ath12k_warn(ar->ab, "Unable to authorize peer %pM vdev %d: %d\n",
-					    sta->addr, arvif->vdev_id, ret);
-		}
+		ret = ath12k_station_authorize(ar, arvif, arsta);
 	} else if (old_state == IEEE80211_STA_AUTHORIZED &&
 		   new_state == IEEE80211_STA_ASSOC) {
-		spin_lock_bh(&ar->ab->base_lock);
-
-		peer = ath12k_peer_find(ar->ab, arvif->vdev_id, sta->addr);
-		if (peer)
-			peer->is_authorized = false;
-
-		spin_unlock_bh(&ar->ab->base_lock);
-	} else if (old_state == IEEE80211_STA_ASSOC &&
-		   new_state == IEEE80211_STA_AUTHORIZED) {
-		spin_lock_bh(&ar->ab->base_lock);
-
-		peer = ath12k_peer_find(ar->ab, arvif->vdev_id, sta->addr);
-		if (peer)
-			peer->is_authorized = true;
-
-		spin_unlock_bh(&ar->ab->base_lock);
-
-		if (vif->type == NL80211_IFTYPE_STATION && arvif->is_up) {
-			ret = ath12k_wmi_set_peer_param(ar, sta->addr,
-							arvif->vdev_id,
-							WMI_PEER_AUTHORIZE,
-							1);
-			if (ret)
-				ath12k_warn(ar->ab, "Unable to authorize peer %pM vdev %d: %d\n",
-					    sta->addr, arvif->vdev_id, ret);
-		}
-	} else if (old_state == IEEE80211_STA_AUTHORIZED &&
-		   new_state == IEEE80211_STA_ASSOC) {
-		spin_lock_bh(&ar->ab->base_lock);
-
-		peer = ath12k_peer_find(ar->ab, arvif->vdev_id, sta->addr);
-		if (peer)
-			peer->is_authorized = false;
-
-		spin_unlock_bh(&ar->ab->base_lock);
-
-		/* Driver should clear the peer keys during mac80211's ref ptr
-		 * gets cleared in __sta_info_destroy_part2 (trans from
-		 * IEEE80211_STA_AUTHORIZED to IEEE80211_STA_ASSOC)
-		 */
-		ret = ath12k_clear_peer_keys(arvif, sta->addr);
-		if (ret) {
-			ath12k_warn(ar->ab, "failed to clear all peer keys for vdev %i: %d\n",
-					arvif->vdev_id, ret);
-			return ret;
-		}
+		ath12k_station_unauthorize(ar, arvif, arsta);
 	} else if (old_state == IEEE80211_STA_ASSOC &&
 		   new_state == IEEE80211_STA_AUTH &&
 		   (vif->type == NL80211_IFTYPE_AP ||
 		    vif->type == NL80211_IFTYPE_MESH_POINT ||
 		    vif->type == NL80211_IFTYPE_ADHOC)) {
-		ret = ath12k_station_disassoc(ar, vif, sta, 0);
+		ret = ath12k_station_disassoc(ar, arvif, arsta);
 		if (ret)
 			ath12k_warn(ar->ab, "Failed to disassociate station: %pM\n",
-				    sta->addr);
+				    arsta->addr);
 	}
 
 	mutex_unlock(&ar->conf_mutex);
-	mutex_unlock(&ah->conf_mutex);
 	return ret;
 }
 
@@ -6005,7 +6263,9 @@ static int ath12k_mac_op_sta_set_txpwr(s
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
 	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
 	struct ath12k_link_vif *arvif;
+	struct ath12k_link_sta *arsta;
 	int ret = 0;
 	s16 txpwr;
 	/* TODO use link id from op after support is available */
@@ -6015,6 +6275,7 @@ static int ath12k_mac_op_sta_set_txpwr(s
 
 	/* TODO get arvif based on link id */
 	arvif = ahvif->link[link_id];
+	arsta = ahsta->link[link_id];
 
 	if (!arvif) {
 		ath12k_err(NULL, "unable to determine device to set sta txpwr\n");
@@ -6046,7 +6307,7 @@ static int ath12k_mac_op_sta_set_txpwr(s
 
 	mutex_lock(&ar->conf_mutex);
 
-	ret = ath12k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,
+	ret = ath12k_wmi_set_peer_param(ar, arsta->addr, arvif->vdev_id,
 					WMI_PEER_USE_FIXED_PWR, txpwr);
 	if (ret) {
 		ath12k_warn(ar->ab, "failed to set tx power for station ret: %d\n",
@@ -6061,6 +6322,175 @@ out:
 	return ret;
 }
 
+static int ath12k_mac_op_sta_state(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   struct ieee80211_sta *sta,
+				   enum ieee80211_sta_state old_state,
+				   enum ieee80211_sta_state new_state)
+{
+	struct ath12k_hw *ah = hw->priv;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_link_sta *arsta;
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	int ret = 0;
+	u8 link_id = 0;
+
+	mutex_lock(&ah->conf_mutex);
+
+	if (vif->valid_links && sta->valid_links) {
+		if (!sta->mlo)
+			WARN_ON(hweight16(sta->valid_links) != 1);
+		link_id = ffs(sta->valid_links) - 1;
+	}
+
+	if ((old_state == IEEE80211_STA_NONE &&
+	     new_state == IEEE80211_STA_NOTEXIST)) {
+		cancel_work_sync(&ahsta->set_4addr_wk);
+	}
+
+	if ((old_state == IEEE80211_STA_NOTEXIST &&
+	     new_state == IEEE80211_STA_NONE)) {
+		INIT_WORK(&ahsta->set_4addr_wk, ath12k_sta_set_4addr_wk);
+		if (!sta->mlo) {
+			ret = ath12k_mac_assign_link_sta(ah, ahsta, &ahsta->deflink,
+							   ahvif, link_id);
+			if (ret)
+				return ret;
+		}
+	}
+
+	if (!sta->mlo) {
+		arvif = ahvif->link[link_id];
+		arsta = ahsta->link[link_id];
+
+		if (WARN_ON(arvif == NULL || arsta == NULL))
+			return -EINVAL;
+
+		ret = ath12k_mac_handle_link_sta_state(hw, arvif, arsta,
+						       old_state, new_state);
+		mutex_unlock(&ah->conf_mutex);
+		return ret;
+	}
+
+	/* Support only AP for now */
+	if (vif->type != NL80211_IFTYPE_AP)
+		return -EINVAL;
+
+	if (!sta->valid_links)
+		WARN_ON(1);
+
+	/* assign default link to the first link sta */
+	if (!ahsta->links_map && hweight16(sta->valid_links) == 1 &&
+	    new_state == IEEE80211_STA_NONE && old_state == IEEE80211_STA_NOTEXIST) {
+		ahsta->ml_peer_id = ath12k_mac_alloc_ml_peer_id(ah);
+
+		if (ahsta->ml_peer_id == ATH12K_MLO_PEER_ID_INVALID) {
+			ath12k_err(NULL, "unable to allocate ml peer id for sta %pM", sta->addr);
+			mutex_unlock(&ah->conf_mutex);
+			return -ENOSPC;
+		}
+
+		ath12k_mac_assign_link_sta(ah, ahsta, &ahsta->deflink,
+					   ahvif, link_id);
+
+		ahsta->deflink.is_assoc_link = true;
+		ahsta->assoc_link_id = link_id;
+	}
+
+	if (new_state == IEEE80211_STA_NOTEXIST && old_state == IEEE80211_STA_NONE) {
+		ath12k_mac_ml_station_remove(ahvif, ahsta);
+		goto exit;
+ 	}
+
+	for_each_set_bit(link_id, &sta->valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arvif = ahvif->link[link_id];
+		arsta = ahsta->link[link_id];
+
+		/* some assumptions went wrong! */
+		if (WARN_ON(!arvif || !arsta))
+			continue;
+
+		ret = ath12k_mac_handle_link_sta_state(hw, arvif, arsta,
+						       old_state, new_state);
+		if (ret) {
+			ath12k_err(NULL, "unable to move link sta %d of sta %pM from state %d to %d",
+				   link_id, arsta->addr, old_state, new_state);
+			mutex_unlock(&ah->conf_mutex);
+			return ret;
+		}
+	}
+
+	if (old_state == IEEE80211_STA_AUTH &&  new_state == IEEE80211_STA_ASSOC) {
+		/* TODO sync wait for ML peer map success, else clear ml peer info on
+		 * all partners? TBD on testing
+		 */
+	}
+
+exit:
+	mutex_unlock(&ah->conf_mutex);
+
+	return ret;
+}
+
+static int ath12k_mac_op_change_sta_links(struct ieee80211_hw *hw,
+					    struct ieee80211_vif *vif,
+					    struct ieee80211_sta *sta,
+					    u16 old_links, u16 new_links)
+{
+	struct ath12k_hw *ah = hw->priv;
+	struct ath12k *ar;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_link_sta *arsta;
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	u8 link_id;
+	int ret;
+
+	if (!sta->valid_links)
+		return -EINVAL;
+
+	mutex_lock(&ah->conf_mutex);
+
+	if (ahsta->ml_peer_id == ATH12K_MLO_PEER_ID_INVALID) {
+		ath12k_err(NULL, "unable to add link for ml sta %pM", sta->addr);
+		mutex_unlock(&ah->conf_mutex);
+		return -EINVAL;
+	}
+
+	/* this op is expected only after initial sta insertion with default link */
+	WARN_ON(ahsta->links_map == 0);
+
+	for_each_set_bit(link_id, &new_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		if (ahsta->links_map & BIT(link_id))
+			continue;
+
+		arvif = ahvif->link[link_id];
+		arsta = ath12k_mac_alloc_assign_link_sta(ah, ahsta, ahvif, link_id);
+
+		if (!arvif || !arsta) {
+			ath12k_err(NULL, "Failed to alloc/assign link sta");
+			continue;
+		}
+
+		ar = arvif->ar;
+
+		mutex_lock(&ar->conf_mutex);
+		ret = ath12k_mac_station_add(ar, arvif, arsta);
+		if (ret)
+			ath12k_warn(ar->ab, "Failed to add station: %pM for VDEV: %d\n",
+				    arsta->addr, arvif->vdev_id);
+		mutex_unlock(&ar->conf_mutex);
+	}
+
+	/* FW doesnt support removal of one of link stas. All sta would be removed during ML STA
+	 * delete in sta_state(), hence link sta removal is not handled here.
+	 */
+	mutex_unlock(&ah->conf_mutex);
+
+	return 0;
+}
+
 static void ath12k_mac_op_sta_set_4addr(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif,
 					struct ieee80211_sta *sta, bool enabled)
@@ -6107,11 +6537,11 @@ static void ath12k_mac_op_sta_rc_update(
 
 	spin_lock_bh(&ar->ab->base_lock);
 
-	peer = ath12k_peer_find(ar->ab, arvif->vdev_id, sta->addr);
+	peer = ath12k_peer_find(ar->ab, arvif->vdev_id, arsta->addr);
 	if (!peer) {
 		spin_unlock_bh(&ar->ab->base_lock);
 		ath12k_warn(ar->ab, "mac sta rc update failed to find peer %pM on vdev %i\n",
-			    sta->addr, arvif->vdev_id);
+			   arsta->addr, arvif->vdev_id);
 		return;
 	}
 
@@ -6119,7 +6549,7 @@ static void ath12k_mac_op_sta_rc_update(
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		   "mac sta rc update for %pM changed %08x bw %d nss %d smps %d\n",
-		   sta->addr, changed, sta->deflink.bandwidth, sta->deflink.rx_nss,
+		   arsta->addr, changed, sta->deflink.bandwidth, sta->deflink.rx_nss,
 		   sta->smps_mode);
 
 	spin_lock_bh(&ar->data_lock);
@@ -6145,7 +6575,7 @@ static void ath12k_mac_op_sta_rc_update(
 			break;
 		default:
 			ath12k_warn(ar->ab, "Invalid bandwidth %d in rc update for %pM\n",
-				    sta->deflink.bandwidth, sta->addr);
+				    sta->deflink.bandwidth, arsta->addr);
 			bw = WMI_PEER_CHWIDTH_20MHZ;
 			break;
 		}
@@ -6173,7 +6603,7 @@ static void ath12k_mac_op_sta_rc_update(
 			break;
 		default:
 			ath12k_warn(ar->ab, "Invalid smps %d in sta rc update for %pM\n",
-				    sta->smps_mode, sta->addr);
+				    sta->smps_mode, arsta->addr);
 			smps = WMI_PEER_SMPS_PS_NONE;
 			break;
 		}
@@ -11092,6 +11522,7 @@ static void ath12k_mac_set_bitrate_mask_
 static void ath12k_mac_disable_peer_fixed_rate(void *data,
 					       struct ieee80211_sta *sta)
 {
+	struct ath12k_link_sta *arsta;
 	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
 	struct ath12k_link_vif *arvif = data;
 	struct ath12k *ar;
@@ -11105,17 +11536,19 @@ static void ath12k_mac_disable_peer_fixe
 	if (!(BIT(link_id) & ahsta->links_map))
 		return;
 
+	arsta = ahsta->link[link_id];
+
 	ar = arvif->ar;
 
 	/* TODO move to sta->link addr */
-	ret = ath12k_wmi_set_peer_param(ar, sta->addr,
+	ret = ath12k_wmi_set_peer_param(ar, arsta->addr,
 					arvif->vdev_id,
 					WMI_PEER_PARAM_FIXED_RATE,
 					WMI_FIXED_RATE_NONE);
 	if (ret)
 		ath12k_warn(ar->ab,
 			    "failed to disable peer fixed rate for STA %pM ret %d\n",
-			    sta->addr, ret);
+			    arsta->addr, ret);
 }
 
 static bool
@@ -11721,6 +12154,7 @@ static const struct ieee80211_ops ath12k
 	.get_survey			= ath12k_mac_op_get_survey,
 	.flush				= ath12k_mac_op_flush,
 	.sta_statistics			= ath12k_mac_op_sta_statistics,
+	.change_sta_links		= ath12k_mac_op_change_sta_links,
 	CFG80211_TESTMODE_CMD(ath12k_tm_cmd)
 #ifdef CPTCFG_ATH12K_DEBUGFS
 	.sta_add_debugfs		= ath12k_debugfs_sta_op_add,
--- a/drivers/net/wireless/ath/ath12k/peer.c
+++ b/drivers/net/wireless/ath/ath12k/peer.c
@@ -8,6 +8,10 @@
 #include "peer.h"
 #include "debug.h"
 
+/* TODO extend peer search apis for ml addr either combined or separately
+ * based on dp needs
+ */
+
 struct ath12k_peer *ath12k_peer_find(struct ath12k_base *ab, int vdev_id,
 				     const u8 *addr)
 {
@@ -63,6 +67,20 @@ struct ath12k_peer *ath12k_peer_find_by_
 	return NULL;
 }
 
+static struct ath12k_peer *ath12k_peer_find_by_ml_id(struct ath12k_base *ab,
+						     int ml_peer_id)
+{
+	struct ath12k_peer *peer;
+
+	lockdep_assert_held(&ab->base_lock);
+
+	list_for_each_entry(peer, &ab->peers, list)
+		if (ml_peer_id == peer->ml_peer_id)
+			return peer;
+
+	return NULL;
+}
+
 struct ath12k_peer *ath12k_peer_find_by_id(struct ath12k_base *ab,
 					   int peer_id)
 {
@@ -70,6 +88,9 @@ struct ath12k_peer *ath12k_peer_find_by_
 
 	lockdep_assert_held(&ab->base_lock);
 
+	if (peer_id & ATH12K_ML_PEER_ID_VALID)
+		return ath12k_peer_find_by_ml_id(ab, peer_id);
+
 	list_for_each_entry(peer, &ab->peers, list)
 		if (peer_id == peer->peer_id)
 			return peer;
@@ -160,6 +181,60 @@ exit:
 	spin_unlock_bh(&ab->base_lock);
 }
 
+void ath12k_peer_mlo_map_event(struct ath12k_base *ab, struct sk_buff *skb)
+{
+	struct ath11k_htt_mlo_peer_map_msg *msg;
+	u16 ml_peer_id;
+	struct ath12k_peer *peer;
+	u16 mld_mac_h16;
+	u8 mld_addr[ETH_ALEN];
+
+	msg = (struct ath11k_htt_mlo_peer_map_msg *)skb->data;
+
+	ml_peer_id = FIELD_GET(ATH12K_HTT_MLO_PEER_MAP_INFO0_PEER_ID, msg->info0);
+
+	ml_peer_id |= ATH12K_ML_PEER_ID_VALID;
+
+	spin_lock_bh(&ab->base_lock);
+	peer = ath12k_peer_find_by_id(ab, ml_peer_id);
+
+	/* TODO a sync wait to check ml peer map success or delete
+	 * ml peer info in all link peers and make peer assoc failure
+	 * TBA after testing basic changes
+	 */
+	if (!peer) {
+		ath12k_warn(ab, "peer corresponding to ml peer id %d not found", ml_peer_id);
+		spin_unlock_bh(&ab->base_lock);
+		return;
+	}
+	mld_mac_h16 = FIELD_GET(ATH12K_HTT_MLO_PEER_MAP_MAC_ADDR_H16,
+				msg->mac_addr.mac_addr_h16);
+	ath12k_dp_get_mac_addr(msg->mac_addr.mac_addr_l32, mld_mac_h16, mld_addr);
+
+	WARN_ON(memcmp(mld_addr, peer->ml_addr, ETH_ALEN));
+
+	spin_unlock_bh(&ab->base_lock);
+
+	ath12k_dbg(ab, ATH12K_DBG_DP_HTT, "htt MLO peer map peer %pM id %d\n",
+		   mld_addr, ml_peer_id);
+
+	/* TODO rx queue setup for the ML peer */
+}
+
+void ath12k_peer_mlo_unmap_event(struct ath12k_base *ab, struct sk_buff *skb)
+{
+	struct ath11k_htt_mlo_peer_unmap_msg *msg;
+	u16 ml_peer_id;
+
+	msg = (struct ath11k_htt_mlo_peer_unmap_msg *)skb->data;
+
+	ml_peer_id = FIELD_GET(ATH12K_HTT_MLO_PEER_UNMAP_PEER_ID, msg->info0);
+
+	ml_peer_id |= ATH12K_ML_PEER_ID_VALID;
+
+	ath12k_dbg(ab, ATH12K_DBG_DP_HTT, "htt MLO peer unmap peer ml id %d\n", ml_peer_id);
+}
+
 static int ath12k_wait_for_peer_common(struct ath12k_base *ab, int vdev_id,
 				       const u8 *addr, bool expect_mapped)
 {
@@ -233,7 +308,7 @@ int ath12k_wait_for_peer_delete_done(str
 	return 0;
 }
 
-int ath12k_peer_delete(struct ath12k *ar, u32 vdev_id, u8 *addr)
+static int ath12k_peer_delete_send(struct ath12k *ar, u32 vdev_id, u8 *addr)
 {
 	int ret;
 
@@ -249,6 +324,19 @@ int ath12k_peer_delete(struct ath12k *ar
 		return ret;
 	}
 
+	return 0;
+}
+
+int ath12k_peer_delete(struct ath12k *ar, u32 vdev_id, u8 *addr)
+{
+	int ret;
+
+	lockdep_assert_held(&ar->conf_mutex);
+
+	ret = ath12k_peer_delete_send(ar, vdev_id, addr);
+	if (ret)
+		return ret;
+
 	ret = ath12k_wait_for_peer_delete_done(ar, vdev_id, addr);
 	if (ret)
 		return ret;
@@ -258,6 +346,76 @@ int ath12k_peer_delete(struct ath12k *ar
 	return 0;
 }
 
+int ath12k_ml_peer_delete(struct ath12k_vif *ahvif, struct ath12k_sta *ahsta)
+{
+	struct ath12k_link_vif *arvif;
+	struct ath12k_link_sta *arsta;
+	struct ieee80211_sta *sta;
+	struct ath12k *ar;
+	int ret, err_ret = 0;
+	u8 link_id = 0;
+	struct ath12k_hw *ah = ahvif->ah;
+
+	lockdep_assert_held(&ah->conf_mutex);
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	if (!sta->mlo)
+		return -EINVAL;
+
+	/* FW expects delete of all link peers at once before waiting for reception
+	 * of peer unmap or delete responses
+	 */
+	for_each_set_bit(link_id, &sta->valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arvif = ahvif->link[link_id];
+		arsta = ahsta->link[link_id];
+
+		if (WARN_ON(!arvif || !arsta))
+			continue;
+
+		ar = arvif->ar;
+
+		cancel_work_sync(&arsta->update_wk);
+
+		mutex_lock(&ar->conf_mutex);
+		ath12k_dp_peer_cleanup(ar, arvif->vdev_id, arsta->addr);
+
+		ret = ath12k_peer_delete_send(ar, arvif->vdev_id, arsta->addr);
+		if (ret) {
+			mutex_unlock(&ar->conf_mutex);
+			ath12k_warn(ar->ab,
+				    "failed to delete peer vdev_id %d addr %pM ret %d\n",
+				    arvif->vdev_id, arsta->addr, ret);
+			err_ret = ret;
+			continue;
+		}
+		mutex_unlock(&ar->conf_mutex);
+	}
+
+	/* Ensure all link peers are deleted and unmapped */
+	for_each_set_bit(link_id, &sta->valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arvif = ahvif->link[link_id];
+		arsta = ahsta->link[link_id];
+
+		if (WARN_ON(!arvif || !arsta))
+			continue;
+
+		ar = arvif->ar;
+
+		mutex_lock(&ar->conf_mutex);
+		ret = ath12k_wait_for_peer_delete_done(ar, arvif->vdev_id, arsta->addr);
+		if (ret) {
+			err_ret = ret;
+			mutex_unlock(&ar->conf_mutex);
+			continue;
+		}
+		ar->num_peers--;
+		mutex_unlock(&ar->conf_mutex);
+	}
+
+	return err_ret;
+}
+
 static int ath12k_wait_for_peer_created(struct ath12k *ar, int vdev_id, const u8 *addr)
 {
 	return ath12k_wait_for_peer_common(ar->ab, vdev_id, addr, true);
@@ -342,15 +500,27 @@ int ath12k_peer_create(struct ath12k *ar
 	peer->vif = vif;
 
 	if (sta) {
-		/* TODO handling for ML PEER */
 		ahsta = (struct ath12k_sta *)sta->drv_priv;
 		arsta = ahsta->link[link_id];
 		arsta->tcl_metadata |= FIELD_PREP(HTT_TCL_META_DATA_TYPE, 0) |
 				       FIELD_PREP(HTT_TCL_META_DATA_PEER_ID,
 						  peer->peer_id);
+		peer->link_id = arsta->link_id;
 
 		/* set HTT extension valid bit to 0 by default */
 		arsta->tcl_metadata &= ~HTT_TCL_META_DATA_VALID_HTT;
+
+		/* Fill ML info into created peer */
+		if (sta->mlo) {
+			peer->ml_peer_id = ahsta->ml_peer_id | ATH12K_ML_PEER_ID_VALID;
+			/* the assoc link is considered primary for now */
+			peer->primary_link = arsta->is_assoc_link;
+			ether_addr_copy(peer->ml_addr, sta->addr);
+		} else {
+			peer->ml_peer_id = ATH12K_MLO_PEER_ID_INVALID;
+			peer->primary_link = true;
+		}
+
 	}
 
 
--- a/drivers/net/wireless/ath/ath12k/peer.h
+++ b/drivers/net/wireless/ath/ath12k/peer.h
@@ -20,6 +20,12 @@ struct ppdu_user_delayba {
 	u32 resp_rate_flags;
 } __packed;
 
+/* Note: The ml info is embedded into the link peer
+ * objects, based on hot dp requirements to fetch link peer
+ * or ml peer based on ml peer id and ml address separate
+ * ml peer list maintained in ah can be done. For now it
+ * doesnt seem to be needed
+ */
 struct ath12k_peer {
 	struct list_head list;
 	struct ieee80211_sta *sta;
@@ -33,6 +39,12 @@ struct ath12k_peer {
 
 	/* protected by ab->data_lock */
 	struct ieee80211_key_conf *keys[WMI_MAX_KEY_INDEX + 1];
+
+	/* rx tid queue is setup once for primary link peer
+	 * in case of ML and cloned into partner peer data
+	 * but would be accessed (only if required)and safely
+	 * by ensuring primary parner is still valid
+	 */
 	struct ath12k_dp_rx_tid rx_tid[IEEE80211_NUM_TIDS + 1];
 
 	/* Info used in MMIC verification of
@@ -51,6 +63,19 @@ struct ath12k_peer {
 	 * a peer has setup its datapath or not
 	 */
 	bool dp_setup_done;
+
+	u16 ml_peer_id;
+	/* TODO remove or fill below these info if required/not required during dp change */
+	/* for reference to ath12k_link_sta */
+	u8 link_id;
+
+	/* To ensure only certain work related to dp is done once */
+	bool primary_link;
+
+	/* any other ML info common for all partners can be added
+	 * here and would be same for all partner peers
+	 */
+	u8 ml_addr[ETH_ALEN];
 };
 
 void ath12k_peer_unmap_event(struct ath12k_base *ab, u16 peer_id);
@@ -63,6 +88,7 @@ struct ath12k_peer *ath12k_peer_find_by_
 struct ath12k_peer *ath12k_peer_find_by_id(struct ath12k_base *ab, int peer_id);
 void ath12k_peer_cleanup(struct ath12k *ar, u32 vdev_id);
 int ath12k_peer_delete(struct ath12k *ar, u32 vdev_id, u8 *addr);
+int ath12k_ml_peer_delete(struct ath12k_vif *ahvif, struct ath12k_sta *ahsta);
 int ath12k_peer_create(struct ath12k *ar, struct ath12k_link_vif *arvif,
 		       struct ieee80211_sta *sta, struct peer_create_params *param);
 int ath12k_wait_for_peer_delete_done(struct ath12k *ar, u32 vdev_id,
@@ -70,5 +96,7 @@ int ath12k_wait_for_peer_delete_done(str
 struct ath12k_peer *ath12k_peer_find_by_vdev_id(struct ath12k_base *ab,
 						int vdev_id);
 struct ath12k_peer *ath12k_peer_find_by_ast(struct ath12k_base *ab, int ast_hash);
+void ath12k_peer_mlo_map_event(struct ath12k_base *ab, struct sk_buff *skb);
+void ath12k_peer_mlo_unmap_event(struct ath12k_base *ab, struct sk_buff *skb);
 
 #endif /* _PEER_H_ */
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -1183,9 +1183,14 @@ int ath12k_wmi_send_peer_create_cmd(stru
 	struct ath12k_pdev_wmi *wmi = ar->wmi;
 	struct wmi_peer_create_cmd *cmd;
 	struct sk_buff *skb;
-	int ret;
+	int ret, len;
+	struct wmi_peer_create_mlo_params *ml_param;
+	void *ptr;
+	struct wmi_tlv *tlv;
 
-	skb = ath12k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));
+	len = sizeof(*cmd) + TLV_HDR_SIZE + sizeof(*ml_param);
+
+	skb = ath12k_wmi_alloc_skb(wmi->wmi_ab, len);
 	if (!skb)
 		return -ENOMEM;
 
@@ -1197,6 +1202,18 @@ int ath12k_wmi_send_peer_create_cmd(stru
 	cmd->peer_type = cpu_to_le32(param->peer_type);
 	cmd->vdev_id = cpu_to_le32(param->vdev_id);
 
+	ptr = skb->data + sizeof(*cmd);
+	tlv = ptr;
+	tlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |
+		      FIELD_PREP(WMI_TLV_LEN, sizeof(*ml_param));
+	ptr += TLV_HDR_SIZE;
+
+	ml_param = ptr;
+	ml_param->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_MLO_PEER_CREATE_PARAMS) |
+				FIELD_PREP(WMI_TLV_LEN, sizeof(*ml_param) - TLV_HDR_SIZE);
+
+	ml_param->flags = FIELD_PREP(ATH12K_WMI_FLAG_MLO_ENABLED, param->ml_enabled);
+
 	ret = ath12k_wmi_cmd_send(wmi, skb, WMI_PEER_CREATE_CMDID);
 	if (ret) {
 		ath12k_warn(ar->ab, "failed to submit WMI_PEER_CREATE cmd\n");
@@ -1204,8 +1221,8 @@ int ath12k_wmi_send_peer_create_cmd(stru
 	}
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_WMI,
-		   "WMI peer create vdev_id %d peer_addr %pM num_peer : %d\n",
-		   param->vdev_id, param->peer_addr, ar->num_peers);
+		   "WMI peer create vdev_id %d peer_addr %pM ml_enabled %d\n",
+		   param->vdev_id, param->peer_addr, param->ml_enabled);
 
 	return ret;
 }
@@ -2014,6 +2031,8 @@ int ath12k_wmi_send_peer_assoc_cmd(struc
 	struct wmi_vht_rate_set *mcs;
 	struct wmi_he_rate_set *he_mcs;
 	struct wmi_eht_rate_set *eht_mcs;
+	struct wmi_peer_assoc_mlo_params *ml_params;
+	struct wmi_peer_assoc_mlo_partner_info *partner_info;
 	struct sk_buff *skb;
 	struct wmi_tlv *tlv;
 	void *ptr;
@@ -2032,7 +2051,8 @@ int ath12k_wmi_send_peer_assoc_cmd(struc
 	      sizeof(*mcs) + TLV_HDR_SIZE +
 	      (sizeof(*he_mcs) * param->peer_he_mcs_count) +
 	      TLV_HDR_SIZE + (sizeof(*eht_mcs) * param->peer_eht_mcs_count) +
-	      TLV_HDR_SIZE + TLV_HDR_SIZE;/* For MLO */
+	      TLV_HDR_SIZE + sizeof(*ml_params) +
+	      TLV_HDR_SIZE + (param->ml.num_partner_links * sizeof(*partner_info));
 
 	skb = ath12k_wmi_alloc_skb(wmi->wmi_ab, len);
 	if (!skb)
@@ -2153,13 +2173,35 @@ int ath12k_wmi_send_peer_assoc_cmd(struc
 		ptr += sizeof(*he_mcs);
 	}
 
-	/* WAR fill MLO Header TAG with 0 length */
-	len = 0;
+	/* MLO params */
 	tlv = ptr;
 	tlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |
-		      FIELD_PREP(WMI_TLV_LEN, len);
+		      FIELD_PREP(WMI_TLV_LEN, sizeof(*ml_params));
 	ptr += TLV_HDR_SIZE;
 
+	ml_params = ptr;
+	ml_params->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_MLO_PEER_ASSOC_PARAMS) |
+				FIELD_PREP(WMI_TLV_LEN, sizeof(*ml_params) - TLV_HDR_SIZE);
+
+	ml_params->flags = FIELD_PREP(ATH12K_WMI_FLAG_MLO_ENABLED,
+				      param->ml.enabled) |
+			   FIELD_PREP(ATH12K_WMI_FLAG_MLO_ASSOC_LINK,
+				      param->ml.assoc_link) |
+			   FIELD_PREP(ATH12K_WMI_FLAG_MLO_PRIMARY_UMAC,
+				      param->ml.primary_umac) |
+			   FIELD_PREP(ATH12K_WMI_FLAG_MLO_LOGICAL_LINK_IDX_VALID,
+				      param->ml.logical_link_idx_valid) |
+			   FIELD_PREP(ATH12K_WMI_FLAG_MLO_PEER_ID_VALID,
+				      param->ml.peer_id_valid);
+
+	ether_addr_copy(ml_params->mld_addr.addr, param->ml.mld_addr);
+	ml_params->logical_link_idx = param->ml.logical_link_idx;
+	ml_params->ml_peer_id = param->ml.ml_peer_id;
+	ml_params->ieee_link_id = param->ml.ieee_link_id;
+	/* TODO emlsr params */
+
+	ptr += sizeof(*ml_params);
+
 	/* Loop through the EHT rate set.
 	 */
 	len = param->peer_eht_mcs_count * sizeof(*eht_mcs);
@@ -2179,13 +2221,33 @@ int ath12k_wmi_send_peer_assoc_cmd(struc
 		ptr += sizeof(*eht_mcs);
 	}
 
-	/* fill ML Partner links Header TAG */
-	len = 0;
+	/* fill ML Partner links */
 	tlv = ptr;
 	tlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |
-		      FIELD_PREP(WMI_TLV_LEN, len);
+		      FIELD_PREP(WMI_TLV_LEN,
+				 param->ml.num_partner_links * sizeof(*partner_info));
 	ptr += TLV_HDR_SIZE;
 
+	for (i = 0; i < param->ml.num_partner_links; i++) {
+		partner_info = ptr;
+		partner_info->tlv_header = FIELD_PREP(WMI_TLV_TAG,
+						      WMI_TAG_MLO_PARTNER_LINK_PARAMS_PEER_ASSOC) |
+					   FIELD_PREP(WMI_TLV_LEN,
+						 sizeof(*partner_info) - TLV_HDR_SIZE);
+		partner_info->vdev_id = param->ml.partner_info[i].vdev_id;
+		partner_info->hw_link_id = param->ml.partner_info[i].hw_link_id;
+
+		partner_info->flags = FIELD_PREP(ATH12K_WMI_FLAG_MLO_ENABLED, 1) |
+				      FIELD_PREP(ATH12K_WMI_FLAG_MLO_ASSOC_LINK,
+						 param->ml.partner_info[i].assoc_link) |
+				      FIELD_PREP(ATH12K_WMI_FLAG_MLO_PRIMARY_UMAC,
+						 param->ml.partner_info[i].primary_umac) |
+				      FIELD_PREP(ATH12K_WMI_FLAG_MLO_LOGICAL_LINK_IDX_VALID,
+						 param->ml.partner_info[i].logical_link_idx_valid);
+		partner_info->logical_link_idx = param->ml.partner_info[i].logical_link_idx;
+		ptr += sizeof(*partner_info);
+	}
+
 	ret = ath12k_wmi_cmd_send(wmi, skb, WMI_PEER_ASSOC_CMDID);
 	if (ret) {
 		ath12k_warn(ar->ab,
@@ -2194,7 +2256,7 @@ int ath12k_wmi_send_peer_assoc_cmd(struc
 	}
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_WMI,
-		   "wmi peer assoc vdev id %d assoc id %d peer mac %pM peer_flags %x rate_caps %x peer_caps %x listen_intval %d ht_caps %x max_mpdu %d nss %d phymode %d peer_mpdu_density %d vht_caps %x he cap_info %x he ops %x he cap_info_ext %x he phy %x %x %x peer_bw_rxnss_override %x peer_flags_ext %x eht mac_cap %x %x eht phy_cap %x %x %x eht ops %x\n",
+		   "wmi peer assoc vdev id %d assoc id %d peer mac %pM peer_flags %x rate_caps %x peer_caps %x listen_intval %d ht_caps %x max_mpdu %d nss %d phymode %d peer_mpdu_density %d vht_caps %x he cap_info %x he ops %x he cap_info_ext %x he phy %x %x %x peer_bw_rxnss_override %x peer_flags_ext %x eht mac_cap %x %x eht phy_cap %x %x %x eht ops %x ml flags %x ml peer id %d num_partner_links %d\n",
 		   cmd->vdev_id, cmd->peer_associd, param->peer_mac,
 		   cmd->peer_flags, cmd->peer_rate_caps, cmd->peer_caps,
 		   cmd->peer_listen_intval, cmd->peer_ht_caps,
@@ -2207,7 +2269,10 @@ int ath12k_wmi_send_peer_assoc_cmd(struc
 		   cmd->peer_bw_rxnss_override, cmd->peer_flags_ext,
 		   cmd->peer_eht_cap_mac[0], cmd->peer_eht_cap_mac[1],
 		   cmd->peer_eht_cap_phy[0], cmd->peer_eht_cap_phy[1],
-		   cmd->peer_eht_cap_phy[2], cmd->peer_eht_ops);
+		   cmd->peer_eht_cap_phy[2], cmd->peer_eht_ops,
+		   ml_params->flags, ml_params->ml_peer_id,
+		   param->ml.num_partner_links
+		   );
 
 	return ret;
 }
--- a/drivers/net/wireless/ath/ath12k/wmi.h
+++ b/drivers/net/wireless/ath/ath12k/wmi.h
@@ -3131,6 +3131,10 @@ struct wmi_ml_partner_info {
 	u32 vdev_id;
 	u32 hw_link_id;
 	u8 addr[ETH_ALEN];
+	bool assoc_link;
+	bool primary_umac;
+	bool logical_link_idx_valid;
+	u32 logical_link_idx;
 };
 
 struct wmi_ml_arg {
@@ -3170,6 +3174,7 @@ struct peer_create_params {
 	const u8 *peer_addr;
 	u32 peer_type;
 	u32 vdev_id;
+	bool ml_enabled;
 };
 
 struct peer_delete_params {
@@ -3313,6 +3318,11 @@ enum wmi_peer_type {
 	WMI_PEER_TYPE_TDLS = 2,
 };
 
+struct wmi_peer_create_mlo_params {
+	u32 tlv_header;
+	u32 flags;
+} __packed;
+
 struct wmi_peer_create_cmd {
 	__le32 tlv_header;
 	__le32 vdev_id;
@@ -3999,6 +4009,20 @@ struct wmi_rate_set_arg {
 	u8 rates[WMI_MAX_SUPPORTED_RATES];
 };
 
+struct peer_assoc_mlo_params {
+	bool enabled;
+	bool assoc_link;
+	bool primary_umac;
+	bool peer_id_valid;
+	bool logical_link_idx_valid;
+	u8 mld_addr[ETH_ALEN];
+	u32 logical_link_idx;
+	u32 ml_peer_id;
+	u32 ieee_link_id;
+	u8 num_partner_links;
+	struct wmi_ml_partner_info partner_info[ATH12K_WMI_MLO_MAX_LINKS];
+};
+
 struct peer_assoc_params {
 	struct wmi_mac_addr peer_macaddr;
 	u32 vdev_id;
@@ -4071,8 +4095,29 @@ struct peer_assoc_params {
 	struct ath12k_ppe_threshold peer_eht_ppet;
 	u32 ru_punct_bitmap;
 	bool is_assoc;
+	struct peer_assoc_mlo_params ml;
 };
 
+struct wmi_peer_assoc_mlo_partner_info {
+	u32 tlv_header;
+	u32 vdev_id;
+	u32 hw_link_id;
+	u32 flags;
+	u32 logical_link_idx;
+} __packed;
+
+struct wmi_peer_assoc_mlo_params {
+	u32 tlv_header;
+	u32 flags;
+	struct wmi_mac_addr mld_addr;
+	u32 logical_link_idx;
+	u32 ml_peer_id;
+	u32 ieee_link_id;
+	u32 emlsr_trans_timeout_us;
+	u32 emlsr_trans_delay_us;
+	u32 emlsr_padding_delay_us;
+} __packed;
+
 struct  wmi_peer_assoc_complete_cmd {
 	__le32 tlv_header;
 	struct wmi_mac_addr peer_macaddr;
