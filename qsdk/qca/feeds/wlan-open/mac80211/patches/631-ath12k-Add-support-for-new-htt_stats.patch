From 6d19a7be4d76116843f7016c6712347c3f138b19 Mon Sep 17 00:00:00 2001
From: Dinesh Karthikeyan <quic_dinek@quicinc.com>
Date: Mon, 16 May 2022 11:00:40 +0530
Subject: [PATCH] ath12k: Add support for new htt_stats

Add additional htt stats type:
ATH12K_DBG_HTT_EXT_STA_11AX_UL_STATS
Dump the 11ax uplink stats for station.

ATH12K_DBG_HTT_EXT_VDEV_RTT_RESP_STATS
Dump RTT response stats for all vdevs.

ATH12K_DBG_HTT_EXT_PKTLOG_AND_HTT_RING_STATS
Dump various pktlog payload that are dropped.

ATH12K_DBG_HTT_EXT_STATS_DLPAGER_STATS
Dump the lock/unlock pages with last 10 lock/unlock
occurrences.

ATH12K_DBG_HTT_EXT_VDEVS_TXRX_STATS
Dump TX and RX stats for all vdevs.

ATH12K_DBG_HTT_EXT_VDEV_RTT_INITIATOR_STATS
Dump RTT initiator stats for all vdevs.

ATH12K_DBG_HTT_EXT_PDEV_PER_STATS
Dump the tx per rate stats.

ATH12K_DBG_HTT_EXT_AST_ENTRIES
Dump AST logs.

Signed-off-by: Dinesh Karthikeyan <quic_dinek@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/debugfs.h          |   8 +
 .../net/wireless/ath/ath12k/debugfs_htt_stats.c    | 940 +++++++++++++++++++++
 .../net/wireless/ath/ath12k/debugfs_htt_stats.h    | 530 +++++++++++-
 3 files changed, 1464 insertions(+), 14 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/debugfs.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs.h
@@ -47,7 +47,15 @@ enum ath12k_dbg_htt_ext_stats_type {
 	ATH12K_DBG_HTT_EXT_STATS_PDEV_RX_RATE_EXT	    =  30,
 	ATH12K_DBG_HTT_EXT_STATS_PDEV_TX_RATE_TXBF	    =  31,
 	ATH12K_DBG_HTT_EXT_STATS_TXBF_OFDMA		    =  32,
+	ATH12K_DBG_HTT_EXT_STA_11AX_UL_STATS		    =  33,
+	ATH12K_DBG_HTT_EXT_VDEV_RTT_RESP_STATS		    =  34,
+	ATH12K_DBG_HTT_EXT_PKTLOG_AND_HTT_RING_STATS	    =  35,
+	ATH12K_DBG_HTT_EXT_STATS_DLPAGER_STATS		    =  36,
 	ATH12K_DBG_HTT_EXT_PHY_COUNTERS_AND_PHY_STATS	    =  37,
+	ATH12K_DBG_HTT_EXT_VDEVS_TXRX_STATS		    =  38,
+	ATH12K_DBG_HTT_EXT_VDEV_RTT_INITIATOR_STATS	    =  39,
+	ATH12K_DBG_HTT_EXT_PDEV_PER_STATS		    =  40,
+	ATH12K_DBG_HTT_EXT_AST_ENTRIES			    =  41,
 
 	/* keep this last */
 	ATH12K_DBG_HTT_NUM_EXT_STATS,
--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
@@ -335,6 +335,74 @@ htt_print_tx_pdev_stats_tx_ppdu_stats_tl
 	stats_req->buf_len = len;
 }
 
+static inline
+void htt_print_tx_pdev_mu_ppdu_dist_stats_tlv_v(const void *tag_buf,
+						struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_mu_ppdu_dist_stats_tlv_v *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	u8 max = HTT_STATS_MAX_NUM_MU_PPDU_PER_BURST;
+	char hw_mode_prefix[][3] = {"ac", "ax"};
+	u8 j = 0, k = 0;
+
+	if (htt_stats_buf->hw_mode == HTT_STATS_HWMODE_AC) {
+		len += scnprintf(buf + len, buf_len - len,
+				 "\nHTT_TX_PDEV_MU_PPDU_DISTRIBUTION_STATS:\n");
+	} else if (htt_stats_buf->hw_mode == HTT_STATS_HWMODE_AX) {
+		k = 1;
+	} else {
+		/* hw_mode not recognized */
+		return;
+	}
+
+	len += scnprintf(buf + len, buf_len - len,
+			 htt_stats_buf->mu_mimo_num_seq_posted,
+			 "%s_mu_mimo_num_seq_posted_nr4\n", hw_mode_prefix[k]);
+	len += scnprintf(buf + len, buf_len - len,
+			 htt_stats_buf->mu_mimo_num_seq_posted,
+			 "%s_mu_mimo_num_seq_posted_nr8\n", hw_mode_prefix[k]);
+
+	for (j = 0; j < HTT_STATS_MAX_NUM_MU_PPDU_PER_BURST; j++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 "%s_mu_mimo_num_ppdu_posted_per_burst_nr4 %u:%u,\n",
+				 hw_mode_prefix[k], j,
+				 htt_stats_buf->mu_mimo_num_ppdu_posted_per_burst[j]);
+		len += scnprintf(buf + len, buf_len - len,
+				 "%s_mu_mimo_num_ppdu_posted_per_burst_nr8 %u:%u,\n",
+				 hw_mode_prefix[k], j,
+				 htt_stats_buf->mu_mimo_num_ppdu_posted_per_burst
+						[max + j]);
+	}
+
+	for (j = 0; j < HTT_STATS_MAX_NUM_MU_PPDU_PER_BURST; j++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 "%s_mu_mimo_num_ppdu_completed_per_burst_nr4 %u:%u,\n",
+				 hw_mode_prefix[k], j,
+				 htt_stats_buf->mu_mimo_num_ppdu_completed_per_burst[j]);
+		len += scnprintf(buf + len, buf_len - len,
+				 "%s_mu_mimo_num_ppdu_completed_per_burst_nr8 %u:%u,\n",
+				 hw_mode_prefix[k], j,
+				 htt_stats_buf->mu_mimo_num_ppdu_completed_per_burst
+						 [max + j]);
+	}
+
+	for (j = 0; j < HTT_STATS_MAX_NUM_SCHED_STATUS; j++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 "%s_mu_mimo_num_seq_term_status_nr4 %u:%u,\n",
+				 hw_mode_prefix[k], j,
+				 htt_stats_buf->mu_mimo_num_seq_term_status[j]);
+		len += scnprintf(buf + len, buf_len - len,
+				 "%s_mu_mimo_num_seq_term_status_nr8 %u:%u,\n",
+				 hw_mode_prefix[k], j,
+				 htt_stats_buf->mu_mimo_num_seq_term_status
+						[HTT_STATS_MAX_NUM_SCHED_STATUS + j]);
+	}
+
+	stats_req->buf_len = len;
+}
+
 static inline void
 htt_print_tx_pdev_stats_tried_mpdu_cnt_hist_tlv_v(const void *tag_buf,
 						  u16 tag_len,
@@ -733,6 +801,36 @@ static inline void htt_print_peer_stats_
 	stats_req->buf_len = len;
 }
 
+static inline void htt_print_ast_entry_tlv(const void *tag_buf,
+					   struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_ast_entry_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	u32 mac_addr = __le32_to_cpu(htt_stats_buf->mac_addr.mac_addr_l32);
+	u32 mac_addr_16 = __le32_to_cpu(htt_stats_buf->mac_addr.mac_addr_h16);
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "mac_addr : %02x:%02x:%02x:%02x:%02x:%02x | ast_index : %u | sw_peer_id : %u | pdev_id : %u | vdev_id : %u\n",
+			 u32_get_bits(mac_addr, HTT_MAC_ADDR_L32_0),
+			 u32_get_bits(mac_addr, HTT_MAC_ADDR_L32_1),
+			 u32_get_bits(mac_addr, HTT_MAC_ADDR_L32_2),
+			 u32_get_bits(mac_addr, HTT_MAC_ADDR_L32_3),
+			 u32_get_bits(mac_addr_16, HTT_MAC_ADDR_H16_0),
+			 u32_get_bits(mac_addr_16, HTT_MAC_ADDR_H16_1),
+			 htt_stats_buf->ast_index, htt_stats_buf->sw_peer_id,
+			 htt_stats_buf->pdev_id, htt_stats_buf->vdev_id);
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "next_hop : %u | mcast : %u | monitor_direct :%u | mesh_sta : %u | mec :%u | intra_bss :%u\n",
+			 htt_stats_buf->next_hop, htt_stats_buf->mcast,
+			 htt_stats_buf->monitor_direct, htt_stats_buf->mesh_sta,
+			 htt_stats_buf->mec, htt_stats_buf->intra_bss);
+
+	stats_req->buf_len = len;
+}
+
 static inline void htt_print_peer_details_tlv(const void *tag_buf,
 					      struct debug_htt_stats_req *stats_req)
 {
@@ -1536,6 +1634,200 @@ htt_print_tx_selfgen_ax_err_stats_tlv(co
 	stats_req->buf_len = len;
 }
 
+static inline
+void htt_print_tx_selfgen_ac_sched_status_stats_tlv(const void *tag_buf,
+						    struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_selfgen_ac_sched_status_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "HTT_TX_SELFGEN_AC_SCHED_STATUS_STATS_TLV:");
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_su_ndpa_sch_status,
+			   "ac_su_ndpa_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_su_ndp_sch_status,
+			   "ac_su_ndp_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_mu_mimo_ndpa_sch_status,
+			   "ac_mu_mimo_ndpa_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_mu_mimo_ndp_sch_status,
+			   "ac_mu_mimo_ndp_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_mu_mimo_brp_sch_status,
+			   "ac_mu_mimo_brp_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_su_ndp_sch_flag_err,
+			   "ac_su_ndp_sch_flag_err = %s ",
+			   HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_mu_mimo_ndp_sch_flag_err,
+			   "ac_mu_mimo_ndp_sch_flag_err = %s ",
+			   HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_mu_mimo_brp_sch_flag_err,
+			   "ac_mu_mimo_brp_sch_flag_err = %s ",
+			   HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS, "\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_selfgen_ax_sched_status_stats_tlv(const void *tag_buf,
+					       struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_selfgen_ax_sched_status_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "HTT_TX_SELFGEN_AX_SCHED_STATUS_STATS_TLV:");
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_su_ndpa_sch_status,
+			   "ax_su_ndpa_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_su_ndp_sch_status,
+			   "ax_su_ndp_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_mimo_ndpa_sch_status,
+			   "ax_mu_mimo_ndpa_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_mimo_ndp_sch_status,
+			   "ax_mu_mimo_ndp_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_brp_sch_status,
+			   "ax_mu_brp_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_bar_sch_status,
+			   "ax_mu_bar_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_basic_trig_sch_status,
+			   "ax_basic_trig_sch_status = %s ",
+			   HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_su_ndp_sch_flag_err,
+			   "ax_su_ndp_sch_flag_err = %s ",
+			   HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_mimo_ndp_sch_flag_err,
+			   "ax_mu_mimo_ndp_sch_flag_err = %s ",
+			   HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_brp_sch_flag_err,
+			   "ax_mu_brp_sch_flag_err = %s ",
+			   HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_bar_sch_flag_err,
+			   "ax_mu_bar_sch_flag_err = %s ",
+			   HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_basic_trig_sch_flag_err,
+			   "ax_basic_trig_sch_flag_err = %s ",
+			   HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS, "\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_dl_mu_ofdma_sch_stats_tlv(const void *tag_buf,
+					    struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_dl_mu_ofdma_sch_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "11ax DL MU_OFDMA SCH STATS:\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_ofdma_sch_nusers,
+			   "ax_mu_ofdma_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS, "\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_ul_mu_ofdma_sch_stats_tlv(const void *tag_buf,
+					    struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_ul_mu_ofdma_sch_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "11ax UL MU_OFDMA SCH STATS:\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_ul_mu_ofdma_basic_sch_nusers,
+			   "ax_ul_mu_ofdma_basic_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_ul_mu_ofdma_bsr_sch_nusers,
+			   "ax_ul_mu_ofdma_bsr_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_ul_mu_ofdma_bar_sch_nusers,
+			   "ax_ul_mu_ofdma_bar_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_ul_mu_ofdma_brp_sch_nusers,
+			   "ax_ul_mu_ofdma_brp_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS, "\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_ul_mu_mimo_sch_stats_tlv(const void *tag_buf,
+					   struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_ul_mu_mimo_sch_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "11ax UL MU_MIMO SCH STATS:\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_ul_mu_mimo_basic_sch_nusers,
+			   "ax_ul_mu_mimo_basic_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_ul_mu_mimo_brp_sch_nusers,
+			   "ax_ul_mu_mimo_brp_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS, "\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_dl_mu_mimo_sch_stats_tlv(const void *tag_buf,
+					   struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_dl_mu_mimo_sch_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "HTT_TX_PDEV_MU_MIMO_SCH_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "mu_mimo_sch_posted = %u\n",
+			 htt_stats_buf->mu_mimo_sch_posted);
+	len += scnprintf(buf + len, buf_len - len, "mu_mimo_sch_failed = %u\n",
+			 htt_stats_buf->mu_mimo_sch_failed);
+	len += scnprintf(buf + len, buf_len - len, "mu_mimo_ppdu_posted = %u\n",
+			 htt_stats_buf->mu_mimo_ppdu_posted);
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_mu_mimo_sch_posted_per_grp_sz,
+			   "ac_mu_mimo_sch_posted_per_group_index",
+			   HTT_TX_PDEV_STATS_NUM_AC_MUMIMO_USER_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_mimo_sch_posted_per_grp_sz,
+			   "ax_mu_mimo_sch_posted_per_group_index",
+			   HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS, "\n");
+
+	len += scnprintf(buf + len, buf_len - len, "11ac DL MU_MIMO SCH STATS:\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_mu_mimo_sch_nusers,
+			   "ac_mu_mimo_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_AC_MUMIMO_USER_STATS, "\n");
+
+	len += scnprintf(buf + len, buf_len - len, "\n11ax DL MU_MIMO SCH STATS:\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ax_mu_mimo_sch_nusers,
+			   "ax_mu_mimo_sch_nusers",
+			   HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS, "\n");
+
+	stats_req->buf_len = len;
+}
+
 static inline void
 htt_print_tx_pdev_mu_mimo_sch_stats_tlv(const void *tag_buf,
 					struct debug_htt_stats_req *stats_req)
@@ -1579,6 +1871,52 @@ htt_print_tx_pdev_mu_mimo_sch_stats_tlv(
 	stats_req->buf_len = len;
 }
 
+static inline
+void htt_print_tx_pdev_mumimo_grp_stats_tlv(const void *tag_buf,
+					    struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_mumimo_grp_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	int j;
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "HTT_TX_PDEV_MUMIMO_GRP_STATS:\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->dl_mumimo_grp_best_grp_size,
+			   "dl_mumimo_grp_best_grp_size", HTT_STATS_MAX_MUMIMO_GRP_SZ,
+			   "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->dl_mumimo_grp_best_num_usrs,
+			   "dl_mumimo_grp_best_num_usrs",
+			   HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->dl_mumimo_grp_tputs,
+			   "dl_mumimo_grp_tputs_observed (per bin = 300 mbps)",
+			   HTT_STATS_MUMIMO_TPUT_NUM_BINS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->dl_mumimo_grp_eligible,
+			   "dl_mumimo_grp eligible", HTT_STATS_MAX_MUMIMO_GRP_SZ, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->dl_mumimo_grp_ineligible,
+			   "dl_mumimo_grp_ineligible", HTT_STATS_MAX_MUMIMO_GRP_SZ, "\n");
+	for (j = 0; j < HTT_STATS_MAX_MUMIMO_GRP_SZ; j++) {
+		len += scnprintf(buf + len, buf_len - len, "grp_id = %u", j);
+		PRINT_ARRAY_TO_BUF(buf, len,
+				   htt_stats_buf->dl_mumimo_grp_invalid, NULL,
+				   HTT_STATS_MAX_INVALID_REASON_CODE, "\n");
+	}
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ul_mumimo_grp_best_grp_size,
+			   "ul_mumimo_grp_best_grp_size", HTT_STATS_MAX_MUMIMO_GRP_SZ,
+			   "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ul_mumimo_grp_best_num_usrs,
+			   "ul_mumimo_grp_best_num_usrs",
+			   HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ul_mumimo_grp_tputs,
+			   "ul_mumimo_grp_tputs_observed (per bin = 300 mbps)",
+			   HTT_STATS_MUMIMO_TPUT_NUM_BINS, "\n");
+
+	stats_req->buf_len = len;
+}
+
 static inline void
 htt_print_tx_pdev_mu_mimo_mpdu_stats_tlv(const void *tag_buf,
 					 struct debug_htt_stats_req *stats_req)
@@ -2065,6 +2403,39 @@ htt_print_tx_tqm_cmn_stats_tlv(const voi
 	stats_req->buf_len = len;
 }
 
+static inline void
+htt_print_unavailable_error_stats_tlv(const void *tag_buf,
+				      struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_stats_error_tlv_v *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_ERROR_STATS_TLV:");
+	len += scnprintf(buf + len, buf_len - len,
+			 "No stats to print for current request: %d",
+			 htt_stats_buf->htt_stats_type);
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_unsupported_error_stats_tlv(const void *tag_buf,
+				      struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_stats_error_tlv_v *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_ERROR_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "Unsupported HTT stats type: %d\n",
+			 htt_stats_buf->htt_stats_type);
+
+	stats_req->buf_len = len;
+}
+
 static inline void htt_print_tx_tqm_error_stats_tlv(const void *tag_buf,
 						    struct debug_htt_stats_req *stats_req)
 {
@@ -2799,7 +3170,7 @@ static inline void htt_print_tx_pdev_rat
 	}
 	tx_bw[j] = htt_stats_buf->tx_bw_320mhz;
 	PRINT_ARRAY_TO_BUF(buf, len, tx_bw, "tx_bw",
-			   HTT_TX_PDEV_STATS_NUM_BW_COUNTERS, "\n");
+			   HTT_TX_PDEV_STATS_NUM_BW_COUNTERS + 1, "\n");
 
 	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ac_mu_mimo_tx_bw,
 			   "ac_mu_mimo_tx_bw", HTT_TX_PDEV_STATS_NUM_BW_COUNTERS, "\n");
@@ -3109,7 +3480,7 @@ static inline void htt_print_rx_pdev_rat
 	u8 *buf = stats_req->buf;
 	u32 len = stats_req->buf_len;
 	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
-	u8 j=0;
+	u8 j=0, i;
 
 	len += scnprintf(buf + len, buf_len - len, "HTT_RX_PDEV_RATE_EXT_STATS_TLV:\n");
 	len += scnprintf(buf + len, buf_len - len, "rssi_mcast_in_dbm = %d\n",
@@ -3118,6 +3489,12 @@ static inline void htt_print_rx_pdev_rat
 			 htt_stats_buf->rssi_mgmt_in_dbm);
 
 	for (j = 0; j < HTT_RX_PDEV_STATS_NUM_SPATIAL_STREAMS; j++) {
+		for (i = 0; i < HTT_RX_PDEV_STATS_NUM_BW_EXT_COUNTERS; i++)
+			len += scnprintf(buf + len,
+					 buf_len - len,
+					 " %u:%d,",
+					 i,
+					 htt_stats_buf->rx_per_chain_rssi_ext_in_dbm[j][i]);
 		len += scnprintf(buf + len, buf_len - len, "\nrssi_chain_ext[%u] = ", j);
 		PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->rssi_chain_ext[j],
 				   NULL, HTT_RX_PDEV_STATS_NUM_BW_EXT_COUNTERS, "\n");
@@ -4813,6 +5190,156 @@ htt_print_pdev_tx_rate_txbf_stats_tlv(co
 	stats_req->buf_len = len;
 }
 
+static inline void
+htt_print_tx_per_rate_stats_tlv(const void *tag_buf,
+				struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_per_rate_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	char mode_prefix[][3] = {"su", "mu"};
+	int i = 0, j = 0;
+
+	if (htt_stats_buf->rc_mode == HTT_STATS_RC_MODE_DLSU) {
+		len += scnprintf(buf + len, buf_len - len, "HTT_TX_PER_STATS:\n");
+		len += scnprintf(buf + len, buf_len - len, "PER_STATS_SU:\n");
+	} else if (htt_stats_buf->rc_mode == HTT_STATS_RC_MODE_DLMUMIMO) {
+		len += scnprintf(buf + len, buf_len - len, "\nPER_STATS_DL_MUMIMO:\n");
+		j = 1;
+	} else {
+		return;
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\nPER per BW:\n");
+
+	len += scnprintf(buf + len, buf_len - len, "ppdus_tried_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_BW_COUNTERS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_bw[i].ppdus_tried);
+	}
+	/*
+	 * Now i = HTT_TX_PDEV_STATS_NUM_BW_COUNTERS.
+	 * Adding 320 MHz ppdus tried.
+	 */
+	len += scnprintf(buf + len, buf_len - len,
+			 " %u:%u\n", i, htt_stats_buf->per_bw320.ppdus_tried);
+
+	len += scnprintf(buf + len, buf_len - len, "ppdus_ack_failed_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_BW_COUNTERS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_bw[i].ppdus_ack_failed);
+	}
+	/*
+	 * Now i = HTT_TX_PDEV_STATS_NUM_BW_COUNTERS.
+	 * Adding 320 MHz ppdus ack failed.
+	 */
+	len += scnprintf(buf + len, buf_len - len,
+			 " %u:%u\n", i, htt_stats_buf->per_bw320.ppdus_ack_failed);
+
+	len += scnprintf(buf + len, buf_len - len, "mpdus_tried_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_BW_COUNTERS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_bw[i].mpdus_tried);
+	}
+	/*
+	 * Now i = HTT_TX_PDEV_STATS_NUM_BW_COUNTERS.
+	 * Adding 320 MHz mpdus tried.
+	 */
+	len += scnprintf(buf + len, buf_len - len,
+			 " %u:%u\n", i, htt_stats_buf->per_bw320.mpdus_tried);
+
+
+	len += scnprintf(buf + len, buf_len - len, "mpdus_failed_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_BW_COUNTERS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_bw[i].mpdus_failed);
+	}
+	/*
+	 * Now i = HTT_TX_PDEV_STATS_NUM_BW_COUNTERS.
+	 * Adding 320 MHz mpdus failed.
+	 */
+	len += scnprintf(buf + len, buf_len - len,
+			 " %u:%u\n", i, htt_stats_buf->per_bw320.mpdus_failed);
+
+	len += scnprintf(buf + len, buf_len - len, "\nPER per NSS:\n");
+
+	len += scnprintf(buf + len, buf_len - len, "ppdus_tried_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_nss[i].ppdus_tried);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\nppdus_ack_fialed_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_nss[i].ppdus_ack_failed);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\nmpdus_tried_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_nss[i].mpdus_tried);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\nmpdus_failed_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_nss[i].mpdus_failed);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\nPER per Mcs:\n");
+
+	len += scnprintf(buf + len, buf_len - len, "ppdus_tried_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_TXBF_RATE_STATS_NUM_MCS_COUNTERS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_mcs[i].ppdus_tried);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\nppdus_ack_failed_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_TXBF_RATE_STATS_NUM_MCS_COUNTERS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_mcs[i].ppdus_ack_failed);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\nmpdus_tried_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_TXBF_RATE_STATS_NUM_MCS_COUNTERS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_mcs[i].mpdus_tried);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\nmpdus_failed_%s", mode_prefix[j]);
+	for (i = 0; i < HTT_TX_TXBF_RATE_STATS_NUM_MCS_COUNTERS; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 " %u:%u ",
+				 i, htt_stats_buf->per_mcs[i].mpdus_failed);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "\n");
+
+	if (htt_stats_buf->rc_mode == HTT_STATS_RC_MODE_DLMUMIMO) {
+		len += scnprintf(buf + len, buf_len - len, "last_probed_bw  = %u\n",
+				 htt_stats_buf->last_probed_bw);
+		len += scnprintf(buf + len, buf_len - len, "last_probed_nss = %u\n",
+				 htt_stats_buf->last_probed_nss);
+		len += scnprintf(buf + len, buf_len - len, "last_probed_mcs = %u\n",
+				 htt_stats_buf->last_probed_mcs);
+	}
+
+	stats_req->buf_len = len;
+}
+
 static
 inline void htt_print_txbf_ofdma_ndpa_stats_tlv(const void *tag_buf,
 						struct debug_htt_stats_req *stats_req)
@@ -5419,6 +5946,73 @@ static inline void htt_print_phy_reset_s
 	stats_req->buf_len = len;
 }
 
+static inline void
+htt_print_soc_txrx_stats_common_tlv(const void *tag_buf,
+				    struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_t2h_soc_txrx_stats_common_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_SOC_COMMON_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "soc_drop_count = 0x%08x%08x\n",
+			 htt_stats_buf->inv_peers_msdu_drop_count_hi,
+			 htt_stats_buf->inv_peers_msdu_drop_count_lo);
+	len += scnprintf(buf + len, buf_len - len, "================================\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_vdev_txrx_stats_hw_tlv(const void *tag_buf,
+				 struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_t2h_vdev_txrx_stats_hw_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_VDEV_TXRX_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "vdev_id = %u\n",
+			 htt_stats_buf->vdev_id);
+
+	len += scnprintf(buf + len, buf_len - len, "rx_msdu_byte_cnt = 0x%08x%08x\n",
+			 htt_stats_buf->rx_msdu_byte_cnt_hi,
+			 htt_stats_buf->rx_msdu_byte_cnt_lo);
+
+	len += scnprintf(buf + len, buf_len - len, "rx_msdu_cnt = 0x%08x%08x\n",
+			 htt_stats_buf->rx_msdu_cnt_hi,
+			 htt_stats_buf->rx_msdu_cnt_lo);
+
+	len += scnprintf(buf + len, buf_len - len, "tx_msdu_byte_cnt = 0x%08x%08x\n",
+			 htt_stats_buf->tx_msdu_byte_cnt_hi,
+			 htt_stats_buf->tx_msdu_byte_cnt_lo);
+
+	len += scnprintf(buf + len, buf_len - len, "tx_msdu_cnt = 0x%08x%08x\n",
+			 htt_stats_buf->tx_msdu_cnt_hi,
+			 htt_stats_buf->tx_msdu_cnt_lo);
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "tx_msdu_excessive_retry_discard_cnt = 0x%08x%08x\n",
+			 htt_stats_buf->tx_msdu_excessive_retry_discard_cnt_hi,
+			 htt_stats_buf->tx_msdu_excessive_retry_discard_cnt_lo);
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "tx_msdu_cong_ctrl_drop_cnt = 0x%08x%08x\n",
+			 htt_stats_buf->tx_msdu_cong_ctrl_drop_cnt_hi,
+			 htt_stats_buf->tx_msdu_cong_ctrl_drop_cnt_lo);
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "tx_msdu_ttl_expire_drop_cnt = 0x%08x%08x\n",
+			 htt_stats_buf->tx_msdu_ttl_expire_drop_cnt_hi,
+			 htt_stats_buf->tx_msdu_ttl_expire_drop_cnt_lo);
+
+	len += scnprintf(buf + len, buf_len - len, "===============================\n");
+
+	stats_req->buf_len = len;
+}
+
 static
 inline void htt_print_peer_ctrl_path_txrx_stats_tlv(const void *tag_buf,
 						    struct debug_htt_stats_req *stats_req)
@@ -5558,6 +6152,279 @@ static inline void htt_print_peer_sched_
 	stats_req->buf_len = len;
 }
 
+static void htt_print_sta_ul_ofdma_stats_tlv(const void *tag_buf,
+					     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_print_sta_ul_ofdma_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	int i, j;
+
+	len += scnprintf(buf + len, buf_len - len, "========STA UL OFDMA STATS=======\n");
+
+	len += scnprintf(buf + len, buf_len - len, "pdev ID = %d\n",
+			 htt_stats_buf->pdev_id);
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->rx_trigger_type,
+			   "STA HW Trigger Type", HTT_STA_UL_OFDMA_NUM_TRIG_TYPE, "\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 " BASIC:%u, BRPOLL:%u, MUBAR:%u, MURTS:%u BSRP:%u Others:%u",
+			 htt_stats_buf->ax_trigger_type[0],
+			 htt_stats_buf->ax_trigger_type[1],
+			 htt_stats_buf->ax_trigger_type[2],
+			 htt_stats_buf->ax_trigger_type[3],
+			 htt_stats_buf->ax_trigger_type[4],
+			 htt_stats_buf->ax_trigger_type[5]);
+	len += scnprintf(buf + len, buf_len - len, "11ax Trigger Type\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 " HIPRI:%u, LOWPRI:%u, BSR:%u",
+			 htt_stats_buf->num_data_ppdu_responded_per_hwq[0],
+			 htt_stats_buf->num_data_ppdu_responded_per_hwq[1],
+			 htt_stats_buf->num_data_ppdu_responded_per_hwq[2]);
+	len += scnprintf(buf + len, buf_len - len, "Data PPDU Resp per HWQ\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 " HIPRI:%u, LOWPRI:%u, BSR:%u",
+			 htt_stats_buf->num_null_delimiters_responded_per_hwq[0],
+			 htt_stats_buf->num_null_delimiters_responded_per_hwq[1],
+			 htt_stats_buf->num_null_delimiters_responded_per_hwq[2]);
+	len += scnprintf(buf + len, buf_len - len, "Null Delim Resp per HWQ\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 " Data:%u, NullDelim:%u",
+			 htt_stats_buf->num_total_trig_responses[0],
+			 htt_stats_buf->num_total_trig_responses[1]);
+	len += scnprintf(buf + len, buf_len - len, "Trigger Resp Status\n");
+
+	len += scnprintf(buf + len, buf_len - len, "Last Trigger RX Time Interval = %u\n",
+			 htt_stats_buf->last_trig_rx_time_delta_ms);
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ul_ofdma_tx_mcs,
+			   "ul_ofdma_tx_mcs",
+			   HTT_STA_UL_OFDMA_NUM_MCS_COUNTERS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ul_ofdma_tx_nss,
+			   "ul_ofdma_tx_nss",
+			   HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS, "\n");
+
+	for (j = 0; j < HTT_TX_PDEV_STATS_NUM_GI_COUNTERS; j++) {
+		len += scnprintf(buf + len, buf_len - len, "ul_ofdma_tx_gi[%u]", j);
+		PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ul_ofdma_tx_gi[j], NULL,
+				   HTT_STA_UL_OFDMA_NUM_MCS_COUNTERS, "\n");
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "ul_ofdma_tx_ldpc = %u\n",
+			 htt_stats_buf->ul_ofdma_tx_ldpc);
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->ul_ofdma_tx_bw,
+			   "ul_ofdma_tx_bw",
+			   HTT_STA_UL_OFDMA_NUM_BW_COUNTERS, "\n");
+
+	for (i = 0; i < HTT_STA_UL_OFDMA_NUM_REDUCED_CHAN_TYPES; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+			  i == 0 ? "half_ul_ofdma_tx_bw" : "quarter_ul_ofdma_tx_bw");
+		PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->reduced_ul_ofdma_tx_bw[i],
+				   NULL, HTT_STA_UL_OFDMA_NUM_BW_COUNTERS, "\n");
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "Trig Based Tx PPDU = %u\n",
+			 htt_stats_buf->trig_based_ppdu_tx);
+	len += scnprintf(buf + len, buf_len - len, "RBO Based Tx PPDU = %u\n",
+			 htt_stats_buf->rbo_based_ppdu_tx);
+	len += scnprintf(buf + len, buf_len - len, "MU to SU EDCA Switch Count = %u\n",
+			 htt_stats_buf->mu_edca_to_su_edca_switch_count);
+	len += scnprintf(buf + len, buf_len - len, "MU EDCA Params Apply Count = %u\n",
+			 htt_stats_buf->num_mu_edca_param_apply_count);
+
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->current_edca_hwq_mode,
+			   "current_edca_hwq_mode[AC]",
+			   HTT_NUM_AC_WMM, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->current_cw_min,
+			   "current_cw_min",
+			   HTT_NUM_AC_WMM, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->current_cw_max,
+			   "current_cw_max",
+			   HTT_NUM_AC_WMM, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len, htt_stats_buf->current_aifs,
+			   "current_aifs",
+			   HTT_NUM_AC_WMM, "\n");
+
+	len += scnprintf(buf + len, buf_len - len, "=============================\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_vdev_rtt_resp_stats_tlv(const void *tag_buf,
+				  struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_vdev_rtt_resp_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_VDEV_RTT_RESP_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "vdev_id = %u\n",
+			 htt_stats_buf->vdev_id);
+	len += scnprintf(buf + len, buf_len - len, "tx_ftm_suc = %u\n",
+			 htt_stats_buf->tx_ftm_suc);
+	len += scnprintf(buf + len, buf_len - len, "tx_ftm_suc_retry = %u\n",
+			 htt_stats_buf->tx_ftm_suc_retry);
+	len += scnprintf(buf + len, buf_len - len, "tx_ftm_fail = %u\n",
+			 htt_stats_buf->tx_ftm_fail);
+	len += scnprintf(buf + len, buf_len - len, "rx_ftmr_cnt = %u\n",
+			 htt_stats_buf->rx_ftmr_cnt);
+	len += scnprintf(buf + len, buf_len - len, "rx_ftmr_dup_cnt = %u\n",
+			 htt_stats_buf->rx_ftmr_dup_cnt);
+	len += scnprintf(buf + len, buf_len - len, "rx_iftmr_cnt = %u\n",
+			 htt_stats_buf->rx_iftmr_cnt);
+	len += scnprintf(buf + len, buf_len - len, "rx_iftmr_dup_cnt = %u\n",
+			 htt_stats_buf->rx_iftmr_dup_cnt);
+	len += scnprintf(buf + len, buf_len - len,
+			 "initiator_active_responder_rejected_cnt = %u\n",
+			 htt_stats_buf->initiator_active_responder_rejected_cnt);
+	len += scnprintf(buf + len, buf_len - len, "responder_terminate_cnt = %u\n",
+			 htt_stats_buf->responder_terminate_cnt);
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_vdev_rtt_init_stats_tlv(const void *tag_buf,
+				  struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_vdev_rtt_init_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_VDEV_RTT_INIT_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "vdev_id  = %u\n",
+			 htt_stats_buf->vdev_id);
+	len += scnprintf(buf + len, buf_len - len, "tx_ftmr_cnt  = %u\n",
+			 htt_stats_buf->tx_ftmr_cnt);
+	len += scnprintf(buf + len, buf_len - len, "tx_ftmr_fail  = %u\n",
+			 htt_stats_buf->tx_ftmr_fail);
+	len += scnprintf(buf + len, buf_len - len, "tx_ftmr_suc_retry  = %u\n",
+			 htt_stats_buf->tx_ftmr_suc_retry);
+	len += scnprintf(buf + len, buf_len - len, "rx_ftm_cnt  = %u\n",
+			 htt_stats_buf->rx_ftm_cnt);
+	len += scnprintf(buf + len, buf_len - len, "initiator_terminate_cnt  = %u\n",
+			 htt_stats_buf->initiator_terminate_cnt);
+	len += scnprintf(buf + len, buf_len - len, "tx_meas_req_count = %u\n",
+			 htt_stats_buf->tx_meas_req_count);
+	len += scnprintf(buf + len, buf_len - len, "===============================\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_pktlog_and_htt_ring_stats_tlv(const void *tag_buf,
+					struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_pktlog_and_htt_ring_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "HTT_PKTLOG_AND_HTT_RING_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "pktlog_lite_drop_cnt = %u\n",
+			 htt_stats_buf->pktlog_lite_drop_cnt);
+	len += scnprintf(buf + len, buf_len - len, "pktlog_tqm_drop_cnt = %u\n",
+			 htt_stats_buf->pktlog_tqm_drop_cnt);
+	len += scnprintf(buf + len, buf_len - len, "pktlog_ppdu_stats_drop_cnt = %u\n",
+			 htt_stats_buf->pktlog_ppdu_stats_drop_cnt);
+	len += scnprintf(buf + len, buf_len - len, "pktlog_ppdu_ctrl_drop_cnt = %u\n",
+			 htt_stats_buf->pktlog_ppdu_ctrl_drop_cnt);
+	len += scnprintf(buf + len, buf_len - len, "pktlog_sw_events_drop_cnt = %u\n",
+			 htt_stats_buf->pktlog_sw_events_drop_cnt);
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+
+	stats_req->buf_len = len;
+}
+
+static inline void htt_print_dlpager_stats_tlv(const void *tag_buf,
+					       struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_dl_pager_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	u32 msg_dword_1 = htt_stats_buf->msg_dword_1;
+	u32 msg_dword_3 = htt_stats_buf->msg_dword_3;
+	u8 pg_locked = HTT_STATS_PAGE_LOCKED;
+	u8 pg_unlocked = HTT_STATS_PAGE_UNLOCKED;
+	int i;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_DLPAGER_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	len += scnprintf(buf + len, buf_len - len, "ASYNC locked pages = %u\n",
+			 HTT_DLPAGER_ASYNC_LOCK_PAGE_COUNT_GET(msg_dword_1));
+	len += scnprintf(buf + len, buf_len - len, "SYNC locked pages = %u\n",
+			 HTT_DLPAGER_SYNC_LOCK_PAGE_COUNT_GET(msg_dword_1));
+	len += scnprintf(buf + len, buf_len - len, "Total locked pages = %u\n",
+			 HTT_DLPAGER_TOTAL_LOCKED_PAGES_GET(htt_stats_buf->msg_dword_2));
+	len += scnprintf(buf + len, buf_len - len, "Total free pages = %u\n",
+			 HTT_DLPAGER_TOTAL_FREE_PAGES_GET(htt_stats_buf->msg_dword_2));
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	len += scnprintf(buf + len, buf_len - len, "LOCKED PAGES HISTORY\n");
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	len += scnprintf(buf + len, buf_len - len, "last_locked_page_idx = %u\n",
+			 (HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_GET(msg_dword_3)) ?
+			 (HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_GET(msg_dword_3) - 1) :
+						(HTT_DLPAGER_STATS_MAX_HIST - 1));
+
+	for (i = 0; i < HTT_DLPAGER_STATS_MAX_HIST; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 "Index - %u : Page Number - %u : Num of pages - %u : Timestamp - %llu us\n",
+				 i,
+				 htt_stats_buf->last_pages_info[pg_locked][i].page_num,
+				 htt_stats_buf->last_pages_info
+						[pg_locked][i].num_of_pages,
+				 ((htt_stats_buf->last_pages_info
+						[pg_locked][i].timestamp_lsbs) |
+				 (((unsigned long long)htt_stats_buf->last_pages_info
+						[pg_locked][i].timestamp_msbs) << 32)));
+	}
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	len += scnprintf(buf + len, buf_len - len, "UNLOCKED PAGES HISTORY\n");
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	len += scnprintf(buf + len, buf_len - len, "last_unlocked_page_idx = %u\n",
+			(HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_GET(msg_dword_3)) ?
+			(HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_GET(msg_dword_3) - 1) :
+						(HTT_DLPAGER_STATS_MAX_HIST - 1));
+
+	for (i = 0; i < HTT_DLPAGER_STATS_MAX_HIST; i++) {
+		len += scnprintf(buf + len, buf_len - len,
+				 "Index - %u : Page Number - %u : Num of pages - %u : Timestamp - %llu us\n",
+				 i, htt_stats_buf->last_pages_info
+							[pg_unlocked][i].page_num,
+				 htt_stats_buf->last_pages_info
+							[pg_unlocked][i].num_of_pages,
+				 ((htt_stats_buf->last_pages_info
+							[pg_unlocked][i].timestamp_lsbs) |
+				 (((unsigned long long)htt_stats_buf->last_pages_info
+						[pg_unlocked][i].timestamp_msbs) << 32)));
+	}
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+
+	stats_req->buf_len = len;
+}
+
 static int ath12k_dbg_htt_ext_stats_parse(struct ath12k_base *ab,
 					  u16 tag, u16 len, const void *tag_buf,
 					  void *user_data)
@@ -5588,6 +6455,10 @@ static int ath12k_dbg_htt_ext_stats_pars
 		htt_print_tx_pdev_stats_tx_ppdu_stats_tlv_v(tag_buf, stats_req);
 		break;
 
+	case HTT_STATS_MU_PPDU_DIST_TAG:
+		htt_print_tx_pdev_mu_ppdu_dist_stats_tlv_v(tag_buf, stats_req);
+		break;
+
 	case HTT_STATS_TX_PDEV_TRIED_MPDU_CNT_HIST_TAG:
 		htt_print_tx_pdev_stats_tried_mpdu_cnt_hist_tlv_v(tag_buf, len,
 								  stats_req);
@@ -5688,6 +6559,26 @@ static int ath12k_dbg_htt_ext_stats_pars
 		htt_print_tx_pdev_mu_mimo_sch_stats_tlv(tag_buf, stats_req);
 		break;
 
+	case HTT_STATS_TX_PDEV_MUMIMO_GRP_STATS_TAG:
+		htt_print_tx_pdev_mumimo_grp_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_PDEV_DL_MU_OFDMA_STATS_TAG:
+		htt_print_tx_pdev_dl_mu_ofdma_sch_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_PDEV_UL_MU_OFDMA_STATS_TAG:
+		htt_print_tx_pdev_ul_mu_ofdma_sch_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_PDEV_DL_MU_MIMO_STATS_TAG:
+		htt_print_tx_pdev_dl_mu_mimo_sch_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_PDEV_UL_MU_MIMO_STATS_TAG:
+		htt_print_tx_pdev_ul_mu_mimo_sch_stats_tlv(tag_buf, stats_req);
+		break;
+
 	case HTT_STATS_SFM_CMN_TAG:
 		htt_print_sfm_cmn_tlv(tag_buf, stats_req);
 		break;
@@ -5998,6 +6889,11 @@ static int ath12k_dbg_htt_ext_stats_pars
 	case HTT_STATS_TXBF_OFDMA_NDPA_STATS_TAG:
 		htt_print_txbf_ofdma_ndpa_stats_tlv(tag_buf, stats_req);
 		break;
+
+	case  HTT_STATS_PER_RATE_STATS_TAG:
+		htt_print_tx_per_rate_stats_tlv(tag_buf, stats_req);
+		break;
+
 	case HTT_STATS_TXBF_OFDMA_NDP_STATS_TAG:
 		htt_print_txbf_ofdma_ndp_stats_tlv(tag_buf, stats_req);
 		break;
@@ -6007,18 +6903,69 @@ static int ath12k_dbg_htt_ext_stats_pars
 	case HTT_STATS_TXBF_OFDMA_STEER_STATS_TAG:
 		htt_print_txbf_ofdma_steer_stats_tlv(tag_buf, stats_req);
 		break;
+
+	case HTT_STATS_TX_SELFGEN_AC_SCHED_STATUS_STATS_TAG:
+		htt_print_tx_selfgen_ac_sched_status_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_TX_SELFGEN_AX_SCHED_STATUS_STATS_TAG:
+		htt_print_tx_selfgen_ax_sched_status_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_UNAVAILABLE_ERROR_STATS_TAG:
+		htt_print_unavailable_error_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_UNSUPPORTED_ERROR_STATS_TAG:
+		htt_print_unsupported_error_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_VDEV_RTT_RESP_STATS_TAG:
+		htt_print_vdev_rtt_resp_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_VDEV_RTT_INIT_STATS_TAG:
+		htt_print_vdev_rtt_init_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_PKTLOG_AND_HTT_RING_STATS_TAG:
+		htt_print_pktlog_and_htt_ring_stats_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_DLPAGER_STATS_TAG:
+		htt_print_dlpager_stats_tlv(tag_buf, stats_req);
+		break;
+
 	case HTT_STATS_PHY_COUNTERS_TAG:
 		htt_print_phy_counters_tlv(tag_buf, stats_req);
 		break;
 	case HTT_STATS_PHY_STATS_TAG:
 		htt_print_phy_stats_tlv(tag_buf, stats_req);
 		break;
+
+	case HTT_STATS_STA_UL_OFDMA_STATS_TAG:
+		htt_print_sta_ul_ofdma_stats_tlv(tag_buf, stats_req);
+		break;
+
 	case HTT_STATS_PHY_RESET_COUNTERS_TAG:
 		htt_print_phy_reset_counters_tlv(tag_buf, stats_req);
 		break;
 	case HTT_STATS_PHY_RESET_STATS_TAG:
 		htt_print_phy_reset_stats_tlv(tag_buf, stats_req);
 		break;
+
+	case HTT_STATS_SOC_TXRX_STATS_COMMON_TAG:
+		htt_print_soc_txrx_stats_common_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_VDEV_TXRX_STATS_HW_STATS_TAG:
+		htt_print_vdev_txrx_stats_hw_tlv(tag_buf, stats_req);
+		break;
+
+	case HTT_STATS_AST_ENTRY_TAG:
+		htt_print_ast_entry_tlv(tag_buf, stats_req);
+		break;
+
 	case HTT_STATS_PEER_CTRL_PATH_TXRX_STATS_TAG:
 		htt_print_peer_ctrl_path_txrx_stats_tlv(tag_buf, stats_req);
 		break;
--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
@@ -116,15 +116,33 @@ enum htt_tlv_tag_t {
 	HTT_STATS_PEER_CTRL_PATH_TXRX_STATS_TAG		    = 101,
 	HTT_STATS_PDEV_CTRL_PATH_TX_STATS_TAG		    = 102,
 	HTT_STATS_RX_PDEV_RATE_EXT_STATS_TAG		    = 103,
+	HTT_STATS_TX_PDEV_DL_MU_MIMO_STATS_TAG		    = 104,
+	HTT_STATS_TX_PDEV_UL_MU_MIMO_STATS_TAG		    = 105,
+	HTT_STATS_TX_PDEV_DL_MU_OFDMA_STATS_TAG		    = 106,
+	HTT_STATS_TX_PDEV_UL_MU_OFDMA_STATS_TAG		    = 107,
 	HTT_STATS_PDEV_TX_RATE_TXBF_STATS_TAG		    = 108,
+	HTT_STATS_UNSUPPORTED_ERROR_STATS_TAG		    = 109,
+	HTT_STATS_UNAVAILABLE_ERROR_STATS_TAG		    = 110,
+	HTT_STATS_TX_SELFGEN_AC_SCHED_STATUS_STATS_TAG	    = 111,
+	HTT_STATS_TX_SELFGEN_AX_SCHED_STATUS_STATS_TAG	    = 112,
 	HTT_STATS_TXBF_OFDMA_NDPA_STATS_TAG		    = 113,
 	HTT_STATS_TXBF_OFDMA_NDP_STATS_TAG		    = 114,
 	HTT_STATS_TXBF_OFDMA_BRP_STATS_TAG		    = 115,
 	HTT_STATS_TXBF_OFDMA_STEER_STATS_TAG		    = 116,
+	HTT_STATS_STA_UL_OFDMA_STATS_TAG		    = 117,
+	HTT_STATS_VDEV_RTT_RESP_STATS_TAG		    = 118,
+	HTT_STATS_PKTLOG_AND_HTT_RING_STATS_TAG		    = 119,
+	HTT_STATS_DLPAGER_STATS_TAG			    = 120,
 	HTT_STATS_PHY_COUNTERS_TAG			    = 121,
 	HTT_STATS_PHY_STATS_TAG				    = 122,
 	HTT_STATS_PHY_RESET_COUNTERS_TAG		    = 123,
 	HTT_STATS_PHY_RESET_STATS_TAG			    = 124,
+	HTT_STATS_SOC_TXRX_STATS_COMMON_TAG		    = 125,
+	HTT_STATS_VDEV_TXRX_STATS_HW_STATS_TAG		    = 126,
+	HTT_STATS_VDEV_RTT_INIT_STATS_TAG		    = 127,
+	HTT_STATS_PER_RATE_STATS_TAG			    = 128,
+	HTT_STATS_MU_PPDU_DIST_TAG			    = 129,
+	HTT_STATS_TX_PDEV_MUMIMO_GRP_STATS_TAG		    = 130,
 	/* 11be stats */
 	HTT_STATS_TX_PDEV_BE_RATE_STATS_TAG		    = 131,
 	HTT_STATS_AST_ENTRY_TAG				    = 132,
@@ -508,6 +526,21 @@ struct htt_peer_details_tlv {
 	u32 qpeer_flags;
 };
 
+struct htt_ast_entry_tlv {
+	u32 sw_peer_id;
+	u32 ast_index;
+	u8 pdev_id;
+	u8 vdev_id;
+	u8 next_hop;
+	u8 mcast;
+	u8 monitor_direct;
+	u8 mesh_sta;
+	u8 mec;
+	u8 intra_bss;
+	u32 reserved;
+	struct htt_mac_addr mac_addr;
+};
+
 enum htt_stats_param_type {
 	HTT_STATS_PREAM_OFDM,
 	HTT_STATS_PREAM_CCK,
@@ -747,10 +780,33 @@ struct htt_tx_hwq_txop_used_cnt_hist_tlv
 };
 
 /* == TX SELFGEN STATS == */
+
+enum htt_tx_mumimo_grp_invalid_reason_code_stats {
+	HTT_TX_MUMIMO_GRP_VALID,
+	HTT_TX_MUMIMO_GRP_INVALID_NUM_MU_USERS_EXCEEDED_MU_MAX_USERS,
+	HTT_TX_MUMIMO_GRP_INVALID_SCHED_ALGO_NOT_MU_COMPATIBLE_GID,
+	HTT_TX_MUMIMO_GRP_INVALID_NON_PRIMARY_GRP,
+	HTT_TX_MUMIMO_GRP_INVALID_ZERO_CANDIDATES,
+	HTT_TX_MUMIMO_GRP_INVALID_MORE_CANDIDATES,
+	HTT_TX_MUMIMO_GRP_INVALID_GROUP_SIZE_EXCEED_NSS,
+	HTT_TX_MUMIMO_GRP_INVALID_GROUP_INELIGIBLE,
+	HTT_TX_MUMIMO_GRP_INVALID,
+	HTT_TX_MUMIMO_GRP_INVALID_GROUP_EFF_MU_TPUT_OMBPS,
+	HTT_TX_MUMIMO_GRP_INVALID_MAX_REASON_CODE,
+};
+
 #define HTT_TX_PDEV_STATS_NUM_AC_MUMIMO_USER_STATS    4
 #define HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS    8
 #define HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS       74
 #define HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS    8
+#define HTT_STATS_MAX_MUMIMO_GRP_SZ		      8
+#define HTT_STATS_MUMIMO_TPUT_NUM_BINS 10
+#define HTT_STATS_MAX_INVALID_REASON_CODE \
+	HTT_TX_MUMIMO_GRP_INVALID_MAX_REASON_CODE
+/* Reasons stated in htt_tx_mumimo_grp_invalid_reason_code_stats */
+#define HTT_TX_NUM_MUMIMO_GRP_INVALID_WORDS \
+	(HTT_STATS_MAX_MUMIMO_GRP_SZ * HTT_STATS_MAX_INVALID_REASON_CODE)
+
 struct htt_tx_selfgen_cmn_stats_tlv {
 	u32 mac_id__word;
 	u32 su_bar;
@@ -898,6 +954,18 @@ struct htt_tx_pdev_mu_mimo_sch_stats_tlv
 	u32 ax_ofdma_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
 };
 
+struct htt_tx_pdev_mumimo_grp_stats_tlv {
+	u32 dl_mumimo_grp_best_grp_size[HTT_STATS_MAX_MUMIMO_GRP_SZ];
+	u32 dl_mumimo_grp_best_num_usrs[HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS];
+	u32 dl_mumimo_grp_eligible[HTT_STATS_MAX_MUMIMO_GRP_SZ];
+	u32 dl_mumimo_grp_ineligible[HTT_STATS_MAX_MUMIMO_GRP_SZ];
+	u32 dl_mumimo_grp_invalid[HTT_TX_NUM_MUMIMO_GRP_INVALID_WORDS];
+	u32 dl_mumimo_grp_tputs[HTT_STATS_MUMIMO_TPUT_NUM_BINS];
+	u32 ul_mumimo_grp_best_grp_size[HTT_STATS_MAX_MUMIMO_GRP_SZ];
+	u32 ul_mumimo_grp_best_num_usrs[HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS];
+	u32 ul_mumimo_grp_tputs[HTT_STATS_MUMIMO_TPUT_NUM_BINS];
+};
+
 struct htt_tx_pdev_mu_mimo_mpdu_stats_tlv {
 	u32 mu_mimo_mpdus_queued_usr;
 	u32 mu_mimo_mpdus_tried_usr;
@@ -924,6 +992,29 @@ struct htt_tx_pdev_mu_mimo_mpdu_stats_tl
 	u32 ax_ofdma_ampdu_underrun_usr;
 };
 
+/* [0]- nr4 , [1]- nr8 */
+#define HTT_STATS_NUM_NR_BINS 2
+/* Termination status stated in htt_tx_wal_tx_isr_sched_status */
+#define HTT_STATS_MAX_NUM_SCHED_STATUS  9
+#define HTT_STATS_MAX_NUM_MU_PPDU_PER_BURST 10
+#define HTT_STATS_MAX_NUM_SCHED_STATUS_WORDS \
+	(HTT_STATS_NUM_NR_BINS * HTT_STATS_MAX_NUM_SCHED_STATUS)
+#define HTT_STATS_MAX_MU_PPDU_PER_BURST_WORDS \
+	(HTT_STATS_NUM_NR_BINS * HTT_STATS_MAX_NUM_MU_PPDU_PER_BURST)
+
+enum htt_stats_hw_mode {
+	HTT_STATS_HWMODE_AC = 0,
+	HTT_STATS_HWMODE_AX = 1,
+};
+
+struct htt_tx_pdev_mu_ppdu_dist_stats_tlv_v {
+	u32 hw_mode; /* HTT_STATS_HWMODE_xx */
+	u32 mu_mimo_num_seq_term_status[HTT_STATS_MAX_MU_PPDU_PER_BURST_WORDS];
+	u32 mu_mimo_num_ppdu_completed_per_burst[HTT_STATS_MAX_MU_PPDU_PER_BURST_WORDS];
+	u32 mu_mimo_num_seq_posted[HTT_STATS_NUM_NR_BINS];
+	u32 mu_mimo_num_ppdu_posted_per_burst[HTT_STATS_MAX_MU_PPDU_PER_BURST_WORDS];
+};
+
 #define HTT_STATS_TX_SCHED_MODE_MU_MIMO_AC  1
 #define HTT_STATS_TX_SCHED_MODE_MU_MIMO_AX  2
 #define HTT_STATS_TX_SCHED_MODE_MU_OFDMA_AX 3
@@ -2175,20 +2266,6 @@ enum htt_tx_selfgen_sch_tsflag_error_sta
 	HTT_TX_SELFGEN_SCH_TSFLAG_ERROR_STATS_VALID = 8
 };
 
-enum htt_tx_mumimo_grp_invalid_reason_code_stats {
-	HTT_TX_MUMIMO_GRP_VALID,
-	HTT_TX_MUMIMO_GRP_INVALID_NUM_MU_USERS_EXCEEDED_MU_MAX_USERS,
-	HTT_TX_MUMIMO_GRP_INVALID_SCHED_ALGO_NOT_MU_COMPATIBLE_GID,
-	HTT_TX_MUMIMO_GRP_INVALID_NON_PRIMARY_GRP,
-	HTT_TX_MUMIMO_GRP_INVALID_ZERO_CANDIDATES,
-	HTT_TX_MUMIMO_GRP_INVALID_MORE_CANDIDATES,
-	HTT_TX_MUMIMO_GRP_INVALID_GROUP_SIZE_EXCEED_NSS,
-	HTT_TX_MUMIMO_GRP_INVALID_GROUP_INELIGIBLE,
-	HTT_TX_MUMIMO_GRP_INVALID,
-	HTT_TX_MUMIMO_GRP_INVALID_GROUP_EFF_MU_TPUT_OMBPS,
-	HTT_TX_MUMIMO_GRP_INVALID_MAX_REASON_CODE,
-};
-
 /* 0...13,-2,-1 */
 #define HTT_TX_PDEV_STATS_NUM_BE_MCS_COUNTERS 16
 /* 20,40,80,160,320 MHz */
@@ -2758,4 +2835,429 @@ struct htt_peer_sched_stats_tlv {
 	u32 peer_rx_active_dur_us_high;
 	u32 peer_curr_rate_kbps;
 };
+
+struct htt_vdev_rtt_resp_stats_tlv {
+	/* No of Fine Timing Measurement frames transmitted successfully */
+	u32 tx_ftm_suc;
+	/* No of Fine Timing Measurement frames transmitted successfully after retry */
+	u32 tx_ftm_suc_retry;
+	/* No of Fine Timing Measurement frames not transmitted successfully */
+	u32 tx_ftm_fail;
+	/* No of Fine Timing Measurement Request frames received, including initial,
+	 * non-initial, and duplicates
+	 */
+	u32 rx_ftmr_cnt;
+	/* No of duplicate Fine Timing Measurement Request frames received, including
+	 * both initial and non-initial
+	 */
+	u32 rx_ftmr_dup_cnt;
+	/* No of initial Fine Timing Measurement Request frames received */
+	u32 rx_iftmr_cnt;
+	/* No of duplicate initial Fine Timing Measurement Request frames received */
+	u32 rx_iftmr_dup_cnt;
+	/* No of responder sessions rejected when initiator was active */
+	u32 initiator_active_responder_rejected_cnt;
+	/* Responder terminate count */
+	u32 responder_terminate_cnt;
+	u32 vdev_id;
+};
+
+struct htt_vdev_rtt_init_stats_tlv {
+	u32 vdev_id;
+	/* No of Fine Timing Measurement request frames transmitted successfully */
+	u32 tx_ftmr_cnt;
+	/* No of Fine Timing Measurement request frames not transmitted successfully */
+	u32 tx_ftmr_fail;
+	/* No of Fine Timing Measurement request frames transmitted successfully
+	 * after retry
+	 */
+	u32 tx_ftmr_suc_retry;
+	/* No of Fine Timing Measurement frames received, including initial, non-initial
+	 * and duplicates
+	 */
+	u32 rx_ftm_cnt;
+	/* Initiator Terminate count */
+	u32 initiator_terminate_cnt;
+	u32 tx_meas_req_count;
+};
+
+struct htt_pktlog_and_htt_ring_stats_tlv {
+	/* No of pktlog payloads that were dropped in htt_ppdu_stats path */
+	u32 pktlog_lite_drop_cnt;
+	/* No of pktlog payloads that were dropped in TQM path */
+	u32 pktlog_tqm_drop_cnt;
+	/* No of pktlog ppdu stats payloads that were dropped */
+	u32 pktlog_ppdu_stats_drop_cnt;
+	/* No of pktlog ppdu ctrl payloads that were dropped */
+	u32 pktlog_ppdu_ctrl_drop_cnt;
+	/* No of pktlog sw events payloads that were dropped */
+	u32 pktlog_sw_events_drop_cnt;
+};
+
+#define HTT_DLPAGER_STATS_MAX_HIST            10
+#define HTT_DLPAGER_ASYNC_LOCKED_PAGE_COUNT_M 0x000000FF
+#define HTT_DLPAGER_ASYNC_LOCKED_PAGE_COUNT_S 0
+#define HTT_DLPAGER_SYNC_LOCKED_PAGE_COUNT_M  0x0000FF00
+#define HTT_DLPAGER_SYNC_LOCKED_PAGE_COUNT_S  8
+#define HTT_DLPAGER_TOTAL_LOCKED_PAGES_M      0x0000FFFF
+#define HTT_DLPAGER_TOTAL_LOCKED_PAGES_S      0
+#define HTT_DLPAGER_TOTAL_FREE_PAGES_M        0xFFFF0000
+#define HTT_DLPAGER_TOTAL_FREE_PAGES_S        16
+#define HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_M    0x0000FFFF
+#define HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_S    0
+#define HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_M  0xFFFF0000
+#define HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_S  16
+
+#define HTT_DLPAGER_ASYNC_LOCK_PAGE_COUNT_GET(_var) \
+	(((_var) & HTT_DLPAGER_ASYNC_LOCKED_PAGE_COUNT_M) >> \
+	HTT_DLPAGER_ASYNC_LOCKED_PAGE_COUNT_S)
+
+#define HTT_DLPAGER_ASYNC_LOCK_PAGE_COUNT_SET(_var, _val) \
+	do { \
+		HTT_CHECK_SET_VAL(HTT_DLPAGER_ASYNC_LOCKED_PAGE_COUNT, _val); \
+		((_var) &= ~(HTT_DLPAGER_ASYNC_LOCKED_PAGE_COUNT_M));\
+		((_var) |= ((_val) << HTT_DLPAGER_ASYNC_LOCKED_PAGE_COUNT_S)); \
+	} while (0)
+
+#define HTT_DLPAGER_SYNC_LOCK_PAGE_COUNT_GET(_var) \
+	(((_var) & HTT_DLPAGER_SYNC_LOCKED_PAGE_COUNT_M) >> \
+	HTT_DLPAGER_SYNC_LOCKED_PAGE_COUNT_S)
+
+#define HTT_DLPAGER_SYNC_LOCK_PAGE_COUNT_SET(_var, _val) \
+	do { \
+		HTT_CHECK_SET_VAL(HTT_DLPAGER_SYNC_LOCKED_PAGE_COUNT, _val); \
+		((_var) &= ~(HTT_DLPAGER_SYNC_LOCKED_PAGE_COUNT_M));\
+		((_var) |= ((_val) << HTT_DLPAGER_SYNC_LOCKED_PAGE_COUNT_S)); \
+	} while (0)
+
+#define HTT_DLPAGER_TOTAL_LOCKED_PAGES_GET(_var) \
+	(((_var) & HTT_DLPAGER_TOTAL_LOCKED_PAGES_M) >> \
+	HTT_DLPAGER_TOTAL_LOCKED_PAGES_S)
+
+#define HTT_DLPAGER_TOTAL_LOCKED_PAGES_SET(_var, _val) \
+	do { \
+		HTT_CHECK_SET_VAL(HTT_DLPAGER_TOTAL_LOCKED_PAGES, _val); \
+		((_var) &= ~(HTT_DLPAGER_TOTAL_LOCKED_PAGES_M)); \
+		((_var) |= ((_val) << HTT_DLPAGER_TOTAL_LOCKED_PAGES_S)); \
+	} while (0)
+
+#define HTT_DLPAGER_TOTAL_FREE_PAGES_GET(_var) \
+	(((_var) & HTT_DLPAGER_TOTAL_FREE_PAGES_M) >> \
+	HTT_DLPAGER_TOTAL_FREE_PAGES_S)
+
+#define HTT_DLPAGER_TOTAL_FREE_PAGES_SET(_var, _val) \
+	do { \
+		HTT_CHECK_SET_VAL(HTT_DLPAGER_TOTAL_FREE_PAGES, _val); \
+		((_var) &= ~(HTT_DLPAGER_TOTAL_FREE_PAGES_M)); \
+		((_var) |= ((_val) << HTT_DLPAGER_TOTAL_FREE_PAGES_S)); \
+	} while (0)
+
+#define HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_GET(_var) \
+	(((_var) & HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_M) >> \
+	HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_S)
+
+#define HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_SET(_var, _val) \
+	do { \
+		HTT_CHECK_SET_VAL(HTT_DLPAGER_LAST_LOCKED_PAGE_IDX, _val); \
+		((_var) &= ~(HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_M)); \
+		((_var) |= ((_val) << HTT_DLPAGER_LAST_LOCKED_PAGE_IDX_S)); \
+	} while (0)
+
+#define HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_GET(_var) \
+	(((_var) & HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_M) >> \
+	HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_S)
+
+#define HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_SET(_var, _val) \
+	do { \
+		HTT_CHECK_SET_VAL(HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX, _val); \
+		((_var) &= ~(HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_M)); \
+		((_var) |= ((_val) << HTT_DLPAGER_LAST_UNLOCKED_PAGE_IDX_S)); \
+	} while (0)
+
+enum {
+	HTT_STATS_PAGE_LOCKED = 0,
+	HTT_STATS_PAGE_UNLOCKED = 1,
+	HTT_STATS_NUM_PAGE_LOCK_STATES
+};
+
+struct htt_dl_pager_stats_tlv {
+	/* msg_dword_1 bitfields:
+	 *     async_lock                 : 8,
+	 *     sync_lock                  : 8,
+	 *     reserved                   : 16;
+	 */
+	u32 msg_dword_1;
+	/* mst_dword_2 bitfields:
+	 *     total_locked_pages         : 16,
+	 *     total_free_pages           : 16;
+	 */
+	u32 msg_dword_2;
+	/* msg_dword_3 bitfields:
+	 *     last_locked_page_idx       : 16,
+	 *     last_unlocked_page_idx     : 16;
+	 */
+	u32 msg_dword_3;
+
+	struct {
+		u32 page_num;
+		u32 num_of_pages;
+		/* timestamp is in microsecond units, from SoC timer clock */
+		u32 timestamp_lsbs;
+		u32 timestamp_msbs;
+	} last_pages_info[HTT_STATS_NUM_PAGE_LOCK_STATES][HTT_DLPAGER_STATS_MAX_HIST];
+};
+
+struct htt_stats_error_tlv_v {
+	u32 htt_stats_type;
+};
+
+#define HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS 7
+
+struct htt_tx_selfgen_ac_sched_status_stats_tlv {
+	/* 11AC VHT SU NDPA scheduler completion status reason code */
+	u32 ac_su_ndpa_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AC VHT SU NDP scheduler completion status reason code */
+	u32 ac_su_ndp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AC VHT SU NDP scheduler error code */
+	u32 ac_su_ndp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	/* 11AC VHT MU MIMO NDPA scheduler completion status reason code */
+	u32 ac_mu_mimo_ndpa_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AC VHT MU MIMO NDP scheduler completion status reason code */
+	u32 ac_mu_mimo_ndp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AC VHT MU MIMO NDP scheduler error code */
+	u32 ac_mu_mimo_ndp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	/* 11AC VHT MU MIMO BRPOLL scheduler completion status reason code */
+	u32 ac_mu_mimo_brp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AC VHT MU MIMO BRPOLL scheduler error code */
+	u32 ac_mu_mimo_brp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+};
+
+struct htt_tx_selfgen_ax_sched_status_stats_tlv {
+	/* 11AX HE SU NDPA scheduler completion status reason code */
+	u32 ax_su_ndpa_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AX SU NDP scheduler completion status reason code */
+	u32 ax_su_ndp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AX HE SU NDP scheduler error code */
+	u32 ax_su_ndp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	/* 11AX HE MU MIMO NDPA scheduler completion status reason code */
+	u32 ax_mu_mimo_ndpa_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AX HE MU MIMO NDP scheduler completion status reason code */
+	u32 ax_mu_mimo_ndp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AX HE MU MIMO NDP scheduler error code */
+	u32 ax_mu_mimo_ndp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	/* 11AX HE MU MIMO MU BRPOLL scheduler completion status reason code */
+	u32 ax_mu_brp_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AX HE MU MIMO MU BRPOLL scheduler error code */
+	u32 ax_mu_brp_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	/* 11AX HE MU BAR scheduler completion status reason code */
+	u32 ax_mu_bar_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AX HE MU BAR scheduler error code */
+	u32 ax_mu_bar_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	/* 11AX HE UL OFDMA Basic Trigger scheduler completion status reason code */
+	u32 ax_basic_trig_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AX HE UL OFDMA Basic Trigger scheduler error code */
+	u32 ax_basic_trig_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+	/* 11AX HE UL MUMIMO Basic Trigger scheduler completion status reason code */
+	u32 ax_ulmumimo_trig_sch_status[HTT_TX_PDEV_STATS_NUM_TX_ERR_STATUS];
+	/* 11AX HE UL MUMIMO Basic Trigger scheduler error code */
+	u32 ax_ulmumimo_trig_sch_flag_err[HTT_TX_SELFGEN_NUM_SCH_TSFLAG_ERROR_STATS];
+};
+
+enum htt_stats_rc_mode {
+	HTT_STATS_RC_MODE_DLSU	   = 0,
+	HTT_STATS_RC_MODE_DLMUMIMO = 1,
+};
+
+struct htt_tx_rate_stats_t {
+	u32 ppdus_tried;
+	u32 ppdus_ack_failed;
+	u32 mpdus_tried;
+	u32 mpdus_failed;
+};
+
+struct htt_tx_per_rate_stats_tlv {
+	u32 rc_mode;
+	u32 last_probed_mcs;
+	u32 last_probed_nss;
+	u32 last_probed_bw;
+
+	struct htt_tx_rate_stats_t per_bw[HTT_TX_PDEV_STATS_NUM_BW_COUNTERS];
+	struct htt_tx_rate_stats_t per_nss[HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS];
+	struct htt_tx_rate_stats_t per_mcs[HTT_TX_TXBF_RATE_STATS_NUM_MCS_COUNTERS];
+
+	/** 320MHz extension for PER */
+	struct htt_tx_rate_stats_t per_bw320;
+};
+
+struct htt_tx_pdev_dl_mu_ofdma_sch_stats_tlv {
+	u32 ax_mu_ofdma_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+};
+
+struct htt_tx_pdev_ul_mu_ofdma_sch_stats_tlv {
+	u32 ax_ul_mu_ofdma_basic_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+	u32 ax_ul_mu_ofdma_bsr_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+	u32 ax_ul_mu_ofdma_bar_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+	u32 ax_ul_mu_ofdma_brp_sch_nusers[HTT_TX_PDEV_STATS_NUM_OFDMA_USER_STATS];
+};
+
+struct htt_t2h_soc_txrx_stats_common_tlv {
+	u32 inv_peers_msdu_drop_count_hi;
+	u32 inv_peers_msdu_drop_count_lo;
+};
+
+struct htt_t2h_vdev_txrx_stats_hw_stats_tlv {
+	u32 vdev_id;
+	u32 rx_msdu_byte_cnt_hi;
+	u32 rx_msdu_byte_cnt_lo;
+	u32 rx_msdu_cnt_hi;
+	u32 rx_msdu_cnt_lo;
+	u32 tx_msdu_byte_cnt_hi;
+	u32 tx_msdu_byte_cnt_lo;
+	u32 tx_msdu_cnt_hi;
+	u32 tx_msdu_cnt_lo;
+	u32 tx_msdu_excessive_retry_discard_cnt_hi;
+	u32 tx_msdu_excessive_retry_discard_cnt_lo;
+	u32 tx_msdu_cong_ctrl_drop_cnt_hi;
+	u32 tx_msdu_cong_ctrl_drop_cnt_lo;
+	u32 tx_msdu_ttl_expire_drop_cnt_hi;
+	u32 tx_msdu_ttl_expire_drop_cnt_lo;
+};
+
+struct htt_tx_pdev_dl_mu_mimo_sch_stats_tlv {
+	/* Number of MU MIMO schedules posted to HW */
+	u32 mu_mimo_sch_posted;
+	/* Number of MU MIMO schedules failed to post */
+	u32 mu_mimo_sch_failed;
+	/* Number of MU MIMO PPDUs posted to HW */
+	u32 mu_mimo_ppdu_posted;
+	/*
+	 * This is the common description for the below sch stats.
+	 * Counts the number of transmissions of each number of MU users
+	 * in each TX mode.
+	 * The array index is the "number of users - 1".
+	 * For example, ac_mu_mimo_sch_nusers[1] counts the number of 11AC MU2
+	 * TX PPDUs, ac_mu_mimo_sch_nusers[2] counts the number of 11AC MU3
+	 * TX PPDUs and so on.
+	 * The same is applicable for the other TX mode stats.
+	 */
+	/* Represents the count for 11AC DL MU MIMO sequences */
+	u32 ac_mu_mimo_sch_nusers[HTT_TX_PDEV_STATS_NUM_AC_MUMIMO_USER_STATS];
+	/* Represents the count for 11AX DL MU MIMO sequences */
+	u32 ax_mu_mimo_sch_nusers[HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS];
+	/* Number of 11AC DL MU MIMO schedules posted per group size */
+	u32 ac_mu_mimo_sch_posted_per_grp_sz[HTT_TX_PDEV_STATS_NUM_AC_MUMIMO_USER_STATS];
+	/* Number of 11AX DL MU MIMO schedules posted per group size */
+	u32 ax_mu_mimo_sch_posted_per_grp_sz[HTT_TX_PDEV_STATS_NUM_AX_MUMIMO_USER_STATS];
+};
+
+struct htt_tx_pdev_ul_mu_mimo_sch_stats_tlv {
+	/* Represents the count for 11AX UL MU MIMO sequences with Basic Triggers */
+	u32 ax_ul_mu_mimo_basic_sch_nusers[HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS];
+	/* Represents the count for 11AX UL MU MIMO sequences with BRP Triggers */
+	u32 ax_ul_mu_mimo_brp_sch_nusers[HTT_TX_PDEV_STATS_NUM_UL_MUMIMO_USER_STATS];
+};
+
+/* UL RESP Queues 0 - HIPRI, 1 - LOPRI & 2 - BSR */
+#define HTT_STA_UL_OFDMA_NUM_UL_QUEUES 3
+
+/* Actual resp type sent by STA for trigger
+ * 0 - HE TB PPDU, 1 - NULL Delimiter
+ */
+#define HTT_STA_UL_OFDMA_NUM_RESP_END_TYPE 2
+
+/* Counter for MCS 0-13 */
+#define HTT_STA_UL_OFDMA_NUM_MCS_COUNTERS 14
+
+/* Counters BW 20,40,80,160,320 */
+#define HTT_STA_UL_OFDMA_NUM_BW_COUNTERS 5
+
+/* 0 - Half, 1 - Quarter */
+#define HTT_STA_UL_OFDMA_NUM_REDUCED_CHAN_TYPES 2
+
+#define HTT_NUM_AC_WMM	0x4
+
+enum HTT_STA_UL_OFDMA_RX_TRIG_TYPE {
+	HTT_ULTRIG_QBOOST_TRIGGER = 0,
+	HTT_ULTRIG_PSPOLL_TRIGGER,
+	HTT_ULTRIG_UAPSD_TRIGGER,
+	HTT_ULTRIG_11AX_TRIGGER,
+	HTT_ULTRIG_11AX_WILDCARD_TRIGGER,
+	HTT_ULTRIG_11AX_UNASSOC_WILDCARD_TRIGGER,
+	HTT_STA_UL_OFDMA_NUM_TRIG_TYPE,
+};
+
+enum HTT_STA_UL_OFDMA_11AX_TRIG_TYPE {
+	HTT_11AX_TRIGGER_BASIC_E		= 0,
+	HTT_11AX_TRIGGER_BRPOLL_E		= 1,
+	HTT_11AX_TRIGGER_MU_BAR_E		= 2,
+	HTT_11AX_TRIGGER_MU_RTS_E		= 3,
+	HTT_11AX_TRIGGER_BUFFER_SIZE_E		= 4,
+	HTT_11AX_TRIGGER_GCR_MU_BAR_E		= 5,
+	HTT_11AX_TRIGGER_BQRP_E			= 6,
+	HTT_11AX_TRIGGER_NDP_FB_REPORT_POLL_E	= 7,
+	HTT_11AX_TRIGGER_RESERVED_8_E		= 8,
+	HTT_11AX_TRIGGER_RESERVED_9_E		= 9,
+	HTT_11AX_TRIGGER_RESERVED_10_E		= 10,
+	HTT_11AX_TRIGGER_RESERVED_11_E		= 11,
+	HTT_11AX_TRIGGER_RESERVED_12_E		= 12,
+	HTT_11AX_TRIGGER_RESERVED_13_E		= 13,
+	HTT_11AX_TRIGGER_RESERVED_14_E		= 14,
+	HTT_11AX_TRIGGER_RESERVED_15_E		= 15,
+	HTT_STA_UL_OFDMA_NUM_11AX_TRIG_TYPE,
+};
+
+struct htt_print_sta_ul_ofdma_stats_tlv {
+	u32 pdev_id;
+	/* Trigger Type reported by HWSCH on RX reception
+	 * Each index populate enum HTT_STA_UL_OFDMA_RX_TRIG_TYPE
+	 */
+	u32 rx_trigger_type[HTT_STA_UL_OFDMA_NUM_TRIG_TYPE];
+	/* 11AX Trigger Type on RX reception
+	 * Each index populate enum HTT_STA_UL_OFDMA_11AX_TRIG_TYPE
+	 */
+	u32 ax_trigger_type[HTT_STA_UL_OFDMA_NUM_11AX_TRIG_TYPE];
+	/* Num data PPDUs/Delims responded to trigs. per HWQ for UL RESP */
+	u32 num_data_ppdu_responded_per_hwq[HTT_STA_UL_OFDMA_NUM_UL_QUEUES];
+	u32 num_null_delimiters_responded_per_hwq[HTT_STA_UL_OFDMA_NUM_UL_QUEUES];
+	/* Overall UL STA RESP Status 0 - HE TB PPDU, 1 - NULL Delimiter
+	 * Super set of num_data_ppdu_responded_per_hwq,
+	 * num_null_delimiters_responded_per_hwq
+	 */
+	u32 num_total_trig_responses[HTT_STA_UL_OFDMA_NUM_RESP_END_TYPE];
+	/* Time interval between current time ms and last successful trigger RX
+	 * 0xFFFFFFFF denotes no trig received / timestamp roll back
+	 */
+	u32 last_trig_rx_time_delta_ms;
+	/* Rate Statistics for UL OFDMA
+	 * UL TB PPDU TX MCS, NSS, GI, BW from STA HWQ
+	 */
+	u32 ul_ofdma_tx_mcs[HTT_STA_UL_OFDMA_NUM_MCS_COUNTERS];
+	u32 ul_ofdma_tx_nss[HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS];
+	u32 ul_ofdma_tx_gi[HTT_TX_PDEV_STATS_NUM_GI_COUNTERS]
+			  [HTT_STA_UL_OFDMA_NUM_MCS_COUNTERS];
+	u32 ul_ofdma_tx_ldpc;
+	u32 ul_ofdma_tx_bw[HTT_STA_UL_OFDMA_NUM_BW_COUNTERS];
+
+	/* Trig based PPDU TX/ RBO based PPDU TX Count */
+	u32 trig_based_ppdu_tx;
+	u32 rbo_based_ppdu_tx;
+	/* Switch MU EDCA to SU EDCA Count */
+	u32 mu_edca_to_su_edca_switch_count;
+	/* Num MU EDCA applied Count */
+	u32 num_mu_edca_param_apply_count;
+
+	/* Current MU EDCA Parameters for WMM ACs
+	 * Mode - 0 - SU EDCA, 1- MU EDCA
+	 */
+	u32 current_edca_hwq_mode[HTT_NUM_AC_WMM];
+	/* Contention Window minimum. Range: 1 - 10 */
+	u32 current_cw_min[HTT_NUM_AC_WMM];
+	/* Contention Window maximum. Range: 1 - 10 */
+	u32 current_cw_max[HTT_NUM_AC_WMM];
+	/* AIFS value - 0 -255 */
+	u32 current_aifs[HTT_NUM_AC_WMM];
+	u32 reduced_ul_ofdma_tx_bw[HTT_STA_UL_OFDMA_NUM_REDUCED_CHAN_TYPES]
+				  [HTT_STA_UL_OFDMA_NUM_BW_COUNTERS];
+};
+
 #endif
