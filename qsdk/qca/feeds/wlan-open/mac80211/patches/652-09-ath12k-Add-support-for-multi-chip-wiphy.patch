From 8fe0063cde2e7874678589015ba3b0f283213748 Mon Sep 17 00:00:00 2001
From: Sriram R <quic_srirrama@quicinc.com>
Date: Fri, 31 Dec 2021 15:09:19 +0530
Subject: [PATCH 10/10] ath12k: Add support for multi chip wiphy

Similar to combining multiple links(ar) of
the soc(ab) into single wiphy, support for
combining multiple soc(ab) and advertising them
as a composite wiphy is supported with this change.

Decision to group multiple soc info into single
wiphy is based on dt info obtained during device
probe. If no such info is available only single
chip will be represented in wiphy, else multiple
chips advertised in the dt are combined. Currently
only a single group is supported where multiple
chips are part of this group.

Co-developed-by: Bhagavathi Perumal S <quic_bperumal@quicinc.com>
Signed-off-by: Bhagavathi Perumal S <quic_bperumal@quicinc.com>
Co-developed-by: Karthikeyan Periyasamy <quic_periyasa@quicinc.com>
Signed-off-by: Karthikeyan Periyasamy <quic_periyasa@quicinc.com>
Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/core.c    | 348 ++++++++++++++++++++++++------
 drivers/net/wireless/ath/ath12k/core.h    |  13 ++
 drivers/net/wireless/ath/ath12k/mac.c     | 234 ++++++++++++--------
 drivers/net/wireless/ath/ath12k/mac.h     |   9 +-
 drivers/net/wireless/ath/ath12k/reg.c     |   9 +-
 drivers/net/wireless/ath/ath12k/reg.h     |   3 +-
 drivers/net/wireless/ath/ath12k/thermal.c |   8 +-
 7 files changed, 459 insertions(+), 165 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -31,6 +31,192 @@ module_param_named(frame_mode, ath12k_fr
 MODULE_PARM_DESC(frame_mode,
 		 "Datapath frame mode (0: raw, 1: native wifi (default), 2: ethernet)");
 
+static DEFINE_MUTEX(ath12k_hw_lock);
+static struct list_head ath12k_hw_groups = LIST_HEAD_INIT(ath12k_hw_groups);
+
+/* This function needs to be used only when dt has multi chip grouping information */
+static struct ath12k_hw_group *ath12k_core_hw_group_find_by_id(u8 group_id)
+{
+	struct ath12k_hw_group *ag;
+
+	lockdep_assert_held(&ath12k_hw_lock);
+
+	/* group ids will be unique only for multi chip group */
+	list_for_each_entry(ag, &ath12k_hw_groups, list) {
+		if (group_id == ag->id && ag->num_chip > 1)
+			return ag;
+	}
+
+	return NULL;
+}
+
+static void ath12k_core_hw_group_free(struct ath12k_hw_group *ag)
+{
+	mutex_lock(&ath12k_hw_lock);
+
+	list_del(&ag->list);
+	kfree(ag);
+
+	mutex_unlock(&ath12k_hw_lock);
+}
+
+static void __ath12k_core_put_hw_group(struct ath12k_base *ab)
+{
+	struct ath12k_hw_group *ag = ab->ag;
+	u8 chip_id = ab->chip_id;
+
+	if (!ag)
+		return;
+
+	lockdep_assert_held(&ag->mutex_lock);
+
+	if (chip_id >= ag->num_chip) {
+		ath12k_err(ab, "failed to put Invalid chip id %d in the group id %d max chip %d\n",
+			   chip_id, ag->id, ag->num_chip);
+
+		return;
+	}
+
+	if (ag->ab[chip_id] != ab) {
+		ath12k_err(ab, "failed to put chip id %d in the group id %d\n",
+			   chip_id, ag->id);
+
+		return;
+	}
+
+	ag->ab[chip_id] = NULL;
+	ab->ag = NULL;
+	ab->chip_id = ATH12K_INVALID_CHIP_ID;
+
+	if (ag->num_probed)
+		ag->num_probed--;
+
+	if (!ag->num_probed)
+		ath12k_core_hw_group_free(ag);
+}
+
+void ath12k_core_put_hw_group(struct ath12k_base *ab)
+{
+	struct ath12k_hw_group *ag = ab->ag;
+
+	mutex_lock(&ag->mutex_lock);
+	__ath12k_core_put_hw_group(ab);
+	mutex_unlock(&ag->mutex_lock);
+}
+
+static struct ath12k_hw_group *
+ath12k_core_hw_group_alloc(u8 id, u8 max_chip)
+{
+	struct ath12k_hw_group *ag = NULL;
+
+	lockdep_assert_held(&ath12k_hw_lock);
+
+	ag = kzalloc(sizeof(*ag), GFP_KERNEL);
+	if (!ag)
+		return NULL;
+
+	ag->id = id;
+	ag->num_chip = max_chip;
+	list_add(&ag->list, &ath12k_hw_groups);
+	mutex_init(&ag->mutex_lock);
+
+	return ag;
+}
+
+static struct ath12k_hw_group *ath12k_core_get_hw_group(struct ath12k_base *ab)
+{
+	struct ath12k_hw_group *ag = NULL;
+	struct device_node *mlo = NULL;
+	struct device *dev = ab->dev;
+	u32 group_id, num_chips;
+	int ret;
+
+	lockdep_assert_held(&ath12k_hw_lock);
+
+	/* If there is no grouping info in the dt, we don't enalbe
+	 * multi soc hw grouping and registration, rather the single
+	 * soc is added to hw group and based on the number of links
+	 * within the soc, all links are combined into a single wiphy.
+	 */
+	mlo = of_parse_phandle(dev->of_node, "qcom,wsi", 0);
+	if (!mlo) {
+		group_id = ATH12K_INVALID_GRP_ID;
+	} else {
+		ret = of_property_read_u32(mlo, "id", &group_id);
+		if (ret)
+			group_id = ATH12K_INVALID_GRP_ID;
+	}
+
+again:
+	if (group_id == ATH12K_INVALID_GRP_ID) {
+		ath12k_info(ab, "Grouping of multiple SoC not done\n");
+
+		ag = ath12k_core_hw_group_alloc(group_id, 1);
+	} else {
+		if (of_property_read_u32(mlo, "num_chip", &num_chips)) {
+			ath12k_err(ab, "num_chip is not configured\n");
+			group_id = ATH12K_INVALID_GRP_ID;
+			goto again;
+		}
+
+		if (num_chips > ATH12K_MAX_SOCS) {
+			ath12k_warn(ab, "num_chip advertised %d is more than limit %d\n",
+				    num_chips, ATH12K_MAX_SOCS);
+			group_id = ATH12K_INVALID_GRP_ID;
+			goto again;
+		}
+
+		/* currently only one group of multiple socs are supported,
+		 * since we use group id ATH12K_INVALID_GRP_ID for single
+		 * chip group which didn't have dt entry, there could be many
+		 * groups with same group id, i.e ATH12K_INVALID_GRP_ID. So
+		 * default group id of ATH12K_INVALID_GRP_ID combined with
+		 * num chips in ath12k_hw_group determines if the group is
+		 * multisoc or single soc group
+		 */
+		ag = ath12k_core_hw_group_find_by_id(group_id);
+		if (!ag) {
+			ag = ath12k_core_hw_group_alloc(group_id, num_chips);
+			if (!ag) {
+				ath12k_warn(ab, "unable to create new hw group\n");
+				return NULL;
+			}
+		} else if (test_bit(ATH12K_FLAG_UNREGISTERING, &ag->dev_flags)) {
+			ath12k_dbg(ab, ATH12K_DBG_BOOT, "group id %d in unregister state\n",
+				   ag->id);
+			group_id = ATH12K_INVALID_GRP_ID;
+			goto again;
+		}
+	}
+
+	if (ag->num_probed >= ag->num_chip) {
+		ath12k_warn(ab, "unable to add new chip to group, max limit reached\n");
+		group_id = ATH12K_INVALID_GRP_ID;
+		goto again;
+	}
+
+	ab->chip_id = ag->num_probed;
+	ag->ab[ag->num_probed++] = ab;
+	ab->ag = ag;
+	return ag;
+}
+
+static inline
+bool ath12k_core_hw_group_create_ready(struct ath12k_hw_group *ag)
+{
+	lockdep_assert_held(&ag->mutex_lock);
+
+	return (ag->num_probed == ag->num_chip);
+}
+
+static inline
+bool ath12k_core_hw_group_start_ready(struct ath12k_hw_group *ag)
+{
+	lockdep_assert_held(&ag->mutex_lock);
+
+	return (ag->num_started == ag->num_chip);
+}
+
 int ath12k_core_suspend(struct ath12k_base *ab)
 {
 	int ret;
@@ -414,6 +600,11 @@ success:
 
 static void ath12k_core_stop(struct ath12k_base *ab)
 {
+	lockdep_assert_held(&ab->ag->mutex_lock);
+	lockdep_assert_held(&ab->core_lock);
+
+	ab->ag->num_started--;
+
 	if (!test_bit(ATH12K_FLAG_CRASH_FLUSH, &ab->dev_flags))
 		ath12k_qmi_firmware_stop(ab);
 
@@ -434,22 +625,14 @@ static int ath12k_core_soc_create(struct
 		return ret;
 	}
 
-	ret = ath12k_debugfs_soc_create(ab);
-	if (ret) {
-		ath12k_err(ab, "failed to create ath12k debugfs\n");
-		goto err_qmi_deinit;
-	}
-
 	ret = ath12k_hif_power_up(ab);
 	if (ret) {
 		ath12k_err(ab, "failed to power up :%d\n", ret);
-		goto err_debugfs_reg;
+		goto err_qmi_deinit;
 	}
 
 	return 0;
 
-err_debugfs_reg:
-	ath12k_debugfs_soc_destroy(ab);
 err_qmi_deinit:
 	ath12k_qmi_deinit_service(ab);
 	return ret;
@@ -457,39 +640,20 @@ err_qmi_deinit:
 
 static void ath12k_core_soc_destroy(struct ath12k_base *ab)
 {
-	ath12k_debugfs_soc_destroy(ab);
 	ath12k_dp_free(ab);
 	ath12k_reg_free(ab);
 	ath12k_qmi_deinit_service(ab);
 }
 
-static int ath12k_core_pdev_create(struct ath12k_base *ab)
+static int ath12k_core_pdev_init(struct ath12k_base *ab)
 {
 	int ret;
 
-	ret = ath12k_debugfs_pdev_create(ab);
-	if (ret) {
-		ath12k_err(ab, "failed to create core pdev debugfs: %d\n", ret);
-		return ret;
-	}
-
-	ret = ath12k_dp_pdev_alloc(ab);
-	if (ret) {
-		ath12k_err(ab, "failed to attach DP pdev: %d\n", ret);
-		goto err_pdev_debug;
-	}
-
-	ret = ath12k_mac_register(ab);
-	if (ret) {
-		ath12k_err(ab, "failed register the radio with mac80211: %d\n", ret);
-		goto err_dp_pdev_free;
-	}
-
 	ret = ath12k_thermal_register(ab);
 	if (ret) {
 		ath12k_err(ab, "could not register thermal device: %d\n",
 			   ret);
-		goto err_mac_unregister;
+		return ret;
 	}
 
 	ret = ath12k_spectral_init(ab);
@@ -502,11 +666,36 @@ static int ath12k_core_pdev_create(struc
 
 err_thermal_unregister:
 	ath12k_thermal_unregister(ab);
-err_mac_unregister:
-	ath12k_mac_unregister(ab);
-err_dp_pdev_free:
-	ath12k_dp_pdev_free(ab);
-err_pdev_debug:
+	return ret;
+}
+
+static void ath12k_core_pdev_deinit(struct ath12k_base *ab)
+{
+	ath12k_spectral_deinit(ab);
+	ath12k_thermal_unregister(ab);
+}
+
+static int ath12k_core_pdev_create(struct ath12k_base *ab)
+{
+	int ret;
+
+	ret = ath12k_debugfs_pdev_create(ab);
+	if (ret) {
+		ath12k_err(ab, "failed to create core pdev debugfs: %d\n", ret);
+		/* Free any previously allocated ab info */
+		return ret;
+	}
+
+	ret = ath12k_dp_pdev_alloc(ab);
+	if (ret) {
+		ath12k_err(ab, "failed to attach DP pdev: %d\n", ret);
+		/* Free current debugfs and any previously allocated info */
+		goto err_debugfs_pdev;
+	}
+
+	return 0;
+
+err_debugfs_pdev:
 	ath12k_debugfs_pdev_destroy(ab);
 
 	return ret;
@@ -514,10 +703,6 @@ err_pdev_debug:
 
 static void ath12k_core_pdev_destroy(struct ath12k_base *ab)
 {
-	ath12k_spectral_deinit(ab);
-	ath12k_thermal_unregister(ab);
-	ath12k_mac_unregister(ab);
-	ath12k_hif_irq_disable(ab);
 	ath12k_dp_pdev_free(ab);
 	ath12k_debugfs_pdev_destroy(ab);
 }
@@ -527,6 +712,9 @@ static int ath12k_core_start(struct ath1
 {
 	int ret;
 
+	lockdep_assert_held(&ab->ag->mutex_lock);
+	lockdep_assert_held(&ab->core_lock);
+
 	ret = ath12k_wmi_attach(ab);
 	if (ret) {
 		ath12k_err(ab, "failed to attach wmi: %d\n", ret);
@@ -578,32 +766,23 @@ static int ath12k_core_start(struct ath1
 
 	ath12k_dp_cc_config(ab);
 
-	ath12k_dp_pdev_pre_alloc(ab);
-
 	ret = ath12k_dp_rx_pdev_reo_setup(ab);
 	if (ret) {
 		ath12k_err(ab, "failed to initialize reo destination rings: %d\n", ret);
 		goto err_hif_stop;
 	}
 
-	ret = ath12k_mac_allocate(ab);
-	if (ret) {
-		ath12k_err(ab, "failed to create new hw device with mac80211 :%d\n",
-			   ret);
-		goto err_reo_cleanup;
-	}
-
 	ret = ath12k_wmi_cmd_init(ab);
 	if (ret) {
 		ath12k_err(ab, "failed to send wmi init cmd: %d\n", ret);
-		goto err_mac_destroy;
+		goto err_reo_cleanup;
 	}
 
 	ret = ath12k_wmi_wait_for_unified_ready(ab);
 	if (ret) {
 		ath12k_err(ab, "failed to receive wmi unified ready event: %d\n",
 			   ret);
-		goto err_mac_destroy;
+		goto err_reo_cleanup;
 	}
 
 	/* put hardware to DBS mode */
@@ -611,7 +790,7 @@ static int ath12k_core_start(struct ath1
 		ret = ath12k_wmi_set_hw_mode(ab, WMI_HOST_HW_MODE_DBS);
 		if (ret) {
 			ath12k_err(ab, "failed to send dbs mode: %d\n", ret);
-			goto err_mac_destroy;
+			goto err_reo_cleanup;
 		}
 	}
 
@@ -619,13 +798,16 @@ static int ath12k_core_start(struct ath1
 	if (ret) {
 		ath12k_err(ab, "failed to send htt version request message: %d\n",
 			   ret);
-		goto err_mac_destroy;
+		goto err_reo_cleanup;
 	}
 
+	if (!test_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags)) {
+		/* Indicate the core start in the appropriate group */
+		ab->ag->num_started++;
+ 	}
+
 	return 0;
 
-err_mac_destroy:
-	ath12k_mac_destroy(ab);
 err_reo_cleanup:
 	ath12k_dp_rx_pdev_reo_cleanup(ab);
 err_hif_stop:
@@ -635,6 +817,110 @@ err_wmi_detach:
 	return ret;
 }
 
+static int ath12k_core_hw_group_start(struct ath12k_hw_group *ag)
+{
+	struct ath12k_base *ab = ag->ab[0];
+	int ret, i;
+	bool is_registered = false;
+
+	lockdep_assert_held(&ag->mutex_lock);
+
+	/* Check If already registered or not, since same flow
+	 * execute for HW restart case.
+	 */
+	if (test_bit(ATH12K_FLAG_REGISTERED, &ag->dev_flags))
+		is_registered = true;
+
+	if (!is_registered) {
+		ret = ath12k_mac_allocate(ag);
+		if (ret) {
+			ath12k_err(ab, "failed to create new hw device with mac80211 :%d\n",
+				   ret);
+			return ret;
+		}
+	}
+
+	for (i = 0; i < ag->num_chip; i++) {
+		ab = ag->ab[i];
+
+		mutex_lock(&ab->core_lock);
+		ret = ath12k_core_pdev_create(ab);
+		if (ret) {
+			mutex_unlock(&ab->core_lock);
+			ath12k_err(ab, "failed to create pdev core %d\n", ret);
+			goto err_pdev_destroy;
+		}
+		mutex_unlock(&ab->core_lock);
+	}
+
+	if (!is_registered) {
+		ret = ath12k_mac_register(ag);
+		if (ret) {
+			ath12k_err(ab, "failed register the radio with mac80211: %d\n", ret);
+			goto err_pdev_destroy;
+		}
+	}
+
+	/* Setup pdev features for all ab */
+	for (i = 0; i < ag->num_chip; i++) {
+		ab = ag->ab[i];
+
+		mutex_lock(&ab->core_lock);
+
+		ret = ath12k_core_pdev_init(ab);
+		if (ret) {
+			mutex_unlock(&ab->core_lock);
+			ath12k_err(ab, "failed to init pdev features\n");
+			goto pdev_cleanup;
+		}
+		ath12k_hif_irq_enable(ab);
+
+		ath12k_config_qdss(ab);
+
+		ret = ath12k_enable_fwlog(ab);
+		if (ret < 0) {
+			mutex_unlock(&ab->core_lock);
+			ath12k_err(ab, "failed to enable fwlog: %d\n", ret);
+			goto pdev_cleanup;
+		}
+
+		set_bit(ATH12K_FLAG_REGISTERED, &ab->dev_flags);
+
+		mutex_unlock(&ab->core_lock);
+	}
+
+	if (!is_registered)
+		set_bit(ATH12K_FLAG_REGISTERED, &ag->dev_flags);
+
+	return 0;
+
+pdev_cleanup:
+	for (i = i - 1; i >= 0; i--) {
+		ab = ag->ab[i];
+
+		mutex_lock(&ab->core_lock);
+
+		ath12k_core_pdev_deinit(ab);
+		ath12k_hif_irq_disable(ab);
+
+		mutex_unlock(&ab->core_lock);
+	}
+
+	ath12k_mac_unregister(ag);
+	i = ag->num_chip;
+err_pdev_destroy:
+	for (i = i - 1; i >= 0; i--) {
+		ab = ag->ab[i];
+
+		mutex_lock(&ab->core_lock);
+		ath12k_core_pdev_destroy(ab);
+		mutex_unlock(&ab->core_lock);
+	}
+
+	ath12k_mac_destroy(ag);
+ 	return ret;
+}
+
 static int ath12k_core_start_firmware(struct ath12k_base *ab,
 				      enum ath12k_firmware_mode mode)
 {
@@ -654,6 +940,7 @@ static int ath12k_core_start_firmware(st
 
 int ath12k_core_qmi_firmware_ready(struct ath12k_base *ab)
 {
+	struct ath12k_hw_group *ag;
 	int ret;
 
 	ret = ath12k_core_start_firmware(ab, ATH12K_FIRMWARE_MODE_NORMAL);
@@ -691,36 +978,44 @@ int ath12k_core_qmi_firmware_ready(struc
 	if (ath12k_frame_mode == ATH12K_HW_TXRX_RAW)
 		set_bit(ATH12K_FLAG_RAW_MODE, &ab->dev_flags);
 
+	ag = ab->ag;
+
+	mutex_lock(&ag->mutex_lock);
 	mutex_lock(&ab->core_lock);
+
+	/* This should be the last function, add core related
+	 * initializations within this function
+	 */
 	ret = ath12k_core_start(ab, ATH12K_FIRMWARE_MODE_NORMAL);
 	if (ret) {
 		ath12k_err(ab, "failed to start core: %d\n", ret);
 		goto err_dp_free;
 	}
 
-	ret = ath12k_core_pdev_create(ab);
-	if (ret) {
-		ath12k_err(ab, "failed to create pdev core: %d\n", ret);
-		goto err_core_stop;
-	}
-	ath12k_hif_irq_enable(ab);
+	mutex_unlock(&ab->core_lock);
 
-	ath12k_config_qdss(ab);
+	if (ath12k_core_hw_group_start_ready(ag)) {
+		ret = ath12k_core_hw_group_start(ag);
+		if (ret) {
+			ath12k_warn(ab, "unable to start hw group\n");
+			goto err_core_stop;
+		}
 
-	ret = ath12k_enable_fwlog(ab);
-	if (ret < 0)
-		ath12k_err(ab, "failed to enable fwlog: %d\n", ret);
+		ath12k_dbg(ab, ATH12K_DBG_BOOT, "group %d started\n", ag->id);
+	}
 
-	mutex_unlock(&ab->core_lock);
+	mutex_unlock(&ag->mutex_lock);
 
+	/* Add code here carefully */
 	return 0;
 
 err_core_stop:
+	mutex_lock(&ab->core_lock);
 	ath12k_core_stop(ab);
-	ath12k_mac_destroy(ab);
 err_dp_free:
 	ath12k_dp_free(ab);
 	mutex_unlock(&ab->core_lock);
+	mutex_unlock(&ag->mutex_lock);
 err_firmware_stop:
 	ath12k_qmi_firmware_stop(ab);
 
@@ -732,10 +1027,9 @@ static int ath12k_core_reconfigure_on_cr
 	int ret;
 
 	mutex_lock(&ab->core_lock);
-	ath12k_thermal_unregister(ab);
+	ath12k_core_pdev_deinit(ab);
 	ath12k_hif_irq_disable(ab);
 	ath12k_dp_pdev_free(ab);
-	ath12k_spectral_deinit(ab);
 	ath12k_hif_stop(ab);
 	ath12k_wmi_detach(ab);
 	ath12k_dp_rx_pdev_reo_cleanup(ab);
@@ -788,102 +1082,109 @@ void ath12k_core_halt(struct ath12k *ar)
 static void ath12k_core_restart(struct work_struct *work)
 {
 	struct ath12k_base *ab = container_of(work, struct ath12k_base, restart_work);
+	struct ath12k_hw_group *ag = ab->ag;
 	int ret;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
 	struct ath12k_vif *arvif;
-	int i;
+	int i, j;
 
 	spin_lock_bh(&ab->base_lock);
 	ab->stats.fw_crash_counter++;
 	spin_unlock_bh(&ab->base_lock);
 
-	ieee80211_stop_queues(ab->ah->hw);
+	ieee80211_stop_queues(ag->ah->hw);
 
-	for (i = 0; i < ab->num_radios; i++) {
-		pdev = &ab->pdevs[i];
-		ar = pdev->ar;
-		if (!ar || ar->state == ATH12K_STATE_OFF)
-			continue;
-
-		list_for_each_entry(arvif, &ar->arvifs, list) {
-			if (arvif->is_started) {
-				ath12k_debugfs_remove_interface(arvif);
+	for (i = 0; i < ag->num_chip; i++) {
+		ab = ag->ab[i];
+
+		for (j = 0; j < ab->num_radios; j++) {
+			pdev = &ab->pdevs[j];
+			ar = pdev->ar;
+			if (!ar || ar->state == ATH12K_STATE_OFF)
+				continue;
+
+			list_for_each_entry(arvif, &ar->arvifs, list) {
+				if (arvif->is_started) {
+					ath12k_debugfs_remove_interface(arvif);
+				}
 			}
+
+			ath12k_mac_drain_tx(ar);
+			complete(&ar->scan.started);
+			complete(&ar->scan.completed);
+			complete(&ar->peer_assoc_done);
+			complete(&ar->peer_delete_done);
+			complete(&ar->install_key_done);
+			complete(&ar->vdev_setup_done);
+			complete(&ar->vdev_delete_done);
+			complete(&ar->bss_survey_done);
+			complete(&ar->thermal.wmi_sync);
+
+			wake_up(&ar->dp.tx_empty_waitq);
+			idr_for_each(&ar->txmgmt_idr,
+				     ath12k_mac_tx_mgmt_pending_free, ar);
+			idr_destroy(&ar->txmgmt_idr);
+			wake_up(&ar->txmgmt_empty_waitq);
+
+			ar->monitor_vdev_id = -1;
+			clear_bit(MONITOR_VDEV_STARTED, &ar->monitor_flags);
+			clear_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags);
 		}
 
-		ath12k_mac_drain_tx(ar);
-		complete(&ar->scan.started);
-		complete(&ar->scan.completed);
-		complete(&ar->peer_assoc_done);
-		complete(&ar->peer_delete_done);
-		complete(&ar->install_key_done);
-		complete(&ar->vdev_setup_done);
-		complete(&ar->vdev_delete_done);
-		complete(&ar->bss_survey_done);
-		complete(&ar->thermal.wmi_sync);
-
-		wake_up(&ar->dp.tx_empty_waitq);
-		idr_for_each(&ar->txmgmt_idr,
-			     ath12k_mac_tx_mgmt_pending_free, ar);
-		idr_destroy(&ar->txmgmt_idr);
-		wake_up(&ar->txmgmt_empty_waitq);
-
-		ar->monitor_vdev_id = -1;
-		clear_bit(MONITOR_VDEV_STARTED, &ar->monitor_flags);
-		clear_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags);
-	}
+		wake_up(&ab->wmi_ab.tx_credits_wq);
+		wake_up(&ab->peer_mapping_wq);
 
-	wake_up(&ab->wmi_ab.tx_credits_wq);
-	wake_up(&ab->peer_mapping_wq);
 
+		ret = ath12k_core_reconfigure_on_crash(ab);
+		if (ret) {
+			ath12k_err(ab, "failed to reconfigure driver on crash recovery\n");
+			return;
+		}
 
-	ret = ath12k_core_reconfigure_on_crash(ab);
-	if (ret) {
-		ath12k_err(ab, "failed to reconfigure driver on crash recovery\n");
-		return;
-	}
+		for (j = 0; j < ab->num_radios; j++) {
+			pdev = &ab->pdevs[j];
+			ar = pdev->ar;
+			if (!ar || ar->state == ATH12K_STATE_OFF)
+				continue;
+
+			mutex_lock(&ar->conf_mutex);
+
+			switch (ar->state) {
+			case ATH12K_STATE_ON:
+				ar->state = ATH12K_STATE_RESTARTING;
+				ath12k_core_halt(ar);
+				break;
+			case ATH12K_STATE_OFF:
+				ath12k_warn(ab,
+					    "cannot restart radio %d that hasn't been started\n",
+					    j);
+				break;
+			case ATH12K_STATE_RESTARTING:
+				break;
+			case ATH12K_STATE_RESTARTED:
+				ar->state = ATH12K_STATE_WEDGED;
+				fallthrough;
+			case ATH12K_STATE_WEDGED:
+				ath12k_warn(ab,
+					    "device is wedged, will not restart radio %d\n", j);
+				break;
+			}
+			mutex_unlock(&ar->conf_mutex);
+		}
 
-	for (i = 0; i < ab->num_radios; i++) {
-		pdev = &ab->pdevs[i];
-		ar = pdev->ar;
-		if (!ar || ar->state == ATH12K_STATE_OFF)
-			continue;
-
-		mutex_lock(&ar->conf_mutex);
-
-		switch (ar->state) {
-		case ATH12K_STATE_ON:
-			ar->state = ATH12K_STATE_RESTARTING;
-			ath12k_core_halt(ar);
-			ieee80211_restart_hw(ab->ah->hw);
-			break;
-		case ATH12K_STATE_OFF:
-			ath12k_warn(ab,
-				    "cannot restart radio %d that hasn't been started\n",
-				    i);
-			break;
-		case ATH12K_STATE_RESTARTING:
-			break;
-		case ATH12K_STATE_RESTARTED:
-			ar->state = ATH12K_STATE_WEDGED;
-			fallthrough;
-		case ATH12K_STATE_WEDGED:
-			ath12k_warn(ab,
-				    "device is wedged, will not restart radio %d\n", i);
-			break;
+		if (ab->is_reset) {
+			atomic_dec(&ab->reset_count);
+			complete(&ab->reset_complete);
+			ab->is_reset = false;
 		}
-		mutex_unlock(&ar->conf_mutex);
-	}
 
-	if (ab->is_reset) {
-		atomic_dec(&ab->reset_count);
-		complete(&ab->reset_complete);
-		ab->is_reset = false;
+		complete(&ab->driver_recovery);
 	}
 
-	complete(&ab->driver_recovery);
-
+	mutex_lock(&ag->ah->conf_mutex);
+	ieee80211_restart_hw(ag->ah->hw);
+	mutex_unlock(&ag->ah->conf_mutex);
 }
 
 static void ath12k_core_reset(struct work_struct *work)
@@ -939,31 +1240,163 @@ int ath12k_core_pre_init(struct ath12k_b
 	return 0;
 }
 
+static int ath12k_core_hw_group_create(struct ath12k_hw_group *ag)
+{
+	int i, ret;
+	struct ath12k_base *ab;
+
+	lockdep_assert_held(&ag->mutex_lock);
+
+	for(i = 0; i < ag->num_chip; i++) {
+		ab = ag->ab[i];
+
+		mutex_lock(&ab->core_lock);
+		ret = ath12k_core_soc_create(ab);
+ 		if (ret) {
+			mutex_unlock(&ab->core_lock);
+			ath12k_err(ab, "failed to create soc core: %d\n", ret);
+			goto out;
+ 		}
+		set_bit(ATH12K_FLAG_HW_GROUP_ATTACHED, &ab->dev_flags);
+		mutex_unlock(&ab->core_lock);
+	}
+
+	return 0;
+out:
+	return ret;
+}
+
 int ath12k_core_init(struct ath12k_base *ab)
 {
+	struct ath12k_hw_group *ag;
 	int ret;
 
-	ret = ath12k_core_soc_create(ab);
+	ret = ath12k_debugfs_soc_create(ab);
 	if (ret) {
-		ath12k_err(ab, "failed to create soc core: %d\n", ret);
+		ath12k_err(ab, "failed to create debugfs\n");
 		return ret;
 	}
 
+	mutex_lock(&ath12k_hw_lock);
+
+	ag = ath12k_core_get_hw_group(ab);
+	if (!ag) {
+		mutex_unlock(&ath12k_hw_lock);
+		ath12k_warn(ab, "unable to get hw group\n");
+		goto err_debugfs;
+	}
+	mutex_unlock(&ath12k_hw_lock);
+
+	mutex_lock(&ag->mutex_lock);
+
+	ath12k_dbg(ab, ATH12K_DBG_BOOT, "num chips in group %d, num probed %d\n",
+		    ag->num_chip, ag->num_probed);
+
+	if (ath12k_core_hw_group_create_ready(ag)) {
+		ret = ath12k_core_hw_group_create(ag);
+		if (ret) {
+			ath12k_warn(ab, "unable to create hw group\n");
+			goto err_hw_group;
+		}
+	}
+
+	mutex_unlock(&ag->mutex_lock);
+
 	return 0;
+
+err_hw_group:
+	__ath12k_core_put_hw_group(ab);
+	mutex_unlock(&ag->mutex_lock);
+err_debugfs:
+	ath12k_debugfs_soc_destroy(ab);
+	return ret;
+}
+
+static void ath12k_core_hw_group_destroy(struct ath12k_hw_group *ag)
+{
+	struct ath12k_base *ab;
+	int i;
+
+	lockdep_assert_held(&ag->mutex_lock);
+
+	for(i = 0; i < ag->num_chip; i++) {
+		ab = ag->ab[i];
+
+		mutex_lock(&ab->core_lock);
+		if (test_bit(ATH12K_FLAG_HW_GROUP_ATTACHED, &ab->dev_flags)) {
+			clear_bit(ATH12K_FLAG_HW_GROUP_ATTACHED, &ab->dev_flags);
+			ath12k_core_soc_destroy(ab);
+		}
+		mutex_unlock(&ab->core_lock);
+	}
+}
+
+static void ath12k_core_hw_group_stop(struct ath12k_hw_group *ag)
+{
+	struct ath12k_base *ab;
+	int i;
+
+	lockdep_assert_held(&ag->mutex_lock);
+
+	if (!test_bit(ATH12K_FLAG_REGISTERED, &ag->dev_flags))
+		return;
+
+	clear_bit(ATH12K_FLAG_REGISTERED, &ag->dev_flags);
+
+	for (i = 0; i < ag->num_chip; i++) {
+		ab = ag->ab[i];
+
+		mutex_lock(&ab->core_lock);
+
+		ath12k_core_pdev_deinit(ab);
+
+		mutex_unlock(&ab->core_lock);
+	}
+
+	ath12k_mac_unregister(ag);
+
+	for (i = 0; i < ag->num_chip; i++) {
+		ab = ag->ab[i];
+
+		mutex_lock(&ab->core_lock);
+
+		ath12k_hif_irq_disable(ab);
+		ath12k_core_pdev_destroy(ab);
+		ath12k_core_stop(ab);
+
+		ath12k_hif_power_down(ab);
+
+		mutex_unlock(&ab->core_lock);
+	}
+
+	ath12k_mac_destroy(ag);
+
+	ath12k_core_hw_group_destroy(ag);
 }
 
 void ath12k_core_deinit(struct ath12k_base *ab)
 {
-	mutex_lock(&ab->core_lock);
+	struct ath12k_hw_group *ag = ab->ag;
 
-	ath12k_core_pdev_destroy(ab);
-	ath12k_core_stop(ab);
+	mutex_lock(&ag->mutex_lock);
 
-	mutex_unlock(&ab->core_lock);
+	if (test_bit(ATH12K_FLAG_REGISTERED, &ag->dev_flags)) {
+		ath12k_core_hw_group_stop(ag);
+	} else if (test_bit(ATH12K_FLAG_HW_GROUP_ATTACHED, &ab->dev_flags)) {
+		mutex_lock(&ab->core_lock);
 
-	ath12k_hif_power_down(ab);
-	ath12k_mac_destroy(ab);
-	ath12k_core_soc_destroy(ab);
+		clear_bit(ATH12K_FLAG_HW_GROUP_ATTACHED, &ab->dev_flags);
+		ath12k_core_stop(ab);
+		ath12k_hif_power_down(ab);
+		ath12k_core_soc_destroy(ab);
+
+		mutex_unlock(&ab->core_lock);
+	}
+
+	ath12k_debugfs_soc_destroy(ab);
+	__ath12k_core_put_hw_group(ab);
+
+	mutex_unlock(&ag->mutex_lock);
 }
 
 void ath12k_core_free(struct ath12k_base *ab)
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -176,7 +176,9 @@ struct ath12k_he {
 };
 
 #define MAX_RADIOS 3
-
+#define ATH12K_MAX_SOCS 3
+#define ATH12K_INVALID_GRP_ID  0xFF
+#define ATH12K_INVALID_CHIP_ID 0xFF
 enum {
 	WMI_HOST_TP_SCALE_MAX   = 0,
 	WMI_HOST_TP_SCALE_50    = 1,
@@ -205,6 +207,8 @@ enum ath12k_dev_flags {
 	ATH12K_FLAG_REGISTERED,
 	ATH12K_FLAG_QMI_FAIL,
 	ATH12K_FLAG_HTC_SUSPEND_COMPLETE,
+	ATH12K_FLAG_QMI_FW_READY_COMPLETE,
+	ATH12K_FLAG_HW_GROUP_ATTACHED,
 };
 
 enum ath12k_monitor_flags {
@@ -685,6 +689,8 @@ struct ath12k {
 	/* pdev_idx starts from 0 whereas pdev->pdev_id starts with 1 */
 	u8 pdev_idx;
 	u8 lmac_id;
+	/* link_idx unique across the group of hw used to lookup in ah */
+	u8 link_idx;
 
 	struct completion peer_assoc_done;
 	struct completion peer_delete_done;
@@ -879,16 +885,31 @@ struct ath12k_hw {
 	struct ath12k radio[0] __aligned(sizeof(void *));
 };
 
+/* Holds info on the group of SOCs that are registered as a single wiphy */
+struct ath12k_hw_group {
+	u8 id;
+	u8 num_chip;
+	u8 num_probed;
+	u8 num_started;
+	unsigned long dev_flags;
+	struct list_head list;
+	struct ath12k_hw *ah;
+	struct ath12k_base *ab[ATH12K_MAX_SOCS];
+	struct mutex mutex_lock;
+};
+
 /* Master structure to hold the hw data which may be used in core module */
 struct ath12k_base {
 	enum ath12k_hw_rev hw_rev;
 	struct platform_device *pdev;
 	struct device *dev;
 	struct ath12k_hw *ah;
+	struct ath12k_hw_group *ag;
 	struct ath12k_qmi qmi;
 	struct ath12k_wmi_base wmi_ab;
 	struct completion fw_ready;
 	int num_radios;
+	u8 chip_id;
 	/* HW channel counters frequency value in hertz common to all MACs */
 	u32 cc_freq_hz;
 
@@ -1142,6 +1163,8 @@ int ath12k_coredump_mhi_update_bhie_tabl
 					  void __iomem *va,
 					  phys_addr_t pa, size_t size);
 
+void ath12k_core_put_hw_group(struct ath12k_base *ab);
+
 const struct firmware *ath12k_core_firmware_request(struct ath12k_base *ab,
 						    const char *filename);
 
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -6464,7 +6464,8 @@ static void ath12k_mac_setup_he_eht_cap(
 		band->n_iftype_data = count;
 	}
 
-	if (cap->supported_bands & WMI_HOST_WLAN_5G_CAP) {
+	if (cap->supported_bands & WMI_HOST_WLAN_5G_CAP &&
+	    !ar->supports_6ghz) {
 		count = ath12k_mac_copy_he_eht_cap(ar, cap,
 						   ar->mac.iftype[NL80211_BAND_5GHZ],
 						   NL80211_BAND_5GHZ);
@@ -7116,7 +7117,8 @@ static int ath12k_mac_setup_vdev_create_
 		params->chains[NL80211_BAND_2GHZ].tx = ar->num_tx_chains;
 		params->chains[NL80211_BAND_2GHZ].rx = ar->num_rx_chains;
 	}
-	if (pdev->cap.supported_bands & WMI_HOST_WLAN_5G_CAP) {
+	if (pdev->cap.supported_bands & WMI_HOST_WLAN_5G_CAP &&
+	    !ar->supports_6ghz) {
 		params->chains[NL80211_BAND_5GHZ].tx = ar->num_tx_chains;
 		params->chains[NL80211_BAND_5GHZ].rx = ar->num_rx_chains;
 	}
@@ -10007,22 +10009,36 @@ static void
 ath12k_mac_op_reconfig_complete(struct ieee80211_hw *hw,
 				enum ieee80211_reconfig_type reconfig_type)
 {
-	/* TODO Handle hw restart */
-	struct ath12k *ar = hw->priv;
+	struct ath12k_hw *ah = hw->priv;
+	struct ath12k *ar;
+	u8 restart_count = 0;
+	int i;
 
 	if (reconfig_type != IEEE80211_RECONFIG_TYPE_RESTART)
 		return;
 
-	mutex_lock(&ar->conf_mutex);
+	mutex_lock(&ah->conf_mutex);
 
-	if (ar->state == ATH12K_STATE_RESTARTED) {
-		ath12k_warn(ar->ab, "pdev %d successfully recovered\n",
-			    ar->pdev->pdev_id);
-		ar->state = ATH12K_STATE_ON;
-		ieee80211_wake_queues(ar->hw);
+	ar = ah->radio;
+
+	for (i = 0; i < ah->num_radio; i++) {
+		mutex_lock(&ar->conf_mutex);
+
+		if (ar->state == ATH12K_STATE_RESTARTED) {
+			ath12k_warn(ar->ab, "pdev %d successfully recovered\n",
+				    ar->pdev->pdev_id);
+			ar->state = ATH12K_STATE_ON;
+			restart_count++;
+		}
+
+		mutex_unlock(&ar->conf_mutex);
+		ar++;
 	}
 
-	mutex_unlock(&ar->conf_mutex);
+	if (restart_count == ah->num_radio)
+		ieee80211_wake_queues(ah->hw);
+
+	mutex_unlock(&ah->conf_mutex);
 }
 
 static void
@@ -10548,10 +10564,13 @@ static const struct wiphy_iftype_ext_cap
 	},
 };
 
-static void __ath12k_mac_unregister(struct ath12k *ar)
+static void __ath12k_mac_pre_unregister(struct ath12k *ar)
 {
 	cancel_work_sync(&ar->regd_update_work);
+}
 
+static void __ath12k_mac_post_unregister(struct ath12k *ar)
+{
 	idr_for_each(&ar->txmgmt_idr, ath12k_mac_tx_mgmt_pending_free, ar);
 	idr_destroy(&ar->txmgmt_idr);
 
@@ -10560,26 +10579,39 @@ static void __ath12k_mac_unregister(stru
 	kfree(ar->mac.sbands[NL80211_BAND_6GHZ].channels);
 }
 
-void ath12k_mac_unregister(struct ath12k_base *ab)
+static void __ath12k_mac_unregister(struct ath12k *ar)
 {
+	__ath12k_mac_pre_unregister(ar);
+	__ath12k_mac_post_unregister(ar);
+}
+
+void ath12k_mac_unregister(struct ath12k_hw_group *ag)
+{
+	struct ath12k_hw *ah = ag->ah;
 	struct ath12k *ar;
-	struct ath12k_pdev *pdev;
 	int i;
 
-	for (i = 0; i < ab->num_radios; i++) {
-		pdev = &ab->pdevs[i];
-		ar = pdev->ar;
-		if (!ar)
-			continue;
+	if (!ah)
+		return;
 
-		__ath12k_mac_unregister(ar);
+	ar = ah->radio;
+	for (i = 0; i < ah->num_radio; i++) {
+		__ath12k_mac_pre_unregister(ar);
+		ar++;
 	}
 
-	kfree(ab->ah->hw->wiphy->iface_combinations[0].limits);
-	kfree(ab->ah->hw->wiphy->iface_combinations);
+	ieee80211_unregister_hw(ah->hw);
 
-	ieee80211_unregister_hw(ab->ah->hw);
-	SET_IEEE80211_DEV(ab->ah->hw, NULL);
+	ar = ah->radio;
+	for (i = 0; i < ah->num_radio; i++) {
+		__ath12k_mac_post_unregister(ar);
+		ar++;
+	}
+
+	kfree(ah->hw->wiphy->iface_combinations[0].limits);
+	kfree(ah->hw->wiphy->iface_combinations);
+
+	SET_IEEE80211_DEV(ah->hw, NULL);
 }
 
 static int __ath12k_mac_register(struct ath12k *ar)
@@ -10611,12 +10643,6 @@ static int __ath12k_mac_register(struct
 	if (cap->nss_ratio_enabled)
 		ieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);
 
-	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
-	ieee80211_hw_set(hw, TX_AMPDU_SETUP_IN_HW);
-	ieee80211_hw_set(hw, SUPPORTS_REORDERING_BUFFER);
-	ieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);
-	ieee80211_hw_set(hw, USES_RSS);
-
 	/* TODO: Check if HT capability advertised from firmware is different
 	 * for each band for a dual band capable radio. It will be tricky to
 	 * handle it when the ht capability different for each band.
@@ -10634,14 +10660,15 @@ static int __ath12k_mac_register(struct
 	return 0;
 }
 
-int ath12k_mac_register(struct ath12k_base *ab)
+int ath12k_mac_register(struct ath12k_hw_group *ag)
 {
 	struct ieee80211_hw *hw;
 	struct ath12k_pdev_cap *cap;
+	struct ath12k_hw *ah;
+	struct ath12k_base *ab, *ab_dflt;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
-	int i;
-	int ret;
+	int i, j, ret;
 	u32 antennas_rx, antennas_tx;
 	bool unregister = false;
 	static const u32 cipher_suites[] = {
@@ -10656,17 +10683,23 @@ int ath12k_mac_register(struct ath12k_ba
 		WLAN_CIPHER_SUITE_CCMP_256,
 	};
 
-	if (test_bit(ATH12K_FLAG_REGISTERED, &ab->dev_flags))
-		return 0;
+	/* Use the first chip in group to advertise some features/info
+	 * these are expected to be similar for chips in group
+	 */
+	ab_dflt = ag->ab[0];
 
-	hw = ab->ah->hw;
+	ah = ag->ah;
+	hw = ah->hw;
 	hw->wiphy->max_ap_assoc_sta = 0;
 	antennas_rx = 0;
 	antennas_tx = 0;
 
-	for (i = 0; i < ab->num_radios; i++) {
-		pdev = &ab->pdevs[i];
-		ar = pdev->ar;
+	ar = ah->radio;
+	ab = ar->ab;
+
+	for (i = 0; i < ah->num_radio; i++) {
+		ab = ar->ab;
+		pdev = ar->pdev;
 		if (ab->pdevs_macaddr_valid) {
 			ether_addr_copy(ar->mac_addr, pdev->mac_addr);
 		} else {
@@ -10686,25 +10719,28 @@ int ath12k_mac_register(struct ath12k_ba
 		antennas_tx = max_t(u32, antennas_tx, cap->tx_chain_mask);
 
 		hw->wiphy->max_ap_assoc_sta += ar->max_num_stations;
+
+		ar++;
 	}
 
 	hw->wiphy->available_antennas_rx = antennas_rx;
 	hw->wiphy->available_antennas_tx = antennas_tx;
 
-	ret = ath12k_mac_setup_iface_combinations(ab);
+	/* TODO: Add link/ar specific iface combinations
+	 * For now, setting up combination once for the group
+	 */
+	ret = ath12k_mac_setup_iface_combinations(ab_dflt);
 	if (ret) {
-		ath12k_err(ab, "failed to setup interface combinations: %d\n", ret);
+		ath12k_err(NULL, "failed to setup interface combinations: %d\n",
+			   ret);
 		goto err_cleanup;
 	}
 
-	/* Initialize channel counters frequency value in hertz */
-	ab->cc_freq_hz = 320000;
-	ab->free_vdev_map = (1LL << (ab->num_radios * TARGET_NUM_VDEVS)) - 1;
+	SET_IEEE80211_PERM_ADDR(hw, ab_dflt->mac_addr);
+	SET_IEEE80211_DEV(hw, ab_dflt->dev);
 
-	/* TODO: SET_IEEE80211_PERM_ADDR() */
-	SET_IEEE80211_DEV(hw, ab->dev);
-
-	hw->wiphy->interface_modes = ab->hw_params->interface_modes;
+	/* Iface modes are expected to be similar for partner chips */
+	hw->wiphy->interface_modes = ab_dflt->hw_params->interface_modes;
 	hw->wiphy->ru_punct_supp_bw = NL80211_RU_PUNCT_SUPP_BW_80;
 
 	ieee80211_hw_set(hw, SIGNAL_DBM);
@@ -10722,6 +10758,12 @@ int ath12k_mac_register(struct ath12k_ba
 	ieee80211_hw_set(hw, QUEUE_CONTROL);
 	ieee80211_hw_set(hw, SUPPORTS_TX_FRAG);
 	ieee80211_hw_set(hw, REPORTS_LOW_ACK);
+	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+	ieee80211_hw_set(hw, TX_AMPDU_SETUP_IN_HW);
+	ieee80211_hw_set(hw, SUPPORTS_REORDERING_BUFFER);
+	ieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);
+	ieee80211_hw_set(hw, USES_RSS);
+
 	if (ath12k_frame_mode == ATH12K_HW_TXRX_ETHERNET) {
 		ieee80211_hw_set(hw, SUPPORTS_TX_ENCAP_OFFLOAD);
 		ieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);
@@ -10746,6 +10788,7 @@ int ath12k_mac_register(struct ath12k_ba
 	hw->wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |
 			       NL80211_FEATURE_AP_SCAN;
 
+	/* TODO Split queues per chip */
 	hw->queues = ATH12K_HW_MAX_QUEUES;
 	hw->wiphy->tx_queue_len = ATH12K_QUEUE_LEN;
 	hw->offchannel_tx_hw_queue = ATH12K_HW_MAX_QUEUES - 1;
@@ -10770,9 +10813,10 @@ int ath12k_mac_register(struct ath12k_ba
 	hw->wiphy->mbssid_max_interfaces = ab->num_radios * TARGET_NUM_VDEVS;
 	hw->wiphy->ema_max_profile_periodicity = TARGET_EMA_MAX_PROFILE_PERIOD;
 
-	ath12k_reg_init(ab);
+	ah->hw->wiphy->regulatory_flags = REGULATORY_WIPHY_SELF_MANAGED;
+	ah->hw->wiphy->reg_notifier = ath12k_reg_notifier;
 
-	if (!test_bit(ATH12K_FLAG_RAW_MODE, &ab->dev_flags)) {
+	if (!test_bit(ATH12K_FLAG_RAW_MODE, &ab_dflt->dev_flags)) {
 		hw->netdev_features = NETIF_F_HW_CSUM;
 		ieee80211_hw_set(hw, SW_CRYPTO_CONTROL);
 		ieee80211_hw_set(hw, SUPPORT_FAST_XMIT);
@@ -10780,11 +10824,11 @@ int ath12k_mac_register(struct ath12k_ba
 
 	ret = ieee80211_register_hw(hw);
 	if (ret) {
-		ath12k_err(ab, "ieee80211 registration failed: %d\n", ret);
+		ath12k_err(NULL, "ieee80211 registration failed: %d\n", ret);
 		goto err_full_cleanup;
 	}
 
-	if (!ab->hw_params->supports_monitor)
+	if (!ab_dflt->hw_params->supports_monitor)
 		/* There's a race between calling ieee80211_register_hw()
 		 * and here where the monitor mode is enabled for a little
 		 * while. But that time is so short and in practise it make
@@ -10792,10 +10836,10 @@ int ath12k_mac_register(struct ath12k_ba
 		 */
 		hw->wiphy->interface_modes &= ~BIT(NL80211_IFTYPE_MONITOR);
 
- 	for (i = 0; i < ab->num_radios; i++) {
- 		pdev = &ab->pdevs[i];
- 		ar = pdev->ar;
+	ar = ah->radio;
+	ab = ar->ab;
 
+ 	for (i = 0; i < ah->num_radio; i++) {
 		ret = ath12k_regd_update(ar, true);
 		if (ret) {
 			ath12k_err(ar->ab, "ath12k regd update failed: %d\n", ret);
@@ -10807,76 +10851,70 @@ int ath12k_mac_register(struct ath12k_ba
 			ath12k_err(ar->ab, "debugfs registration failed: %d\n", ret);
 			goto err_unregister_hw;
 		}
+
+		ar++;
 	}
 
 	return 0;
 
 err_unregister_hw:
+	ar = ah->radio;
+	for (j = 0; j < i; j++) {
+		ath12k_debugfs_unregister(ar);
+		ar++;
+	}
 	unregister = true;
 err_full_cleanup:
 	kfree(hw->wiphy->iface_combinations[0].limits);
 	kfree(hw->wiphy->iface_combinations);
-	i = ab->num_radios;
+	i = ah->num_radio;
 err_cleanup:
-	for (i = i - 1; i >= 0; i--) {
-		pdev = &ab->pdevs[i];
-		ar = pdev->ar;
+	ar = ah->radio;
+	for (j = 0; j < i; j++) {
 		__ath12k_mac_unregister(ar);
+		ar++;
 	}
 
 	if (unregister) {
-		ieee80211_unregister_hw(ab->ah->hw);
-		SET_IEEE80211_DEV(ab->ah->hw, NULL);
+		ieee80211_unregister_hw(hw);
+		SET_IEEE80211_DEV(hw, NULL);
 	}
 
 	return ret;
 }
 
 static inline struct ath12k *ath12k_mac_get_ar(struct ath12k_hw *ah,
-					       u8 pdev_idx)
+					       u8 link_idx)
 {
 	struct ath12k *ar = ah->radio;
 
-	return ar + pdev_idx;
+	if (link_idx >= ah->num_radio)
+		return NULL;
+
+	return ar + link_idx;
 }
 
-int ath12k_mac_allocate(struct ath12k_base *ab)
+static int ath12k_mac_chip_setup(struct ath12k_hw *ah, u8 *link_id,
+				 struct ath12k_base *ab)
 {
-	struct ieee80211_hw *hw;
-	struct ath12k_hw *ah;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
-	size_t len;
 	int i;
 
-	if (test_bit(ATH12K_FLAG_REGISTERED, &ab->dev_flags))
-		return 0;
-
-	len = sizeof(struct ath12k_hw) + (ab->num_radios * sizeof(struct ath12k));
-
-	hw = ieee80211_alloc_hw(len, &ath12k_ops);
-	if (!hw) {
-		ath12k_warn(ab, "failed to allocate mac80211 hw device\n");
-		return -ENOMEM;
-	}
-
-	ah = hw->priv;
-	ah->hw = hw;
-	ah->ops = &ath12k_ops;
-	ah->num_radio = ab->num_radios;
 	ab->ah = ah;
 
-	mutex_init(&ah->conf_mutex);
-
 	for (i = 0; i < ab->num_radios; i++) {
 		pdev = &ab->pdevs[i];
-		ar = ath12k_mac_get_ar(ah, i);
+		ar = ath12k_mac_get_ar(ah, *link_id);
+		if (!ar)
+			return -EINVAL;
 
 		ar->ab = ab;
-		ar->hw = hw;
+		ar->hw = ah->hw;
 		ar->pdev = pdev;
 		ar->pdev_idx = i;
 		ar->lmac_id = ath12k_hw_get_mac_from_pdev_id(ab->hw_params, i);
+		ar->link_idx = *link_id;
 
 		ar->wmi = &ab->wmi_ab.wmi[i];
 		/* FIXME wmi[0] is already initialized during attach,
@@ -10912,26 +10950,91 @@ int ath12k_mac_allocate(struct ath12k_ba
 		clear_bit(MONITOR_VDEV_STARTED, &ar->monitor_flags);
 		ar->monitor_vdev_id = -1;
 		clear_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags);
+
+		*link_id = *link_id + 1;
 	}
 
+	/* Initialize channel counters frequency value in hertz */
+	ab->cc_freq_hz = 320000;
+	ab->free_vdev_map = (1LL << (ab->num_radios * TARGET_NUM_VDEVS)) - 1;
+
+	ath12k_dp_pdev_pre_alloc(ab);
+
 	return 0;
 }
 
-void ath12k_mac_destroy(struct ath12k_base *ab)
+int ath12k_mac_allocate(struct ath12k_hw_group *ag)
 {
+	struct ieee80211_hw *hw;
+	struct ath12k_hw *ah;
+	size_t len;
+	int i, num_radios = 0, ret;
+	u8 link_id = 0;
+
+	for (i = 0; i < ag->num_chip; i++)
+		num_radios += ag->ab[i]->num_radios;
+
+	len = sizeof(struct ath12k_hw) + (num_radios * sizeof(struct ath12k));
+	hw = ieee80211_alloc_hw(len, &ath12k_ops);
+	if (!hw) {
+		WARN_ON(1);
+		return -ENOMEM;
+	}
+
+	ah = hw->priv;
+	ah->hw = hw;
+	ah->ops = &ath12k_ops;
+	ah->num_radio = num_radios;
+	ag->ah = ah;
+
+	ath12k_info(NULL,
+		    "ath12k hw device created with %d radios in group %d with %d chips\n",
+		    ah->num_radio, ag->id, ag->num_chip);
+
+	mutex_init(&ah->conf_mutex);
+
+	for (i = 0; i < ag->num_chip; i++) {
+		ret = ath12k_mac_chip_setup(ah, &link_id, ag->ab[i]);
+		if (ret) {
+			ath12k_err(ag->ab[i], "failed to perform chip allocate for chip %d group %d\n",
+				   i, ag->id);
+			goto err_mac_destroy;
+		}
+	}
+
+	return 0;
+
+err_mac_destroy:
+	ath12k_mac_destroy(ag);
+	return ret;
+}
+
+void ath12k_mac_destroy(struct ath12k_hw_group *ag)
+{
+	struct ath12k_base *ab;
+	struct ath12k_hw *ah = ag->ah;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
-	int i;
+	int i, j;
 
-	for (i = 0; i < ab->num_radios; i++) {
-		pdev = &ab->pdevs[i];
-		ar = pdev->ar;
-		if (!ar)
+	if (!ah)
+		return;
+
+	for (i = 0; i < ag->num_chip; i++) {
+		ab = ag->ab[i];
+		if (!ab)
 			continue;
 
-		pdev->ar = NULL;
+		for (j = 0; j < ab->num_radios; j++) {
+			pdev = &ab->pdevs[j];
+			ar = pdev->ar;
+			if (!ar)
+				continue;
+
+			pdev->ar = NULL;
+		}
 	}
 
-	ieee80211_free_hw(ab->ah->hw);
-	ab->ah = NULL;
+	ieee80211_free_hw(ah->hw);
+	ag->ah = NULL;
 }
--- a/drivers/net/wireless/ath/ath12k/mac.h
+++ b/drivers/net/wireless/ath/ath12k/mac.h
@@ -12,6 +12,7 @@
 
 struct ath12k;
 struct ath12k_base;
+struct ath12k_hw_group;
 
 struct ath12k_generic_iter {
 	struct ath12k *ar;
@@ -129,10 +130,10 @@ struct ath12k_generic_iter {
 extern const struct htt_rx_ring_tlv_filter ath12k_mac_mon_status_filter_default;
 
 void ath12k_mac_ap_ps_recalc(struct ath12k *ar);
-void ath12k_mac_destroy(struct ath12k_base *ab);
-void ath12k_mac_unregister(struct ath12k_base *ab);
-int ath12k_mac_register(struct ath12k_base *ab);
-int ath12k_mac_allocate(struct ath12k_base *ab);
+void ath12k_mac_destroy(struct ath12k_hw_group *ag);
+void ath12k_mac_unregister(struct ath12k_hw_group *ag);
+int ath12k_mac_register(struct ath12k_hw_group *ag);
+int ath12k_mac_allocate(struct ath12k_hw_group *ag);
 int ath12k_mac_hw_ratecode_to_legacy_rate(u8 hw_rc, u8 preamble, u8 *rateidx,
 					  u16 *rate);
 u8 ath12k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,
--- a/drivers/net/wireless/ath/ath12k/reg.c
+++ b/drivers/net/wireless/ath/ath12k/reg.c
@@ -126,8 +126,7 @@ ath12k_reg_send_request(struct ath12k *a
 			    "INIT Country code set to fw failed : %d\n", ret);
 }
 
-static void
-ath12k_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+void ath12k_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
 {
 	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
 	struct ath12k_hw *ah = hw->priv;
@@ -747,12 +746,6 @@ void ath12k_regd_update_work(struct work
 	}
 }
 
-void ath12k_reg_init(struct ath12k_base *ab)
-{
-	ab->ah->hw->wiphy->regulatory_flags = REGULATORY_WIPHY_SELF_MANAGED;
-	ab->ah->hw->wiphy->reg_notifier = ath12k_reg_notifier;
-}
-
 void ath12k_reg_free(struct ath12k_base *ab)
 {
 	int i;
--- a/drivers/net/wireless/ath/ath12k/reg.h
+++ b/drivers/net/wireless/ath/ath12k/reg.h
@@ -26,7 +26,8 @@ enum ath12k_dfs_region {
 };
 
 /* ATH12K Regulatory API's */
-void ath12k_reg_init(struct ath12k_base *ab);
+void ath12k_reg_notifier(struct wiphy *wiphy,
+			 struct regulatory_request *request);
 void ath12k_reg_free(struct ath12k_base *ab);
 void ath12k_regd_update_work(struct work_struct *work);
 struct ieee80211_regdomain *
--- a/drivers/net/wireless/ath/ath12k/thermal.c
+++ b/drivers/net/wireless/ath/ath12k/thermal.c
@@ -155,36 +155,44 @@ int ath12k_thermal_set_throttling(struct
 	return ret;
 }
 
-int ath12k_thermal_register(struct ath12k_base *sc)
+int ath12k_thermal_register(struct ath12k_base *ab)
 {
+	struct ath12k_hw *ah;
 	struct thermal_cooling_device *cdev;
 	struct device *hwmon_dev;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
 	int i, ret;
+	char pdev_name[20];
 
-	for (i = 0; i < sc->num_radios; i++) {
-		pdev = &sc->pdevs[i];
+	ah = ab->ah;
+	for (i = 0; i < ab->num_radios; i++) {
+		pdev = &ab->pdevs[i];
 		ar = pdev->ar;
 		if (!ar)
 			continue;
 
+		memset(pdev_name, 0, sizeof(pdev_name));
+
 		cdev = thermal_cooling_device_register("ath12k_thermal", ar,
 						       &ath12k_thermal_ops);
 
 		if (IS_ERR(cdev)) {
-			ath12k_err(sc, "failed to setup thermal device result: %ld\n",
+			ath12k_err(ab, "failed to setup thermal device result: %ld\n",
 				   PTR_ERR(cdev));
 			ret = -EINVAL;
 			goto err_thermal_destroy;
 		}
 
+		snprintf(pdev_name, sizeof(pdev_name), "%s%d", "cooling_device",
+			 ar->link_idx);
+
 		ar->thermal.cdev = cdev;
 
 		ret = sysfs_create_link(&ar->hw->wiphy->dev.kobj, &cdev->device.kobj,
-					"cooling_device");
+					pdev_name);
 		if (ret) {
-			ath12k_err(sc, "failed to create cooling device symlink\n");
+			ath12k_err(ab, "failed to create cooling device symlink\n");
 			goto err_thermal_destroy;
 		}
 
@@ -205,23 +213,31 @@ int ath12k_thermal_register(struct ath12
 	return 0;
 
 err_thermal_destroy:
-	ath12k_thermal_unregister(sc);
+	ath12k_thermal_unregister(ab);
 	return ret;
 }
 
-void ath12k_thermal_unregister(struct ath12k_base *sc)
+void ath12k_thermal_unregister(struct ath12k_base *ab)
 {
+	struct ath12k_hw *ah;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
 	int i;
+	char pdev_name[20];
 
-	for (i = 0; i < sc->num_radios; i++) {
-		pdev = &sc->pdevs[i];
+	ah = ab->ah;
+	for (i = 0; i < ab->num_radios; i++) {
+		pdev = &ab->pdevs[i];
 		ar = pdev->ar;
 		if (!ar)
 			continue;
 
-		sysfs_remove_link(&ar->hw->wiphy->dev.kobj, "cooling_device");
+		memset(pdev_name, 0, sizeof(pdev_name));
+
+		snprintf(pdev_name, sizeof(pdev_name), "%s%d", "cooling_device",
+			 ar->link_idx);
+
+		sysfs_remove_link(&ar->hw->wiphy->dev.kobj, pdev_name);
 		thermal_cooling_device_unregister(ar->thermal.cdev);
 	}
 }
--- a/drivers/net/wireless/ath/ath12k/pci.c
+++ b/drivers/net/wireless/ath/ath12k/pci.c
@@ -1326,6 +1326,7 @@ static int ath12k_pci_probe(struct pci_d
 		ath12k_err(ab, "failed to init core: %d\n", ret);
 		goto err_free_irq;
 	}
+
 	return 0;
 
 err_free_irq:
@@ -1361,10 +1362,11 @@ static void ath12k_pci_remove(struct pci
 		ath12k_pci_power_down(ab);
 		ath12k_debugfs_soc_destroy(ab);
 		ath12k_qmi_deinit_service(ab);
+		ath12k_core_put_hw_group(ab);
 		goto qmi_fail;
 	}
 
-	set_bit(ATH12K_FLAG_UNREGISTERING, &ab->dev_flags);
+	set_bit(ATH12K_FLAG_UNREGISTERING, &ab->ag->dev_flags);
 
 	cancel_work_sync(&ab->reset_work);
 	ath12k_core_deinit(ab);
--- a/drivers/net/wireless/ath/ath12k/qmi.c
+++ b/drivers/net/wireless/ath/ath12k/qmi.c
@@ -4576,7 +4576,8 @@ static void ath12k_qmi_driver_event_work
 			break;
 		case ATH12K_QMI_EVENT_FW_READY:
 			clear_bit(ATH12K_FLAG_QMI_FAIL, &ab->dev_flags);
-			if (test_bit(ATH12K_FLAG_REGISTERED, &ab->dev_flags)) {
+			if (test_bit(ATH12K_FLAG_QMI_FW_READY_COMPLETE,
+				     &ab->dev_flags)) {
 				ath12k_hal_dump_srng_stats(ab);
 				queue_work(ab->workqueue, &ab->restart_work);
 				break;
@@ -4589,8 +4590,15 @@ static void ath12k_qmi_driver_event_work
 				clear_bit(ATH12K_FLAG_CRASH_FLUSH,
 					  &ab->dev_flags);
 				clear_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags);
-				ath12k_core_qmi_firmware_ready(ab);
-				set_bit(ATH12K_FLAG_REGISTERED, &ab->dev_flags);
+				ret = ath12k_core_qmi_firmware_ready(ab);
+				if (ret) {
+					ath12k_warn(ab, "failed to init after firmware ready: %d\n", ret);
+					set_bit(ATH12K_FLAG_QMI_FAIL, &ab->dev_flags);
+					break;
+				}
+				set_bit(ATH12K_FLAG_QMI_FW_READY_COMPLETE,
+					&ab->dev_flags);
+
 			}
 
 			break;
--- a/drivers/net/wireless/ath/ath12k/mhi.c
+++ b/drivers/net/wireless/ath/ath12k/mhi.c
@@ -328,7 +328,7 @@ static void ath12k_mhi_op_status_cb(stru
 		ath12k_warn(ab, "firmware crashed: MHI_CB_SYS_ERROR\n");
 		break;
 	case MHI_CB_EE_RDDM:
-		if (!(test_bit(ATH12K_FLAG_UNREGISTERING, &ab->dev_flags)))
+		if (!(test_bit(ATH12K_FLAG_UNREGISTERING, &ab->ag->dev_flags)))
 			queue_work(ab->workqueue_aux, &ab->reset_work);
 		ath12k_hal_dump_srng_stats(ab);
 		break;
