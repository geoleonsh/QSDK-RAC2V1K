From 9780162653ef8571a88ea797169e103dd3dbf281 Mon Sep 17 00:00:00 2001
From: Karthikeyan Periyasamy <quic_periyasa@quicinc.com>
Date: Tue, 21 Mar 2023 10:33:33 +0530
Subject: [PATCH] wifi: ath12k: added soc stats for REO Rx data path debug

Enabled the counter for below statistics
	1. REO Rx chip wise
	2. REO Fast Rx chip wise
	3. REO Non Fast Rx chip wise
	4. WBM Release Src module wise error

Chip wise data useful for MLO scenario.

Signed-off-by: Karthikeyan Periyasamy <quic_periyasa@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/core.h    |  6 ++-
 drivers/net/wireless/ath/ath12k/debugfs.c | 50 ++++++++++++++++++++---
 drivers/net/wireless/ath/ath12k/dp_rx.c   | 17 ++++++--
 drivers/net/wireless/ath/ath12k/dp_tx.c   |  2 +-
 4 files changed, 64 insertions(+), 11 deletions(-)

diff --git a/drivers/net/wireless/ath/ath12k/core.h b/drivers/net/wireless/ath/ath12k/core.h
index 8efd75fb257a..3a2a9082a489 100644
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -1079,11 +1079,15 @@ struct ath12k_soc_dp_stats {
 	u32 mcast_enqueued;
 	u32 ucast_enqueued;
 	u32 mcast_reinject;
-	u32 wbm_rel_source[HAL_WBM_REL_SRC_MODULE_MAX];
+	u32 tx_wbm_rel_source[HAL_WBM_REL_SRC_MODULE_MAX];
 	u32 tqm_rel_reason[MAX_TQM_RELEASE_REASON];
 	u32 fw_tx_status[MAX_FW_TX_STATUS];
 	u32 tx_enqueued[MAX_TCL_RING];
 	u32 tx_completed[MAX_TCL_RING];
+	u32 reo_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
+	u32 fast_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
+	u32 non_fast_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
+	u32 rx_wbm_rel_source[HAL_WBM_REL_SRC_MODULE_MAX] [ATH12K_MAX_SOCS];
 	struct ath12k_soc_dp_tx_err_stats tx_err;
 	struct ath12k_dp_ring_bp_stats bp_stats;
 };
diff --git a/drivers/net/wireless/ath/ath12k/debugfs.c b/drivers/net/wireless/ath/ath12k/debugfs.c
index f117c435c524..6ed3e86008cf 100644
--- a/drivers/net/wireless/ath/ath12k/debugfs.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs.c
@@ -1514,6 +1514,8 @@ static ssize_t ath12k_debugfs_dump_soc_dp_stats(struct file *file,
 			"Frame SN equal SSN", "PN check fail", "2k err",
 			"PN err", "Desc blocked"};
 
+	static const char *wbm_rel_src[HAL_WBM_REL_SRC_MODULE_MAX] = {
+				"TQM", "Rxdma", "Reo", "FW", "SW" };
 	char *buf;
 
 	buf = kzalloc(size, GFP_KERNEL);
@@ -1578,12 +1580,12 @@ static ssize_t ath12k_debugfs_dump_soc_dp_stats(struct file *file,
 			soc_stats->mcast_reinject);
 
 	len += scnprintf(buf + len, size - len,
-			"\nwbm_rel_source: 0:%u 1:%u 2:%u 3:%u 4:%u\n",
-			soc_stats->wbm_rel_source[0],
-			soc_stats->wbm_rel_source[1],
-			soc_stats->wbm_rel_source[2],
-			soc_stats->wbm_rel_source[3],
-			soc_stats->wbm_rel_source[4]);
+			"\ntx_wbm_rel_source: 0:%u 1:%u 2:%u 3:%u 4:%u\n",
+			soc_stats->tx_wbm_rel_source[0],
+			soc_stats->tx_wbm_rel_source[1],
+			soc_stats->tx_wbm_rel_source[2],
+			soc_stats->tx_wbm_rel_source[3],
+			soc_stats->tx_wbm_rel_source[4]);
 
 	len += scnprintf(buf + len, size - len,
 			"\ntqm_rel_reason: 0:%u 1:%u 2:%u 3:%u 4:%u 5:%u 6:%u 7:%u 8:%u 9:%u 10:%u 11:%u 12:%u 13:%u\n",
@@ -1626,6 +1628,42 @@ static ssize_t ath12k_debugfs_dump_soc_dp_stats(struct file *file,
 			soc_stats->tx_completed[2],
 			soc_stats->tx_completed[3]);
 
+	len += scnprintf(buf + len, size - len, "\nREO Rx Received:\n");
+	for (i = 0; i < DP_REO_DST_RING_MAX; i++)
+		len += scnprintf(buf + len, size - len,
+				 "Ring%d: 0:%u\t1:%u\t2:%u\n",
+				 i + 1,
+				 soc_stats->reo_rx[i][0],
+				 soc_stats->reo_rx[i][1],
+				 soc_stats->reo_rx[i][2]);
+
+	len += scnprintf(buf + len, size - len, "\nREO Fast Rx:\n");
+	for (i = 0; i < DP_REO_DST_RING_MAX; i++)
+		len += scnprintf(buf + len, size - len,
+				 "Ring%d: 0:%u\t1:%u\t2:%u\n",
+				 i + 1,
+				 soc_stats->fast_rx[i][0],
+				 soc_stats->fast_rx[i][1],
+				 soc_stats->fast_rx[i][2]);
+
+	len += scnprintf(buf + len, size - len, "\nREO Non-Fast Rx:\n");
+	for (i = 0; i < DP_REO_DST_RING_MAX; i++)
+		len += scnprintf(buf + len, size - len,
+				 "Ring%d: 0:%u\t1:%u\t2:%u\n",
+				 i + 1,
+				 soc_stats->non_fast_rx[i][0],
+				 soc_stats->non_fast_rx[i][1],
+				 soc_stats->non_fast_rx[i][2]);
+
+	len += scnprintf(buf + len, size - len, "\nRx WBM REL SRC Errors:\n");
+	for (i = 0; i < HAL_WBM_REL_SRC_MODULE_MAX; i++)
+		len += scnprintf(buf + len, size - len,
+				"%s\t:0:%u\t1:%u\t2:%u\n",
+				wbm_rel_src[i],
+				soc_stats->rx_wbm_rel_source[i][0],
+				soc_stats->rx_wbm_rel_source[i][1],
+				soc_stats->rx_wbm_rel_source[i][2]);
+
 	len += ath12k_debugfs_dump_soc_ring_bp_stats(ab, buf + len, size - len);
 
 	if (len > size)
diff --git a/drivers/net/wireless/ath/ath12k/dp_rx.c b/drivers/net/wireless/ath/ath12k/dp_rx.c
index 05501b0f03f5..5fa88738e02b 100644
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -3230,8 +3230,12 @@ static void ath12k_dp_rx_process_received_packets(struct ath12k_base *ab,
 			continue;
 		}
 
-		if (!fast_rx)
+		if (!fast_rx) {
+			ab->soc_stats.non_fast_rx[ring_id][ar->ab->chip_id]++;
 			ath12k_dp_rx_deliver_msdu(ar, napi, msdu, &rx_info);
+		} else {
+			ab->soc_stats.fast_rx[ring_id][ar->ab->chip_id]++;
+		}
 	}
 
 	rcu_read_unlock();
@@ -3299,7 +3303,7 @@ try_again:
 		if (!ar) {
 			rcu_read_unlock();
 
-			ab->soc_stats.hal_reo_error[dp->reo_dst_ring[ring_id].ring_id]++;
+			ab->soc_stats.hal_reo_error[ring_id]++;
 			ath12k_warn(ab, "Rx with invalid/inactive hw_link_id %d cookie 0x%x\n", hw_link_id, cookie);
 
 			if (desc_info) {
@@ -3338,13 +3342,14 @@ try_again:
 				       DMA_FROM_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);
 
 		num_buffs_reaped[src_ab->chip_id]++;
+		ab->soc_stats.reo_rx[ring_id][src_ab->chip_id]++;
 
 		push_reason = u32_get_bits(desc.info0,
 					   HAL_REO_DEST_RING_INFO0_PUSH_REASON);
 		if (unlikely(push_reason !=
 		    HAL_REO_DEST_RING_PUSH_REASON_ROUTING_INSTRUCTION)) {
 			dev_kfree_skb_any(msdu);
-			ab->soc_stats.hal_reo_error[dp->reo_dst_ring[ring_id].ring_id]++;
+			ab->soc_stats.hal_reo_error[ring_id]++;
 			continue;
 		}
 
@@ -4537,6 +4542,7 @@ int ath12k_dp_rx_process_wbm_err(struct ath12k_base *ab,
 	int num_buffs_reaped = 0;
 	int total_num_buffs_reaped = 0;
 	struct ath12k_rx_desc_info *desc_info;
+	struct ath12k_soc_dp_stats *soc_stats = &ab->soc_stats;
 	int ret;
 	u8 src_link_id;
 
@@ -4641,6 +4647,11 @@ int ath12k_dp_rx_process_wbm_err(struct ath12k_base *ab,
 			continue;
 		}
 
+		rxcb = ATH12K_SKB_RXCB(msdu);
+
+		if (rxcb->err_rel_src < HAL_WBM_REL_SRC_MODULE_MAX)
+			soc_stats->rx_wbm_rel_source[rxcb->err_rel_src][ar->ab->chip_id]++;
+
 		ath12k_dp_rx_wbm_err(ar, napi, msdu, &msdu_list);
 	}
 	rcu_read_unlock();
diff --git a/drivers/net/wireless/ath/ath12k/dp_tx.c b/drivers/net/wireless/ath/ath12k/dp_tx.c
index ed20b568dbbe..8da71658e419 100644
--- a/drivers/net/wireless/ath/ath12k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.c
@@ -1029,7 +1029,7 @@ int ath12k_dp_tx_completion_handler(struct ath12k_base *ab, int ring_id,
 		ath12k_dp_tx_release_txbuf(dp, tx_desc, tx_desc->pool_id);
 		/* Find the HAL_WBM_RELEASE_INFO0_REL_SRC_MODULE value */
 		buf_rel_source = tx_status->info0 & HAL_WBM_RELEASE_INFO0_REL_SRC_MASK;
-		ab->soc_stats.wbm_rel_source[buf_rel_source]++;
+		ab->soc_stats.tx_wbm_rel_source[buf_rel_source]++;
 		if (unlikely(buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW)) {
 			ath12k_dp_tx_process_htt_tx_complete(ab,
 							     (void *)tx_status,
-- 
2.37.0

