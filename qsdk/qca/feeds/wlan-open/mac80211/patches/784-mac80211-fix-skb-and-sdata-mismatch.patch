From a5fe53bfa03ffb18098bd7a1617b938b40edaecd Mon Sep 17 00:00:00 2001
From: Rahul Bhattacharjee <quic_rbhattac@quicinc.com>
Date: Wed, 21 Jun 2023 22:40:02 +0530
Subject: [PATCH] mac80211: fix skb and sdata mismatch

Currently, skbs are getting tagged with wrong sdata, i.e even if the
sdata does not support a skb specific band, we are tagging the sdata
along with that.

In issue scenerio, 1 DUT was having 6G Mesh(root) + 2G AP and the other DUT
was having 2G Mesh(child) , and the packets from 2G Mesh were seeing in
6G Mesh, interface.

In this fix, we tag the sdata is the respective skb's band support is
present.

Signed-off-by: Rahul Bhattacharjee <quic_rbhattac@quicinc.com>
---
 net/mac80211/rx.c | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -5404,6 +5404,11 @@ static void __ieee80211_rx_handle_packet
 	prev = NULL;
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		unsigned int link_id;
+		struct ieee80211_bss_conf *conf;
+		u16 valid_links = sdata->vif.valid_links;
+		bool flag = false;
+
 		if (!ieee80211_sdata_running(sdata))
 			continue;
 
@@ -5411,28 +5416,76 @@ static void __ieee80211_rx_handle_packet
 		    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
 			continue;
 
+		if (valid_links) {
+			for_each_set_bit(link_id, &valid_links,
+					 IEEE80211_MLD_MAX_NUM_LINKS) {
+				conf = rcu_dereference(sdata->vif.link_conf[link_id]);
+
+				if (conf && conf->chandef.chan)
+					if (conf->chandef.chan->center_freq == status->freq) {
+						flag = true;
+						break;
+					}
+			}
+		} else {
+			conf = &sdata->vif.bss_conf;
+
+			if (conf && conf->chandef.chan)
+				if (conf->chandef.chan->center_freq == status->freq)
+					flag = true;
+		}
+
 		/*
 		 * frame is destined for this interface, but if it's
 		 * not also for the previous one we handle that after
 		 * the loop to avoid copying the SKB once too much
 		 */
 
-		if (!prev) {
-			prev = sdata;
-			continue;
-		}
+		if (flag) {
+			if (!prev) {
+				prev = sdata;
+				continue;
+			}
 
-		rx.sdata = prev;
-		ieee80211_rx_for_interface(&rx, skb, false);
+			rx.sdata = prev;
+			ieee80211_rx_for_interface(&rx, skb, false);
 
-		prev = sdata;
+			prev = sdata;
+		}
 	}
 
 	if (prev) {
-		rx.sdata = prev;
+		unsigned int link_id;
+		struct ieee80211_bss_conf *conf;
+		u16 valid_links = prev->vif.valid_links;
+		bool flag = false;
+
+		if (valid_links) {
+			for_each_set_bit(link_id, &valid_links,
+					 IEEE80211_MLD_MAX_NUM_LINKS) {
+				conf = rcu_dereference(prev->vif.link_conf[link_id]);
+
+				if (conf && conf->chandef.chan) {
+					if (conf->chandef.chan->center_freq == status->freq) {
+						flag = true;
+						break;
+					}
+				}
+			}
+		} else {
+			conf = &prev->vif.bss_conf;
+
+			if (conf && conf->chandef.chan)
+				if (conf->chandef.chan->center_freq == status->freq)
+					flag = true;
+		}
 
-		if (ieee80211_rx_for_interface(&rx, skb, true))
-			return;
+		if (flag) {
+			rx.sdata = prev;
+
+			if (ieee80211_rx_for_interface(&rx, skb, true))
+				return;
+		}
 	}
 
  out:
