From d4cde677b823114e947b230e84142d58fee0a710 Mon Sep 17 00:00:00 2001
From: Sriram R <quic_srirrama@quicinc.com>
Date: Thu, 6 Oct 2022 10:44:01 +0530
Subject: [PATCH] hostapd: handle inheritance for per sta profile

Handle inheritance from reporting sta for per sta profile
Also use non inheritance ies while parsing per sta ies

Signed-off-by: Adil Saeed Musthafa <quic_adilm@quicinc.com
Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
---
 src/ap/ieee802_11.c            | 104 ++++++++++++++++++++++++++++++---
 src/common/ieee802_11_common.c | 100 +++++++++++++++++++++++++------
 src/common/ieee802_11_common.h |  15 +++++
 3 files changed, 195 insertions(+), 24 deletions(-)

--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -3710,9 +3710,67 @@ static bool check_sa_query(struct hostap
 	return false;
 }
 
+static int mark_elems(u8 *mark_array, const u8 **ie_ptr, u8 *ie_len)
+{
+	const u8 *pos;
+	u8 len, num_ies;
+	int cnt;
+
+	pos = *ie_ptr;
+	len = *ie_len;
+
+	if (len == 0)
+		return -1;
+
+	num_ies = *pos;
+	pos++;
+	len--;
+	if (len < num_ies) {
+
+		wpa_printf(MSG_ERROR,
+				"%s: ERROR!! Not enough length in "
+				"non_inheritance IE\n", __func__);
+		return -1;
+	}
+
+	for (cnt = 0; cnt < num_ies; cnt++) {
+		u8 ie;
+
+		ie = *pos;
+		pos++;
+		len--;
+		/*
+		 * each IE is represented by a bit.
+		 * so set the appropriate bit in the 256-bit array
+		 * (32-byte array)
+		 */
+		mark_array[ie/8] |= (1 << (ie % 8));
+	}
+
+	*ie_ptr = pos;
+	*ie_len = len;
+	return 0;
+}
+
+/*
+ * This function creates the non_inherit structure from the
+ * non-inheritance IE inside the frame
+ */
+static void mark_non_inheritance_elems(struct non_inheritance_elems *non_inherit,
+				       const u8 *ie_ptr,
+				       u8 ie_len)
+{
+	if (mark_elems(non_inherit->non_inherit, &ie_ptr, &ie_len))
+		return;
+
+	if (mark_elems(non_inherit->non_inherit_ext, &ie_ptr, &ie_len))
+		return;
+}
 
 static int check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
-			   const u8 *ies, size_t ies_len, int reassoc)
+			   const u8 *ies, size_t ies_len,
+			   const u8* inherit_ies, size_t inherit_ies_len,
+			   int reassoc)
 {
 	struct ieee802_11_elems elems;
 	int resp;
@@ -3720,11 +3778,43 @@ static int check_assoc_ies(struct hostap
 	size_t wpa_ie_len;
 	const u8 *p2p_dev_addr = NULL;
 
-	if (ieee802_11_parse_elems(ies, ies_len, &elems, 1) == ParseFailed) {
-		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
-			       HOSTAPD_LEVEL_INFO, "Station sent an invalid "
-			       "association request");
-		return WLAN_STATUS_UNSPECIFIED_FAILURE;
+	if (inherit_ies) {
+
+		const u8 *non_inherit_ie = NULL;
+		struct non_inheritance_elems non_inherit = {0};
+
+		non_inherit_ie =
+		get_ie_ext(ies, ies_len, WLAN_EID_EXT_NON_INHERITANCE);
+		if (non_inherit_ie)
+			mark_non_inheritance_elems(&non_inherit,
+						   non_inherit_ie+2+1,
+						   non_inherit_ie[1]-1);
+
+		if (ieee802_11_parse_elems_sta_profile(inherit_ies,
+						       inherit_ies_len,
+						       &elems, 1, 0,
+						       &non_inherit) ==
+						       ParseFailed) {
+			hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+					HOSTAPD_LEVEL_INFO, "Station sent an invalid "
+					"association request");
+			return WLAN_STATUS_UNSPECIFIED_FAILURE;
+		}
+		if (ieee802_11_parse_elems_sta_profile(ies, ies_len, &elems, 1,
+						       1, NULL) == ParseFailed) {
+			hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+					HOSTAPD_LEVEL_INFO, "Station sent an invalid "
+					"association request");
+			return WLAN_STATUS_UNSPECIFIED_FAILURE;
+		}
+
+	} else {
+		if (ieee802_11_parse_elems(ies, ies_len, &elems, 1) == ParseFailed) {
+			hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+					HOSTAPD_LEVEL_INFO, "Station sent an invalid "
+					"association request");
+			return WLAN_STATUS_UNSPECIFIED_FAILURE;
+		}
 	}
 
 	resp = check_ssid(hapd, sta, elems.ssid, elems.ssid_len);
@@ -4964,7 +5054,7 @@ static void handle_assoc(struct hostapd_
 
 	/* followed by SSID and Supported rates; and HT capabilities if 802.11n
 	 * is used */
-	resp = check_assoc_ies(hapd, sta, pos, left, reassoc);
+	resp = check_assoc_ies(hapd, sta, pos, left, NULL, 0, reassoc);
 	if (resp != WLAN_STATUS_SUCCESS)
 		goto fail;
 	omit_rsnxe = !get_ie(pos, left, WLAN_EID_RSNX);
--- a/src/common/ieee802_11_common.c
+++ b/src/common/ieee802_11_common.c
@@ -198,6 +198,23 @@ static int ieee802_11_parse_vendor_speci
 	return 0;
 }
 
+static int
+is_part_of_non_inheritance(struct non_inheritance_elems *non_inherit,
+						   u8 id)
+{
+
+	if (non_inherit == NULL)
+		return 0;
+	return (non_inherit->non_inherit[id/8] & (1 << (id%8)));
+}
+
+static int
+is_part_of_non_inheritance_ext(struct non_inheritance_elems *non_inherit, u8 id)
+{
+	if (non_inherit == NULL)
+		return 0;
+	return (non_inherit->non_inherit_ext[id/8] & (1 << (id%8)));
+}
 
 static int ieee802_11_parse_mle(const u8 *pos, size_t elen, size_t **total_len,
 				struct ieee802_11_elems *elems,
@@ -265,7 +282,9 @@ static size_t ieee802_11_fragments_lengt
 static int ieee802_11_parse_extension(const u8 *pos, size_t elen,
 				      struct ieee802_11_elems *elems,
 				      const u8 *start, size_t len,
-				      int show_errors)
+				      int show_errors,
+				      int is_ml_sta_profile_ie,
+				      struct non_inheritance_elems *non_inherit)
 {
 	u8 ext_id;
 	size_t *total_len = NULL;
@@ -281,6 +300,10 @@ static int ieee802_11_parse_extension(co
 	ext_id = *pos++;
 	elen--;
 
+	if (is_part_of_non_inheritance_ext(non_inherit, ext_id)) {
+		return 0;
+	}
+
 	switch (ext_id) {
 	case WLAN_EID_EXT_ASSOC_DELAY_INFO:
 		if (elen != 1)
@@ -381,6 +404,23 @@ static int ieee802_11_parse_extension(co
 		elems->eht_operation_len = elen;
 		break;
 	case WLAN_EID_EXT_MULTI_LINK:
+		/*
+                 * This check is needed to make sure we don't
+                 * 1. allow ML-IE inside STA-Profile IEs
+                 * 2. parse Multi-link again as part of the parent IEs
+                 *
+                 * Elaborating on point number-2, we have already parsed
+                 * the Multi-Link element in the outer core frame, then
+                 * we don't want to parse it again when this function is called
+                 * as part of the STA clone creation (copying the inherited
+                 * IEs to the clone STA). ML-IE from the parent should not be
+                 * part of the cloned STA.
+                 */
+                if ((non_inherit == NULL) && !is_ml_sta_profile_ie) {
+                        elems->mle = pos;
+                        elems->mle_len = elen;
+                }
+
 		if (elen < 2)
 			break;
 		if (ieee802_11_parse_mle(pos, elen, &total_len, elems,
@@ -391,10 +431,6 @@ static int ieee802_11_parse_extension(co
 		elems->mbssid_known_bss = pos;
 		elems->mbssid_known_bss_len = elen;
 		break;
-	case WLAN_EID_EXT_MULTI_LINK:
-		elems->mle = pos;
-		elems->mle_len = elen;
-		break;
 	default:
 		if (show_errors) {
 			wpa_printf(MSG_MSGDUMP,
@@ -412,22 +448,17 @@ static int ieee802_11_parse_extension(co
 }
 
 
-/**
- * ieee802_11_parse_elems - Parse information elements in management frames
- * @start: Pointer to the start of IEs
- * @len: Length of IE buffer in octets
- * @elems: Data structure for parsed elements
- * @show_errors: Whether to show parsing errors in debug log
- * Returns: Parsing result
- */
-ParseRes ieee802_11_parse_elems(const u8 *start, size_t len,
-				struct ieee802_11_elems *elems,
-				int show_errors)
+static ParseRes ieee802_11_parse_elems_helper(const u8 *start, size_t len,
+					      struct ieee802_11_elems *elems,
+					      int show_errors,
+					      int is_ie_part_of_sta_profile,
+					      struct non_inheritance_elems *non_inherit)
 {
 	const struct element *elem;
 	int unknown = 0;
 
-	os_memset(elems, 0, sizeof(*elems));
+	if (!is_ie_part_of_sta_profile)
+		os_memset(elems, 0, sizeof(*elems));
 
 	if (!start)
 		return ParseOK;
@@ -442,6 +473,9 @@ ParseRes ieee802_11_parse_elems(const u8
 		}
 		elems->num_frag_elems = 0;
 
+		if (is_part_of_non_inheritance(non_inherit, id))
+			continue;
+
 		switch (id) {
 		case WLAN_EID_SSID:
 			if (elen > SSID_MAX_LEN) {
@@ -450,7 +484,7 @@ ParseRes ieee802_11_parse_elems(const u8
 					   elen);
 				break;
 			}
-			if (elems->ssid) {
+			if (!is_ie_part_of_sta_profile && elems->ssid) {
 				wpa_printf(MSG_MSGDUMP,
 					   "Ignored duplicated SSID element");
 				break;
@@ -651,7 +685,9 @@ ParseRes ieee802_11_parse_elems(const u8
 			break;
 		case WLAN_EID_EXTENSION:
 			if (ieee802_11_parse_extension(pos, elen, elems, start,
-						       len, show_errors))
+						       len, show_errors,
+						       is_ie_part_of_sta_profile,
+						       non_inherit))
 				unknown++;
 			break;
 		default:
@@ -680,6 +716,34 @@ done:
 }
 
 
+/**
+ * ieee802_11_parse_elems - Parse information elements in management frames
+ * @start: Pointer to the start of IEs
+ * @len: Length of IE buffer in octets
+ * @elems: Data structure for parsed elements
+ * @show_errors: Whether to show parsing errors in debug log
+ * Returns: Parsing result
+ */
+ParseRes ieee802_11_parse_elems(const u8 *start, size_t len,
+				struct ieee802_11_elems *elems,
+				int show_errors)
+{
+	return ieee802_11_parse_elems_helper(start, len, elems,
+					     show_errors, 0, NULL);
+}
+
+ParseRes ieee802_11_parse_elems_sta_profile(const u8 *start, size_t len,
+					    struct ieee802_11_elems *elems,
+					    int show_errors,
+					    int is_ie_part_of_sta_profile,
+					    struct non_inheritance_elems *non_inherit)
+{
+	return ieee802_11_parse_elems_helper(start, len, elems,
+					     show_errors,
+					     is_ie_part_of_sta_profile,
+					     non_inherit);
+}
+
 int ieee802_11_ie_count(const u8 *ies, size_t ies_len)
 {
 	const struct element *elem;
--- a/src/common/ieee802_11_common.h
+++ b/src/common/ieee802_11_common.h
@@ -255,9 +255,24 @@ struct ieee802_11_elems {
 
 typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;
 
+struct non_inheritance_elems {
+	/*
+	 * we need 256 bits each for EIDs and ext-EIDs
+	 * to get 256 bits, we need 32 bytes
+	 * so 32 bytes each for EIDs and  ext-EIDs
+	 */
+	u8 non_inherit[32];
+	u8 non_inherit_ext[32];
+};
+
 ParseRes ieee802_11_parse_elems(const u8 *start, size_t len,
 				struct ieee802_11_elems *elems,
 				int show_errors);
+ParseRes ieee802_11_parse_elems_sta_profile(const u8 *start, size_t len,
+					    struct ieee802_11_elems *elems,
+					    int show_errors,
+					    int is_ie_part_of_sta_profile,
+					    struct non_inheritance_elems *non_inherit);
 int ieee802_11_ie_count(const u8 *ies, size_t ies_len);
 struct wpabuf * ieee802_11_vendor_ie_concat(const u8 *ies, size_t ies_len,
 					    u32 oui_type);
