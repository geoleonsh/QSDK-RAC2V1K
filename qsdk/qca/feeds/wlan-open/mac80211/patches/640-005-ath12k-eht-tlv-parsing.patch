From 260227e439754b4b5790a0a23819e265c1700faa Mon Sep 17 00:00:00 2001
From: P Praneesh <quic_ppranees@quicinc.com>
Date: Thu, 23 Jun 2022 10:47:16 +0530
Subject: [PATCH] ath12k: add EHT tlv parsing for monitor mode

In addition to the legacy training and signaling fields, 802.11be introduces
U-SIG and EHT-SIG TLVs which provides EHT related informations for Single
user and Multi-users. Add parsing logic to store the EHT specific information
to the ppdu_info structure which is further used to build radiotap header.

Signed-off-by: P Praneesh <quic_ppranees@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/dp_mon.c   | 907 ++++++++++++++++++++++++++++-
 drivers/net/wireless/ath/ath12k/hal_desc.h |   9 +-
 drivers/net/wireless/ath/ath12k/hal_rx.h   | 534 +++++++++++++++++
 3 files changed, 1447 insertions(+), 3 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/dp_mon.c
+++ b/drivers/net/wireless/ath/ath12k/dp_mon.c
@@ -580,12 +580,880 @@ static void ath12k_dp_mon_parse_he_sig_s
 	ppdu_info->reception_type = HAL_RX_RECEPTION_TYPE_SU;
 }
 
+static inline u32
+ath12k_dp_mon_hal_rx_parse_u_sig_cmn(u8 *rx_tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_mon_usig_hdr *usig = (struct hal_mon_usig_hdr *)rx_tlv;
+	struct hal_mon_usig_cmn *usig_1 = &usig->usig_1;
+	u32 phy_version, bandwidth, ul_dl, bss_color, txop;
+	u8 bad_usig_crc;
+
+	bad_usig_crc = u32_get_bits(__le32_to_cpu(usig->usig_2.tb.info0),
+				    HAL_RX_USIG_TB_INFO0_RX_INTEG_CHECK_PASS);
+	ppdu_info->usig_common |=
+			USIG_PHY_VERSION_KNOWN |
+			USIG_BW_KNOWN |
+			USIG_UL_DL_KNOWN |
+			USIG_BSS_COLOR_KNOWN |
+			USIG_TXOP_KNOWN;
+
+	phy_version = u32_get_bits(__le32_to_cpu(usig_1->info0),
+				   HAL_RX_USIG_CMN_INFO0_PHY_VERSION);
+	ppdu_info->usig_common |= (phy_version << USIG_PHY_VERSION_SHIFT);
+
+	bandwidth = u32_get_bits(__le32_to_cpu(usig_1->info0),
+				 HAL_RX_USIG_CMN_INFO0_BW);
+	ppdu_info->usig_common |= (bandwidth << USIG_BW_SHIFT);
+
+	ul_dl = u32_get_bits(__le32_to_cpu(usig_1->info0),
+			     HAL_RX_USIG_CMN_INFO0_UL_DL);
+	ppdu_info->usig_common |= (ul_dl << USIG_UL_DL_SHIFT);
+
+	bss_color = u32_get_bits(__le32_to_cpu(usig_1->info0),
+				 HAL_RX_USIG_CMN_INFO0_BSS_COLOR);
+	ppdu_info->usig_common |= (bss_color << USIG_BSS_COLOR_SHIFT);
+
+	txop = u32_get_bits(__le32_to_cpu(usig_1->info0),
+			    HAL_RX_USIG_CMN_INFO0_TXOP);
+
+	ppdu_info->usig_common |= (txop << USIG_TXOP_SHIFT);
+	ppdu_info->usig_common |= bad_usig_crc;
+	ppdu_info->u_sig_info.ul_dl = ul_dl;
+	ppdu_info->u_sig_info.bw = bandwidth;
+	ppdu_info->bw = bandwidth;
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_u_sig_tb(u8 *rx_tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_mon_usig_hdr *usig = (struct hal_mon_usig_hdr *)rx_tlv;
+	struct hal_mon_usig_tb *usig_tb = &usig->usig_2.tb;
+	u32 ppdu_type_comp_mode, spatial_reuse_1, spatial_reuse_2, crc, tail;
+
+	ppdu_info->usig_mask |=
+			USIG_DISREGARD_KNOWN |
+			USIG_PPDU_TYPE_N_COMP_MODE_KNOWN |
+			USIG_VALIDATE_KNOWN |
+			USIG_TB_SPATIAL_REUSE_1_KNOWN |
+			USIG_TB_SPATIAL_REUSE_2_KNOWN |
+			USIG_TB_DISREGARD1_KNOWN |
+			USIG_CRC_KNOWN |
+			USIG_TAIL_KNOWN;
+
+	ppdu_info->usig_value |= (0x3F << USIG_DISREGARD_SHIFT);
+	ppdu_type_comp_mode = u32_get_bits(__le32_to_cpu(usig_tb->info0),
+					   HAL_RX_USIG_TB_INFO0_PPDU_TYPE_COMP_MODE);
+	ppdu_info->usig_value |=
+		(ppdu_type_comp_mode << USIG_PPDU_TYPE_N_COMP_MODE_SHIFT);
+
+	ppdu_info->usig_value |= (0x1 << USIG_VALIDATE_SHIFT);
+	spatial_reuse_1 = u32_get_bits(__le32_to_cpu(usig_tb->info0),
+				       HAL_RX_USIG_TB_INFO0_SPATIAL_REUSE_1);
+	ppdu_info->usig_value |=
+		(spatial_reuse_1 << USIG_TB_SPATIAL_REUSE_1_SHIFT);
+
+	spatial_reuse_2 = u32_get_bits(__le32_to_cpu(usig_tb->info0),
+				       HAL_RX_USIG_TB_INFO0_SPATIAL_REUSE_2);
+	ppdu_info->usig_value |=
+		(spatial_reuse_2 << USIG_TB_SPATIAL_REUSE_2_SHIFT);
+
+	ppdu_info->usig_value |= (0x1F << USIG_TB_DISREGARD1_SHIFT);
+	crc = u32_get_bits(__le32_to_cpu(usig_tb->info0),
+			   HAL_RX_USIG_TB_INFO0_CRC);
+	ppdu_info->usig_value |= (crc << USIG_CRC_SHIFT);
+	tail = u32_get_bits(__le32_to_cpu(usig_tb->info0),
+			    HAL_RX_USIG_TB_INFO0_TAIL);
+	ppdu_info->usig_value |= (tail << USIG_TAIL_SHIFT);
+
+	ppdu_info->u_sig_info.ppdu_type_comp_mode = ppdu_type_comp_mode;
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline uint32_t
+ath12k_dp_mon_hal_rx_parse_u_sig_mu(u8 *rx_tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_mon_usig_hdr *usig = (struct hal_mon_usig_hdr *)rx_tlv;
+	struct hal_mon_usig_mu *usig_mu = &usig->usig_2.mu;
+	u32 ppdu_type_comp_mode, punc_ch_info, eht_sig_mcs, num_eht_sig_sym, crc, tail;
+
+	ppdu_info->usig_mask |=
+		USIG_DISREGARD_KNOWN |
+		USIG_PPDU_TYPE_N_COMP_MODE_KNOWN |
+		USIG_VALIDATE_KNOWN |
+		USIG_MU_VALIDATE1_SHIFT |
+		USIG_MU_PUNCTURE_CH_INFO_KNOWN |
+		USIG_MU_VALIDATE2_SHIFT |
+		USIG_MU_EHT_SIG_MCS_KNOWN |
+		USIG_MU_NUM_EHT_SIG_SYM_KNOWN |
+		USIG_CRC_KNOWN |
+		USIG_TAIL_KNOWN;
+
+	ppdu_info->usig_value |= (0x1F << USIG_DISREGARD_SHIFT);
+	ppdu_info->usig_value |= (0x1 << USIG_MU_VALIDATE1_SHIFT);
+
+	ppdu_type_comp_mode = u32_get_bits(__le32_to_cpu(usig_mu->info0),
+					   HAL_RX_USIG_MU_INFO0_PPDU_TYPE_COMP_MODE);
+	ppdu_info->usig_value |=
+		(ppdu_type_comp_mode << USIG_PPDU_TYPE_N_COMP_MODE_SHIFT);
+	ppdu_info->usig_value |= (0x1 << USIG_VALIDATE_SHIFT);
+
+	punc_ch_info = u32_get_bits(__le32_to_cpu(usig_mu->info0),
+				    HAL_RX_USIG_MU_INFO0_PUNC_CH_INFO);
+	ppdu_info->usig_value |= (punc_ch_info << USIG_MU_PUNCTURE_CH_INFO_SHIFT);
+	ppdu_info->usig_value |= (0x1 << USIG_MU_VALIDATE2_SHIFT);
+
+	eht_sig_mcs = u32_get_bits(__le32_to_cpu(usig_mu->info0),
+				   HAL_RX_USIG_MU_INFO0_EHT_SIG_MCS);
+	ppdu_info->usig_value |= (eht_sig_mcs << USIG_MU_EHT_SIG_MCS_SHIFT);
+
+	num_eht_sig_sym = u32_get_bits(__le32_to_cpu(usig_mu->info0),
+				       HAL_RX_USIG_MU_INFO0_NUM_EHT_SIG_SYM);
+	ppdu_info->usig_value |= (num_eht_sig_sym << USIG_MU_NUM_EHT_SIG_SYM_SHIFT);
+
+	crc = u32_get_bits(__le32_to_cpu(usig_mu->info0), HAL_RX_USIG_MU_INFO0_CRC);
+	ppdu_info->usig_value |= (crc << USIG_CRC_SHIFT);
+
+	tail = u32_get_bits(__le32_to_cpu(usig_mu->info0), HAL_RX_USIG_MU_INFO0_TAIL);
+	ppdu_info->usig_value |= (tail << USIG_TAIL_SHIFT);
+	ppdu_info->u_sig_info.ppdu_type_comp_mode = ppdu_type_comp_mode;
+	ppdu_info->u_sig_info.eht_sig_mcs = eht_sig_mcs;
+	ppdu_info->u_sig_info.num_eht_sig_sym = num_eht_sig_sym;
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_u_sig_hdr(u8 *rx_tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_mon_usig_hdr *usig = (struct hal_mon_usig_hdr *)rx_tlv;
+	struct hal_mon_usig_cmn *usig_cmn = &usig->usig_1;
+	u8 comp_mode;
+	bool ul_dl;
+
+        ppdu_info->usig_flags = 1;
+
+	ath12k_dp_mon_hal_rx_parse_u_sig_cmn(rx_tlv, ppdu_info);
+
+	ul_dl = u32_get_bits(__le32_to_cpu(usig_cmn->info0), HAL_RX_USIG_CMN_INFO0_UL_DL);
+
+	comp_mode = u32_get_bits(__le32_to_cpu(usig->usig_2.mu.info0),
+				 HAL_RX_USIG_MU_INFO0_PPDU_TYPE_COMP_MODE);
+
+	if (comp_mode == 0 && ul_dl)
+		return ath12k_dp_mon_hal_rx_parse_u_sig_tb(rx_tlv, ppdu_info);
+	 else
+		return ath12k_dp_mon_hal_rx_parse_u_sig_mu(rx_tlv, ppdu_info);
+}
+
+static enum hal_rx_mon_status
+ath12k_dp_mon_hal_aggr_tlv(struct hal_rx_mon_ppdu_info *ppdu_info,
+				   u16 tlv_len, u8 *tlv_data)
+{
+	if (tlv_len <= HAL_RX_MON_MAX_AGGR_SIZE - ppdu_info->tlv_aggr.cur_len) {
+		memcpy(ppdu_info->tlv_aggr.buf + ppdu_info->tlv_aggr.cur_len,
+		       tlv_data, tlv_len);
+		ppdu_info->tlv_aggr.cur_len += tlv_len;
+	}
+
+	return HAL_RX_MON_STATUS_PPDU_NOT_DONE;
+}
+
+static inline bool
+ath12k_dp_mon_hal_rx_is_mu_mimo_user(struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	if (ppdu_info->u_sig_info.ppdu_type_comp_mode == HAL_RX_RECEPTION_TYPE_SU &&
+	    ppdu_info->u_sig_info.ul_dl == 1)
+		return true;
+
+	return false;
+}
+
+static inline bool
+ath12k_dp_mon_hal_rx_is_frame_type_ndp(struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	if (ppdu_info->u_sig_info.ppdu_type_comp_mode == 1 &&
+	    ppdu_info->u_sig_info.eht_sig_mcs == 0 &&
+	    ppdu_info->u_sig_info.num_eht_sig_sym == 0)
+		return true;
+
+	return false;
+}
+
+static inline bool
+ath12k_dp_mon_hal_rx_is_non_ofdma(struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	u32 ppdu_type_comp_mode = ppdu_info->u_sig_info.ppdu_type_comp_mode;
+	u32 ul_dl = ppdu_info->u_sig_info.ul_dl;
+
+	if ((ppdu_type_comp_mode == HAL_RX_RECEPTION_TYPE_MU_MIMO && ul_dl == 0) ||
+	    (ppdu_type_comp_mode == HAL_RX_RECEPTION_TYPE_MU_OFDMA && ul_dl == 0) ||
+	    (ppdu_type_comp_mode == HAL_RX_RECEPTION_TYPE_MU_MIMO  && ul_dl == 1))
+		return true;
+
+	return false;
+}
+
+static inline bool
+ath12k_dp_mon_hal_rx_is_ofdma(struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	if (ppdu_info->u_sig_info.ppdu_type_comp_mode == 0 &&
+	    ppdu_info->u_sig_info.ul_dl == 0)
+		return true;
+
+	return false;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_eht_sig_ndp(u8 *tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+        struct hal_eht_sig_ndp_cmn_eb *eht_sig_ndp =
+				(struct hal_eht_sig_ndp_cmn_eb *)tlv;
+	u32 spatial_reuse, num_ltf_sym, nss, beamformed, crc;
+
+        ppdu_info->eht_known |=
+		EHT_SPATIAL_REUSE_KNOWN |
+		EHT_EHT_LTF_KNOWN |
+		EHT_NDP_NSS_KNOWN |
+		EHT_NDP_BEAMFORMED_KNOWN |
+		EHT_NDP_DISREGARD_KNOWN |
+		EHT_CRC1_KNOWN |
+		EHT_TAIL1_KNOWN;
+
+	spatial_reuse = u32_get_bits(__le32_to_cpu(eht_sig_ndp->info0),
+				     HAL_RX_EHT_SIG_NDP_CMN_INFO0_SPATIAL_REUSE);
+	ppdu_info->eht_data[0] |= (spatial_reuse << EHT_SPATIAL_REUSE_SHIFT);
+
+	/*
+	 * GI and LTF size are separately indicated in radiotap header
+	 * and hence will be parsed from other TLV
+	 */
+	num_ltf_sym = u32_get_bits(__le32_to_cpu(eht_sig_ndp->info0),
+				   HAL_RX_EHT_SIG_NDP_CMN_INFO0_GI_LTF);
+	ppdu_info->eht_data[0] |= (num_ltf_sym << EHT_EHT_LTF_SHIFT);
+	ppdu_info->eht_data[0] |= (0xF << EHT_NDP_DISREGARD_SHIFT);
+
+	nss = u32_get_bits(__le32_to_cpu(eht_sig_ndp->info0),
+			   HAL_RX_EHT_SIG_NDP_CMN_INFO0_NSS);
+	ppdu_info->eht_data[4] |= (nss << EHT_NDP_NSS_SHIFT);
+
+	beamformed = u32_get_bits(__le32_to_cpu(eht_sig_ndp->info0),
+				  HAL_RX_EHT_SIG_NDP_CMN_INFO0_BEAMFORMED);
+	ppdu_info->eht_data[4] |= (beamformed << EHT_NDP_BEAMFORMED_SHIFT);
+
+	crc = u32_get_bits(__le32_to_cpu(eht_sig_ndp->info0),
+			   HAL_RX_EHT_SIG_NDP_CMN_INFO0_CRC);
+	ppdu_info->eht_data[0] |= (crc << EHT_CRC1_SHIFT);
+
+        return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_usig_overflow(u8 *tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_eht_sig_cc_usig_overflow *usig_ovflow =
+		(struct hal_eht_sig_cc_usig_overflow *)tlv;
+	u32 spatial_reuse, num_ltf_sym, ldpc_extra_sym, pre_fec_pad_factor, disambiguity;
+
+        ppdu_info->eht_known |=
+		EHT_SPATIAL_REUSE_KNOWN |
+		EHT_EHT_LTF_KNOWN |
+		EHT_LDPC_EXTRA_SYMBOL_SEG_KNOWN |
+		EHT_PRE_FEC_PADDING_FACTOR_KNOWN |
+		EHT_PE_DISAMBIGUITY_KNOWN |
+		EHT_DISREARD_KNOWN;
+
+	spatial_reuse = u32_get_bits(__le32_to_cpu(usig_ovflow->info0),
+				     HAL_RX_EHT_SIG_OVERFLOW_INFO0_SPATIAL_REUSE);
+	ppdu_info->eht_data[0] |= (spatial_reuse << EHT_SPATIAL_REUSE_SHIFT);
+
+	/*
+	 * GI and LTF size are separately indicated in radiotap header
+	 * and hence will be parsed from other TLV
+	 */
+	num_ltf_sym = u32_get_bits(__le32_to_cpu(usig_ovflow->info0),
+				   HAL_RX_EHT_SIG_OVERFLOW_INFO0_NUM_LTF_SYM);
+	ppdu_info->eht_data[0] |= (num_ltf_sym << EHT_EHT_LTF_SHIFT);
+
+	ldpc_extra_sym = u32_get_bits(__le32_to_cpu(usig_ovflow->info0),
+				      HAL_RX_EHT_SIG_OVERFLOW_INFO0_LDPC_EXTA_SYM);
+	ppdu_info->eht_data[0] |= (ldpc_extra_sym << EHT_LDPC_EXTRA_SYMBOL_SEG_SHIFT);
+
+	pre_fec_pad_factor = u32_get_bits(__le32_to_cpu(usig_ovflow->info0),
+				HAL_RX_EHT_SIG_OVERFLOW_INFO0_PRE_FEC_PAD_FACTOR);
+	ppdu_info->eht_data[0] |= (pre_fec_pad_factor <<
+				   EHT_PRE_FEC_PADDING_FACTOR_SHIFT);
+
+	disambiguity = u32_get_bits(__le32_to_cpu(usig_ovflow->info0),
+				    HAL_RX_EHT_SIG_OVERFLOW_INFO0_DISAMBIGUITY);
+	ppdu_info->eht_data[0] |= (disambiguity << EHT_PE_DISAMBIGUITY_SHIFT);
+	ppdu_info->eht_data[0] |= (0xF << EHT_DISREGARD_SHIFT);
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_ru_allocation(u8 *tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	u64 *ehtsig_tlv = (u64 *)tlv;
+	struct hal_eht_sig_ofdma_cmn_eb1 *ofdma_cmn_eb1;
+	struct hal_eht_sig_ofdma_cmn_eb2 *ofdma_cmn_eb2;
+	u32 ru_allocation2_6, ru_allocation2_5, ru_allocation2_4, ru_allocation2_3;
+	u32 ru_allocation2_2, ru_allocation2_1, ru_allocation1_2, ru_allocation1_1;
+	u8 num_ru_allocation_known = 0;
+
+	ofdma_cmn_eb1 = (struct hal_eht_sig_ofdma_cmn_eb1 *)ehtsig_tlv;
+	ofdma_cmn_eb2 = (struct hal_eht_sig_ofdma_cmn_eb2 *)(ehtsig_tlv + 1);
+
+	switch (ppdu_info->u_sig_info.bw) {
+	case HAL_EHT_BW_320_2:
+	case HAL_EHT_BW_320_1:
+		num_ru_allocation_known += 4;
+		ru_allocation2_6 = u64_get_bits(__le64_to_cpu(ofdma_cmn_eb2->info0),
+						HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_6);
+		ppdu_info->eht_data[3] |= (ru_allocation2_6 << EHT_RU_ALLOCATION2_6_SHIFT);
+
+		ru_allocation2_5 = u64_get_bits(__le64_to_cpu(ofdma_cmn_eb2->info0),
+						HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_5);
+		ppdu_info->eht_data[3] |= (ru_allocation2_5 << EHT_RU_ALLOCATION2_5_SHIFT);
+
+		ru_allocation2_4 = u64_get_bits(__le64_to_cpu(ofdma_cmn_eb2->info0),
+						HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_4);
+		ppdu_info->eht_data[3] |= (ru_allocation2_4 << EHT_RU_ALLOCATION2_4_SHIFT);
+
+		ru_allocation2_3 = u64_get_bits(__le64_to_cpu(ofdma_cmn_eb2->info0),
+						HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_3);
+		ppdu_info->eht_data[2] |= (ru_allocation2_3 << EHT_RU_ALLOCATION2_3_SHIFT);
+	        /* fallthrough */
+	case HAL_EHT_BW_160:
+		num_ru_allocation_known += 2;
+		ru_allocation2_2 = u64_get_bits(__le64_to_cpu(ofdma_cmn_eb2->info0),
+						HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_2);
+		ppdu_info->eht_data[2] |=
+				(ru_allocation2_2 << EHT_RU_ALLOCATION2_2_SHIFT);
+		ru_allocation2_1 = u64_get_bits(__le64_to_cpu(ofdma_cmn_eb2->info0),
+						HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_1);
+		ppdu_info->eht_data[2] |=
+				(ru_allocation2_1 << EHT_RU_ALLOCATION2_1_SHIFT);
+		/* fallthrough */
+	case HAL_EHT_BW_80:
+		num_ru_allocation_known += 1;
+		ru_allocation1_2 = u64_get_bits(__le64_to_cpu(ofdma_cmn_eb1->info0),
+						HAL_RX_EHT_SIG_OFDMA_EB1_RU_ALLOC_1_2);
+		ppdu_info->eht_data[1] |=
+				(ru_allocation1_2 << EHT_RU_ALLOCATION1_2_SHIFT);
+		/* fallthrough */
+	case HAL_EHT_BW_40:
+	case HAL_EHT_BW_20:
+		num_ru_allocation_known += 1;
+		ru_allocation1_1 = u64_get_bits(__le64_to_cpu(ofdma_cmn_eb1->info0),
+						HAL_RX_EHT_SIG_OFDMA_EB1_RU_ALLOC_1_1);
+		ppdu_info->eht_data[1] |=
+				(ru_allocation1_1 << EHT_RU_ALLOCATION1_1_SHIFT);
+		break;
+	default:
+	        break;
+        }
+
+        ppdu_info->eht_known |=
+		(num_ru_allocation_known << EHT_NUM_KNOWN_RU_ALLOCATIONS_SHIFT);
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline uint32_t
+ath12k_dp_mon_hal_rx_parse_non_ofdma_users(u8 *tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_eht_sig_non_ofdma_cmn_eb *non_ofdma_cmn_eb =
+	                        (struct hal_eht_sig_non_ofdma_cmn_eb *)tlv;
+	u32 num_users;
+
+	ppdu_info->eht_known |= EHT_NUM_NON_OFDMA_USERS_KNOWN;
+	num_users = u32_get_bits(__le32_to_cpu(non_ofdma_cmn_eb->info0),
+				 HAL_RX_EHT_SIG_NON_OFDMA_INFO0_NUM_USERS);
+	ppdu_info->eht_data[4] |= (num_users << EHT_NUM_NON_OFDMA_USERS_SHIFT);
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_eht_sig_mumimo_user_info(u8 *tlv,
+						    struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_eht_sig_mu_mimo_user_info *user_info;
+	u32 user_idx = ppdu_info->num_eht_user_info_valid;
+	u32 sta_id, mcs, coding, spatial_coding, crc;
+
+	user_info = (struct hal_eht_sig_mu_mimo_user_info *)tlv;
+
+	ppdu_info->eht_user_info[user_idx] |=
+				EHT_USER_STA_ID_KNOWN |
+				EHT_USER_MCS_KNOWN |
+				EHT_USER_CODING_KNOWN |
+				EHT_USER_SPATIAL_CONFIG_KNOWN;
+
+	sta_id = u32_get_bits(__le32_to_cpu(user_info->info0),
+			      HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_STA_ID);
+	ppdu_info->eht_user_info[user_idx] |= (sta_id << EHT_USER_STA_ID_SHIFT);
+
+	mcs = u32_get_bits(__le32_to_cpu(user_info->info0),
+			   HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_MCS);
+	ppdu_info->eht_user_info[user_idx] |= (mcs << EHT_USER_MCS_SHIFT);
+	ppdu_info->mcs = mcs;
+
+	coding = u32_get_bits(__le32_to_cpu(user_info->info0),
+			      HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_CODING);
+	ppdu_info->eht_user_info[user_idx] |= (coding << EHT_USER_CODING_SHIFT);
+
+	spatial_coding = u32_get_bits(__le32_to_cpu(user_info->info0),
+				      HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_SPATIAL_CODING);
+	ppdu_info->eht_user_info[user_idx] |=
+        	              	(spatial_coding << EHT_USER_SPATIAL_CONFIG_SHIFT);
+
+	/* CRC for matched user block */
+	ppdu_info->eht_known |=
+			EHT_USER_ENC_BLOCK_CRC_KNOWN |
+			EHT_USER_ENC_BLOCK_TAIL_KNOWN;
+
+	crc = u32_get_bits(__le32_to_cpu(user_info->info0),
+			   HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_CRC);
+	ppdu_info->eht_data[4] |= (crc << EHT_USER_ENC_BLOCK_CRC_SHIFT);
+
+	ppdu_info->num_eht_user_info_valid++;
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_eht_sig_non_mumimo_user(u8 *tlv,
+						   struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_eht_sig_non_mu_mimo_user_info *user_info;
+	u32 user_idx = ppdu_info->num_eht_user_info_valid;
+	u32 sta_id, mcs, nss, beamformed, coding, crc;
+
+	user_info = (struct hal_eht_sig_non_mu_mimo_user_info *)tlv;
+
+	ppdu_info->eht_user_info[user_idx] |=
+					EHT_USER_STA_ID_KNOWN |
+					EHT_USER_MCS_KNOWN |
+					EHT_USER_CODING_KNOWN |
+					EHT_USER_NSS_KNOWN |
+					EHT_USER_BEAMFORMING_KNOWN;
+
+	sta_id = u32_get_bits(__le32_to_cpu(user_info->info0),
+			      HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_STA_ID);
+        ppdu_info->eht_user_info[user_idx] |= (sta_id << EHT_USER_STA_ID_SHIFT);
+
+	mcs = u32_get_bits(__le32_to_cpu(user_info->info0),
+			   HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_MCS);
+        ppdu_info->eht_user_info[user_idx] |= (mcs << EHT_USER_MCS_SHIFT);
+        ppdu_info->mcs = mcs;
+
+	nss = u32_get_bits(__le32_to_cpu(user_info->info0),
+			   HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_NSS);
+        ppdu_info->eht_user_info[user_idx] |= (nss << EHT_USER_NSS_SHIFT);
+        ppdu_info->nss = nss;
+
+	beamformed = u32_get_bits(__le32_to_cpu(user_info->info0),
+				  HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_BEAMFORMED);
+        ppdu_info->eht_user_info[user_idx] |= (beamformed << EHT_USER_BEAMFORMING_SHIFT);
+
+	coding = u32_get_bits(__le32_to_cpu(user_info->info0),
+			      HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_CODING);
+        ppdu_info->eht_user_info[user_idx] |=
+			(coding << EHT_USER_CODING_SHIFT);
+
+        /* CRC for matched user block */
+        ppdu_info->eht_known |=
+		EHT_USER_ENC_BLOCK_CRC_KNOWN | EHT_USER_ENC_BLOCK_TAIL_KNOWN;
+
+	crc = u32_get_bits(__le32_to_cpu(user_info->info0),
+			   HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_CRC);
+        ppdu_info->eht_data[4] |= (crc << EHT_USER_ENC_BLOCK_CRC_SHIFT);
+
+        ppdu_info->num_eht_user_info_valid++;
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_eht_sig_non_ofdma(u8 *tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	void *user_info = (void *)((u8 *)tlv + HTT_TLV_HDR_LEN);
+
+	ath12k_dp_mon_hal_rx_parse_usig_overflow(tlv, ppdu_info);
+	ath12k_dp_mon_hal_rx_parse_non_ofdma_users(tlv, ppdu_info);
+
+        if (ath12k_dp_mon_hal_rx_is_mu_mimo_user(ppdu_info))
+                ath12k_dp_mon_hal_rx_parse_eht_sig_mumimo_user_info(user_info,
+								    ppdu_info);
+        else
+		ath12k_dp_mon_hal_rx_parse_eht_sig_non_mumimo_user(user_info,
+								   ppdu_info);
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline u32
+ath12k_dp_mon_hal_rx_parse_eht_sig_ofdma(u8 *tlv, struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	u64 *eht_sig_tlv = (u64 *)tlv;
+	void *user_info = (void *)(eht_sig_tlv + 2);
+
+	ath12k_dp_mon_hal_rx_parse_usig_overflow(tlv, ppdu_info);
+        ath12k_dp_mon_hal_rx_parse_ru_allocation(tlv, ppdu_info);
+	ath12k_dp_mon_hal_rx_parse_eht_sig_non_mumimo_user(user_info,
+							   ppdu_info);
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static void
+ath12k_dp_mon_parse_eht_sig_hdr(struct hal_rx_mon_ppdu_info *ppdu_info,
+				u8 *tlv_data)
+{
+	ppdu_info->eht_flags = 1;
+
+	if (ath12k_dp_mon_hal_rx_is_frame_type_ndp(ppdu_info))
+		ath12k_dp_mon_hal_rx_parse_eht_sig_ndp(tlv_data, ppdu_info);
+	else if (ath12k_dp_mon_hal_rx_is_non_ofdma(ppdu_info))
+		ath12k_dp_mon_hal_rx_parse_eht_sig_non_ofdma(tlv_data, ppdu_info);
+	else if (ath12k_dp_mon_hal_rx_is_ofdma(ppdu_info))
+		ath12k_dp_mon_hal_rx_parse_eht_sig_ofdma(tlv_data, ppdu_info);
+}
+
+static u32
+ath12k_dp_mon_hal_rx_status_process_aggr_tlv(struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	u32 aggr_tlv_tag = ppdu_info->tlv_aggr.tlv_tag;
+
+	if (aggr_tlv_tag == HAL_PHYRX_GENERIC_EHT_SIG)
+		ath12k_dp_mon_parse_eht_sig_hdr(ppdu_info, ppdu_info->tlv_aggr.buf);
+
+	ppdu_info->tlv_aggr.in_progress = 0;
+	ppdu_info->tlv_aggr.cur_len = 0;
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
+static inline enum ath12k_eht_ru_size
+hal_rx_mon_hal_ru_size_to_ath12k_ru_size(u32 hal_ru_size)
+{
+	switch (hal_ru_size) {
+	case HAL_EHT_RU_26:
+		return ATH12K_EHT_RU_26;
+	case HAL_EHT_RU_52:
+		return ATH12K_EHT_RU_52;
+	case HAL_EHT_RU_78:
+		return ATH12K_EHT_RU_52_26;
+	case HAL_EHT_RU_106:
+		return ATH12K_EHT_RU_106;
+	case HAL_EHT_RU_132:
+		return ATH12K_EHT_RU_106_26;
+	case HAL_EHT_RU_242:
+		return ATH12K_EHT_RU_242;
+	case HAL_EHT_RU_484:
+		return ATH12K_EHT_RU_484;
+	case HAL_EHT_RU_726:
+		return ATH12K_EHT_RU_484_242;
+	case HAL_EHT_RU_996:
+		return ATH12K_EHT_RU_996;
+	case HAL_EHT_RU_996x2:
+		return ATH12K_EHT_RU_996x2;
+	case HAL_EHT_RU_996x3:
+		return ATH12K_EHT_RU_996x3;
+	case HAL_EHT_RU_996x4:
+		return ATH12K_EHT_RU_996x4;
+	case HAL_EHT_RU_NONE:
+		return ATH12K_EHT_RU_INVALID;
+	case HAL_EHT_RU_996_484:
+		return ATH12K_EHT_RU_996_484;
+	case HAL_EHT_RU_996x2_484:
+		return ATH12K_EHT_RU_996x2_484;
+	case HAL_EHT_RU_996x3_484:
+		return ATH12K_EHT_RU_996x3_484;
+	case HAL_EHT_RU_996_484_242:
+		return ATH12K_EHT_RU_996_484_242;
+	default:
+		return ATH12K_EHT_RU_INVALID;
+	}
+}
+
+static inline void hal_rx_ul_ofdma_ru_size_to_width(u32 ru_size, u32 *ru_width)
+{
+	uint32_t width = 0;
+
+	switch (ru_size) {
+	case ATH12K_EHT_RU_26:
+		width = RU_26;
+		break;
+	case ATH12K_EHT_RU_52:
+		width = RU_52;
+		break;
+	case ATH12K_EHT_RU_52_26:
+		width = RU_52_26;
+		break;
+	case ATH12K_EHT_RU_106:
+		width = RU_106;
+		break;
+	case ATH12K_EHT_RU_106_26:
+		width = RU_106_26;
+		break;
+	case ATH12K_EHT_RU_242:
+		width = RU_242;
+		break;
+	case ATH12K_EHT_RU_484:
+		width = RU_484;
+		break;
+	case ATH12K_EHT_RU_484_242:
+		width = RU_484_242;
+		break;
+	case ATH12K_EHT_RU_996:
+		width = RU_996;
+		break;
+	case ATH12K_EHT_RU_996_484:
+		width = RU_996_484;
+		break;
+	case ATH12K_EHT_RU_996_484_242:
+		width = RU_996_484_242;
+		break;
+	case ATH12K_EHT_RU_996x2:
+		width = RU_2X996;
+		break;
+	case ATH12K_EHT_RU_996x2_484:
+		width = RU_2X996_484;
+		break;
+	case ATH12K_EHT_RU_996x3:
+		width = RU_3X996;
+		break;
+	case ATH12K_EHT_RU_996x3_484:
+		width = RU_3X996_484;
+		break;
+	case ATH12K_EHT_RU_996x4:
+		width = RU_4X996;
+		break;
+	default:
+		break;
+	}
+
+	*ru_width = width;
+}
+
+static u32
+ath12k_dp_mon_hal_rx_parse_receive_user_info(u8 *tlv, u16 user_id,
+					     struct hal_rx_mon_ppdu_info *ppdu_info)
+{
+	struct hal_receive_user_info *rx_usr_info = (struct hal_receive_user_info *)tlv;
+	struct hal_rx_user_status *mon_rx_user_status = NULL;
+	u64 ru_index_320mhz = 0;
+	u32 ru_index_per80mhz;
+	u32 ru_size = 0, num_80mhz_with_ru = 0, ru_start_index_80_0;
+	u32 ru_index = HAL_EHT_RU_INVALID;
+	u32 rtap_ru_size = ATH12K_EHT_RU_INVALID;
+	u32 ru_width, reception_type, ru_type_80_0, dl_ofdma_content_channel;
+	u32 ru_type_80_1, ru_start_index_80_1, ru_type_80_2, ru_start_index_80_2;
+	u32 ru_type_80_3, ru_start_index_80_3;
+
+	ppdu_info->eht_known |= EHT_CONTENT_CH_INDEX_KNOWN;
+	dl_ofdma_content_channel = u32_get_bits(__le32_to_cpu(rx_usr_info->info1),
+						HAL_RX_USR_INFO1_DL_OFMDA_USR_IDX);
+	ppdu_info->eht_data[0] |= dl_ofdma_content_channel << EHT_CONTENT_CH_INDEX_SHIFT;
+	reception_type = u32_get_bits(__le32_to_cpu(rx_usr_info->info0),
+				      HAL_RX_USR_INFO0_RECEPTION_TYPE);
+
+	switch (reception_type) {
+	case HAL_RECEPTION_TYPE_SU:
+	        ppdu_info->reception_type = HAL_RX_RECEPTION_TYPE_SU;
+	        break;
+	case HAL_RECEPTION_TYPE_DL_MU_MIMO:
+	case HAL_RECEPTION_TYPE_UL_MU_MIMO:
+	        ppdu_info->reception_type = HAL_RX_RECEPTION_TYPE_MU_MIMO;
+	        break;
+	case HAL_RECEPTION_TYPE_DL_MU_OFMA:
+	case HAL_RECEPTION_TYPE_UL_MU_OFDMA:
+	        ppdu_info->reception_type = HAL_RX_RECEPTION_TYPE_MU_OFDMA;
+	        break;
+	case HAL_RECEPTION_TYPE_DL_MU_OFDMA_MIMO:
+	case HAL_RECEPTION_TYPE_UL_MU_OFDMA_MIMO:
+	        ppdu_info->reception_type = HAL_RX_RECEPTION_TYPE_MU_OFDMA_MIMO;
+	}
+
+	ppdu_info->is_stbc = u32_get_bits(__le32_to_cpu(rx_usr_info->info0),
+					  HAL_RX_USR_INFO0_STBC);
+	ppdu_info->ldpc = u32_get_bits(__le32_to_cpu(rx_usr_info->info2),
+				       HAL_RX_USR_INFO2_LDPC);
+	ppdu_info->dcm = u32_get_bits(__le32_to_cpu(rx_usr_info->info2),
+				      HAL_RX_USR_INFO2_STA_DCM);
+	ppdu_info->bw = u32_get_bits(__le32_to_cpu(rx_usr_info->info1),
+				     HAL_RX_USR_INFO1_RX_BW);
+	ppdu_info->mcs = u32_get_bits(__le32_to_cpu(rx_usr_info->info1),
+				      HAL_RX_USR_INFO1_MCS);
+	ppdu_info->nss = u32_get_bits(__le32_to_cpu(rx_usr_info->info2),
+				      HAL_RX_USR_INFO2_NSS);
+
+	if (user_id < HAL_MAX_UL_MU_USERS) {
+	        mon_rx_user_status =
+	                &ppdu_info->userstats[user_id];
+	        mon_rx_user_status->mcs = ppdu_info->mcs;
+	        mon_rx_user_status->nss = ppdu_info->nss;
+	}
+
+	if (!(ppdu_info->reception_type == HAL_RX_RECEPTION_TYPE_MU_MIMO ||
+	      ppdu_info->reception_type == HAL_RX_RECEPTION_TYPE_MU_OFDMA ||
+	      ppdu_info->reception_type == HAL_RX_RECEPTION_TYPE_MU_OFDMA_MIMO))
+			return HAL_TLV_STATUS_PPDU_NOT_DONE;
+
+	/* RU allocation present only for OFDMA reception */
+	ru_type_80_0 = u32_get_bits(__le32_to_cpu(rx_usr_info->info2),
+				    HAL_RX_USR_INFO2_RU_TYPE_80_0);
+	ru_start_index_80_0 = u32_get_bits(__le32_to_cpu(rx_usr_info->info3),
+					   HAL_RX_USR_INFO3_RU_START_IDX_80_0);
+	if (ru_type_80_0 != HAL_EHT_RU_NONE) {
+	        ru_size += ru_type_80_0;
+	        ru_index = ru_index_per80mhz = ru_start_index_80_0;
+	        HAL_SET_RU_PER80(ru_index_320mhz, ru_type_80_0, ru_index_per80mhz, 0);
+	        num_80mhz_with_ru++;
+	}
+
+	ru_type_80_1 = u32_get_bits(__le32_to_cpu(rx_usr_info->info2),
+				    HAL_RX_USR_INFO2_RU_TYPE_80_1);
+	ru_start_index_80_1 = u32_get_bits(__le32_to_cpu(rx_usr_info->info3),
+					   HAL_RX_USR_INFO3_RU_START_IDX_80_1);
+	if (ru_type_80_1 != HAL_EHT_RU_NONE) {
+	        ru_size += ru_type_80_1;
+	        ru_index = ru_index_per80mhz = ru_start_index_80_1;
+	        HAL_SET_RU_PER80(ru_index_320mhz, ru_type_80_1, ru_index_per80mhz, 1);
+	        num_80mhz_with_ru++;
+	}
+
+	ru_type_80_2 = u32_get_bits(__le32_to_cpu(rx_usr_info->info2),
+				    HAL_RX_USR_INFO2_RU_TYPE_80_2);
+	ru_start_index_80_2 = u32_get_bits(__le32_to_cpu(rx_usr_info->info3),
+					   HAL_RX_USR_INFO3_RU_START_IDX_80_2);
+	if (ru_type_80_2 != HAL_EHT_RU_NONE) {
+	        ru_size += ru_type_80_2;
+	        ru_index = ru_index_per80mhz = ru_start_index_80_2;
+	        HAL_SET_RU_PER80(ru_index_320mhz, ru_type_80_2, ru_index_per80mhz, 2);
+	        num_80mhz_with_ru++;
+	}
+
+	ru_type_80_3 = u32_get_bits(__le32_to_cpu(rx_usr_info->info2),
+				    HAL_RX_USR_INFO2_RU_TYPE_80_3);
+	ru_start_index_80_3 = u32_get_bits(__le32_to_cpu(rx_usr_info->info2),
+					   HAL_RX_USR_INFO3_RU_START_IDX_80_3);
+	if (ru_type_80_3 != HAL_EHT_RU_NONE) {
+	        ru_size += ru_type_80_3;
+	        ru_index = ru_index_per80mhz = ru_start_index_80_3;
+	        HAL_SET_RU_PER80(ru_index_320mhz, ru_type_80_3, ru_index_per80mhz, 3);
+	        num_80mhz_with_ru++;
+	}
+
+	if (num_80mhz_with_ru > 1) {
+	        /* Calculate the MRU index */
+		switch (ru_index_320mhz) {
+		case HAL_EHT_RU_996_484_0:
+		case HAL_EHT_RU_996x2_484_0:
+		case HAL_EHT_RU_996x3_484_0:
+			ru_index = 0;
+			break;
+		case HAL_EHT_RU_996_484_1:
+		case HAL_EHT_RU_996x2_484_1:
+		case HAL_EHT_RU_996x3_484_1:
+			ru_index = 1;
+			break;
+		case HAL_EHT_RU_996_484_2:
+		case HAL_EHT_RU_996x2_484_2:
+		case HAL_EHT_RU_996x3_484_2:
+			ru_index = 2;
+			break;
+		case HAL_EHT_RU_996_484_3:
+		case HAL_EHT_RU_996x2_484_3:
+		case HAL_EHT_RU_996x3_484_3:
+			ru_index = 3;
+			break;
+		case HAL_EHT_RU_996_484_4:
+		case HAL_EHT_RU_996x2_484_4:
+		case HAL_EHT_RU_996x3_484_4:
+			ru_index = 4;
+			break;
+		case HAL_EHT_RU_996_484_5:
+		case HAL_EHT_RU_996x2_484_5:
+		case HAL_EHT_RU_996x3_484_5:
+			ru_index = 5;
+			break;
+		case HAL_EHT_RU_996_484_6:
+		case HAL_EHT_RU_996x2_484_6:
+		case HAL_EHT_RU_996x3_484_6:
+			ru_index = 6;
+			break;
+		case HAL_EHT_RU_996_484_7:
+		case HAL_EHT_RU_996x2_484_7:
+		case HAL_EHT_RU_996x3_484_7:
+			ru_index = 7;
+			break;
+		case HAL_EHT_RU_996x2_484_8:
+			ru_index = 8;
+			break;
+		case HAL_EHT_RU_996x2_484_9:
+			ru_index = 9;
+			break;
+		case HAL_EHT_RU_996x2_484_10:
+		        ru_index = 10;
+		        break;
+		case HAL_EHT_RU_996x2_484_11:
+			ru_index = 11;
+			break;
+		default:
+			ru_index = HAL_EHT_RU_INVALID;
+	        break;
+		}
+
+		ru_size += 4;
+	}
+
+	rtap_ru_size = hal_rx_mon_hal_ru_size_to_ath12k_ru_size(ru_size);
+	if (rtap_ru_size != ATH12K_EHT_RU_INVALID) {
+		ppdu_info->eht_known |= EHT_RU_MRU_SIZE_KNOWN;
+		ppdu_info->eht_data[1] |= (rtap_ru_size << EHT_RU_MRU_SIZE_SHIFT);
+	}
+
+	if (ru_index != HAL_EHT_RU_INVALID) {
+		ppdu_info->eht_known |= EHT_RU_MRU_INDEX_KNOWN;
+		ppdu_info->eht_data[1] |= (ru_index << EHT_RU_MRU_INDEX_SHIFT);
+	}
+
+	if (mon_rx_user_status && ru_index != HAL_EHT_RU_INVALID &&
+	    rtap_ru_size != ATH12K_EHT_RU_INVALID) {
+		mon_rx_user_status->ul_ofdma_ru_start_index = ru_index;
+		mon_rx_user_status->ul_ofdma_ru_size = rtap_ru_size;
+		hal_rx_ul_ofdma_ru_size_to_width(rtap_ru_size, &ru_width);
+		mon_rx_user_status->ul_ofdma_ru_width = ru_width;
+		mon_rx_user_status->ofdma_info_valid = 1;
+	}
+
+	return HAL_TLV_STATUS_PPDU_NOT_DONE;
+}
+
 static enum hal_rx_mon_status
 ath12k_dp_mon_rx_parse_status_tlv(struct ath12k_base *ab,
 				  struct hal_rx_mon_ppdu_info *ppdu_info,
-				  u32 tlv_tag, u8 *tlv_data, u32 userid)
+				  struct hal_tlv_parsed_hdr *tlv_parsed_hdr)
 {
 	u32 info[6];
+	u16 tlv_tag = tlv_parsed_hdr->tlv_tag;
+	u16 tlv_len = tlv_parsed_hdr->tlv_len;
+	u16 userid = tlv_parsed_hdr->tlv_userid;
+	u8 *tlv_data = tlv_parsed_hdr->tlv_data;
+
+	if (ppdu_info->tlv_aggr.in_progress) {
+		if (ppdu_info->tlv_aggr.tlv_tag == tlv_tag) {
+			return ath12k_dp_mon_hal_aggr_tlv(ppdu_info,
+							  tlv_len, tlv_data);
+		} else {
+			ath12k_dp_mon_hal_rx_status_process_aggr_tlv(ppdu_info);
+		}
+	}
 
 	switch (tlv_tag) {
 	case HAL_RX_PPDU_START: {
@@ -664,6 +1532,9 @@ ath12k_dp_mon_rx_parse_status_tlv(struct
 		case HAL_RX_PREAMBLE_11AX:
 			ppdu_info->he_flags = 1;
 			break;
+		case HAL_RX_PREAMBLE_11BE:
+			ppdu_info->eht_flags = 1;
+			break;
 		default:
 			break;
 		}
@@ -796,6 +1667,10 @@ ath12k_dp_mon_rx_parse_status_tlv(struct
 
 		break;
 	}
+	case HAL_RX_PPDU_START_USER_INFO: {
+		ath12k_dp_mon_hal_rx_parse_receive_user_info(tlv_data, userid, ppdu_info);
+		break;
+	}
 	case HAL_PHYRX_OTHER_RECEIVE_INFO: {
 		struct phyrx_common_user_info *cmn_usr_info =
 			(struct phyrx_common_user_info *)tlv_data;
@@ -803,6 +1678,24 @@ ath12k_dp_mon_rx_parse_status_tlv(struct
 					     HAL_RX_PHY_CMN_USER_INFO0_GI);
 		break;
 	}
+	case HAL_PHYRX_GENERIC_U_SIG:
+		ath12k_dp_mon_hal_rx_parse_u_sig_hdr(tlv_data, ppdu_info);
+		break;
+	case HAL_PHYRX_GENERIC_EHT_SIG: {
+		/*
+		 * Handle the case where aggregation is in progress
+		 * or the current TLV is one of the TLVs which should be
+		 * aggregated
+		 */
+		ppdu_info->tlv_aggr.in_progress = 1;
+		ppdu_info->tlv_aggr.tlv_tag = tlv_tag;
+		ppdu_info->tlv_aggr.cur_len = 0;
+		ppdu_info->eht_flags = 1;
+
+		ath12k_dp_mon_hal_aggr_tlv(ppdu_info, tlv_len, tlv_data);
+
+		break;
+	}
 	case HAL_MON_BUF_ADDR:
 		return HAL_RX_MON_STATUS_BUF_ADDR;
 	case HAL_RX_MPDU_END:
@@ -1098,6 +1991,47 @@ ath12k_dp_mon_rx_update_radiotap_he_mu(s
 	rtap_buf[rtap_len] = rx_status->he_RU[3];
 }
 
+static enum nl80211_eht_ru_alloc
+ath12k_dp_mon_rx_mon_ru_size_to_nl_ru_size(u32 ru_size)
+{
+	switch(ru_size) {
+	case ATH12K_EHT_RU_26:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_26;
+	case ATH12K_EHT_RU_52:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_52;
+	case ATH12K_EHT_RU_52_26:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_52P26;
+	case ATH12K_EHT_RU_106:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_106;
+	case ATH12K_EHT_RU_106_26:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_106P26;
+	case ATH12K_EHT_RU_242:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_242;
+	case ATH12K_EHT_RU_484:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_484;
+	case ATH12K_EHT_RU_484_242:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_484P242;
+	case ATH12K_EHT_RU_996:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_996;
+	case ATH12K_EHT_RU_996x2:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_2x996;
+	case ATH12K_EHT_RU_996x3:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_3x996;
+	case ATH12K_EHT_RU_996x4:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_4x996;
+	case ATH12K_EHT_RU_996_484:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_996P484;
+	case ATH12K_EHT_RU_996x2_484:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_2x996P484;
+	case ATH12K_EHT_RU_996x3_484:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_3x996P484;
+	case ATH12K_EHT_RU_996_484_242:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_996P484P242;
+	default:
+		return NL80211_RATE_INFO_EHT_RU_ALLOC_26;
+	}
+}
+
 static void ath12k_dp_mon_update_radiotap(struct ath12k *ar,
 					  struct hal_rx_mon_ppdu_info *ppduinfo,
 					  struct sk_buff *mon_skb,
@@ -1106,6 +2040,7 @@ static void ath12k_dp_mon_update_radiota
 	struct ieee80211_supported_band *sband;
 	u8 *ptr = NULL;
 	u16 ampdu_id = ppduinfo->ampdu_id[ppduinfo->userid];
+	u32 ru_size;
 
 	rxs->flag |= RX_FLAG_MACTIME_START;
 	rxs->signal = ppduinfo->rssi_comb + ATH12K_DEFAULT_NOISE_FLOOR;
@@ -1124,6 +2059,8 @@ static void ath12k_dp_mon_update_radiota
 	} else if (ppduinfo->he_flags) {
 		rxs->flag |= RX_FLAG_RADIOTAP_HE;
 		rxs->encoding = RX_ENC_HE;
+		ru_size = ppduinfo->userstats[ppduinfo->userid].ul_ofdma_ru_size;
+		rxs->eht_ru = ath12k_dp_mon_rx_mon_ru_size_to_nl_ru_size(ru_size);
 		ptr = skb_push(mon_skb, sizeof(struct ieee80211_radiotap_he));
 		ath12k_dp_mon_rx_update_radiotap_he(ppduinfo, ptr);
 		rxs->rate_idx = ppduinfo->rate;
@@ -1409,6 +2346,7 @@ ath12k_dp_mon_parse_rx_dest(struct ath12
 			    struct sk_buff *skb)
 {
 	struct hal_tlv_64_hdr *tlv;
+	struct hal_tlv_parsed_hdr tlv_parsed_hdr = {0};
 	enum hal_rx_mon_status hal_status = HAL_RX_MON_STATUS_BUF_DONE;
 	u32 tlv_userid = 0;
 	u16 tlv_tag, tlv_len;
@@ -1431,8 +2369,13 @@ ath12k_dp_mon_parse_rx_dest(struct ath12
 		if (tlv_tag == HAL_RX_PPDU_END)
 			tlv_len = sizeof(struct hal_rx_rxpcu_classification_overview);
 
+		tlv_parsed_hdr.tlv_tag = tlv_tag;
+		tlv_parsed_hdr.tlv_len = tlv_len;
+		tlv_parsed_hdr.tlv_userid = tlv_userid;
+		tlv_parsed_hdr.tlv_data = ptr;
+
 		hal_status = ath12k_dp_mon_rx_parse_status_tlv(ar->ab, ppdu_info,
-							       tlv_tag, ptr, tlv_userid);
+							       &tlv_parsed_hdr);
 
 		if (montior_started)
 			ath12k_dp_mon_parse_rx_dest_tlv(ar, ppdu_info,
--- a/drivers/net/wireless/ath/ath12k/hal_desc.h
+++ b/drivers/net/wireless/ath/ath12k/hal_desc.h
@@ -522,7 +522,7 @@ enum hal_tlv_tag {
 	HAL_PHYRXHT_SIG_USR_SU					= 468 /* 0x1d4 */,
 	HAL_PHYRXHT_SIG_USR_MU_MIMO				= 469 /* 0x1d5 */,
 	HAL_PHYRX_GENERIC_U_SIG					= 470 /* 0x1d6 */,
-	HAL_PHYRX_GENERICHT_SIG					= 471 /* 0x1d7 */,
+	HAL_PHYRX_GENERIC_EHT_SIG				= 471 /* 0x1d7 */,
 	HAL_OVERWRITE_RESP_START				= 472 /* 0x1d8 */,
 	HAL_OVERWRITE_RESP_PREAMBLE_INFO			= 473 /* 0x1d9 */,
 	HAL_OVERWRITE_RESP_FRAME_INFO				= 474 /* 0x1da */,
@@ -587,6 +587,13 @@ struct hal_tlv_64_hdr {
 	u8 value[];
 } __packed;
 
+struct hal_tlv_parsed_hdr {
+	u16 tlv_tag;
+	u16 tlv_len;
+	u16 tlv_userid;
+	u8 *tlv_data;
+};
+
 #define RX_MPDU_DESC_INFO0_MSDU_COUNT		GENMASK(7, 0)
 #define RX_MPDU_DESC_INFO0_FRAG_FLAG		BIT(8)
 #define RX_MPDU_DESC_INFO0_MPDU_RETRY		BIT(9)
--- a/drivers/net/wireless/ath/ath12k/hal_rx.h
+++ b/drivers/net/wireless/ath/ath12k/hal_rx.h
@@ -163,6 +163,23 @@ struct mon_mpdu_data {
 	u16 msdu_count;
 };
 
+#define HAL_RX_MON_MAX_AGGR_SIZE	128
+
+struct hal_rx_tlv_aggr_info {
+	u8 in_progress;
+	u8 cur_len;
+	u8 tlv_tag;
+	u8 buf[HAL_RX_MON_MAX_AGGR_SIZE];
+};
+
+struct hal_rx_u_sig_info {
+	bool ul_dl;
+	u8 bw;
+	u8 ppdu_type_comp_mode;
+	u8 eht_sig_mcs;
+	u8 num_eht_sig_sym;
+};
+
 struct hal_rx_mon_ppdu_info {
 	u32 ppdu_id;
 	u32 last_ppdu_id;
@@ -250,6 +267,18 @@ struct hal_rx_mon_ppdu_info {
 	bool ppdu_continuation;
 	struct mon_mpdu_data mon_mpdu[HAL_RX_MAX_MPDU];
 	u16 mpdu_count;
+	struct hal_rx_tlv_aggr_info tlv_aggr;
+	u16 usig_flags;
+	u16 eht_flags;
+	u8 num_eht_user_info_valid;
+	u16 punctured_pattern;
+	u32 usig_common;
+	u32 usig_value;
+	u32 usig_mask;
+	u32 eht_known;
+	u32 eht_data[6];
+	u32 eht_user_info[4];
+	struct hal_rx_u_sig_info u_sig_info;
 };
 
 #define HAL_RX_PPDU_START_INFO0_PPDU_ID		GENMASK(15, 0)
@@ -552,6 +581,373 @@ struct phyrx_common_user_info {
 	__le32 rsvd1;
 };
 
+#define HAL_RX_EHT_SIG_NDP_CMN_INFO0_SPATIAL_REUSE	GENMASK(3, 0)
+#define HAL_RX_EHT_SIG_NDP_CMN_INFO0_GI_LTF		GENMASK(5, 4)
+#define HAL_RX_EHT_SIG_NDP_CMN_INFO0_NUM_LTF_SYM	GENMASK(8, 6)
+#define HAL_RX_EHT_SIG_NDP_CMN_INFO0_NSS		GENMASK(10, 7)
+#define HAL_RX_EHT_SIG_NDP_CMN_INFO0_BEAMFORMED		BIT(11)
+#define HAL_RX_EHT_SIG_NDP_CMN_INFO0_DISREGARD		GENMASK(13, 12)
+#define HAL_RX_EHT_SIG_NDP_CMN_INFO0_CRC		GENMASK(17, 14)
+
+struct hal_eht_sig_ndp_cmn_eb {
+	__le32 info0;
+} __packed;
+
+#define HAL_RX_EHT_SIG_OVERFLOW_INFO0_SPATIAL_REUSE		GENMASK(3, 0)
+#define HAL_RX_EHT_SIG_OVERFLOW_INFO0_GI_LTF			GENMASK(5, 4)
+#define HAL_RX_EHT_SIG_OVERFLOW_INFO0_NUM_LTF_SYM		GENMASK(8, 6)
+#define HAL_RX_EHT_SIG_OVERFLOW_INFO0_LDPC_EXTA_SYM		BIT(9)
+#define HAL_RX_EHT_SIG_OVERFLOW_INFO0_PRE_FEC_PAD_FACTOR	GENMASK(11, 10)
+#define HAL_RX_EHT_SIG_OVERFLOW_INFO0_DISAMBIGUITY		BIT(12)
+#define HAL_RX_EHT_SIG_OVERFLOW_INFO0_DISREGARD			GENMASK(16, 13)
+
+struct hal_eht_sig_cc_usig_overflow {
+	__le32 info0;
+} __packed;
+
+#define HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_STA_ID	GENMASK(10, 0)
+#define HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_MCS	GENMASK(14, 11)
+#define HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_VALIDATE	BIT(15)
+#define HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_NSS	GENMASK(19, 16)
+#define HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_BEAMFORMED	BIT(20)
+#define HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_CODING	BIT(21)
+#define HAL_RX_EHT_SIG_NON_MUMIMO_USER_INFO0_CRC	GENMASK(25, 22)
+
+struct hal_eht_sig_non_mu_mimo_user_info {
+	__le32 info0;
+} __packed;
+
+#define HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_STA_ID		GENMASK(10, 0)
+#define HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_MCS		GENMASK(14, 11)
+#define HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_CODING		BIT(15)
+#define HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_SPATIAL_CODING	GENMASK(22, 16)
+#define HAL_RX_EHT_SIG_MUMIMO_USER_INFO0_CRC		GENMASK(26, 23)
+
+struct hal_eht_sig_mu_mimo_user_info {
+	__le32 info0;
+} __packed;
+
+union hal_eht_sig_user_field {
+	struct hal_eht_sig_mu_mimo_user_info mu_mimo_usr;
+	struct hal_eht_sig_non_mu_mimo_user_info non_mu_mimo_usr;
+};
+
+#define HAL_RX_EHT_SIG_NON_OFDMA_INFO0_SPATIAL_REUSE		GENMASK(3, 0)
+#define HAL_RX_EHT_SIG_NON_OFDMA_INFO0_GI_LTF			GENMASK(5, 4)
+#define	HAL_RX_EHT_SIG_NON_OFDMA_INFO0_NUM_LTF_SYM		GENMASK(8, 6)
+#define HAL_RX_EHT_SIG_NON_OFDMA_INFO0_LDPC_EXTA_SYM		BIT(9)
+#define	HAL_RX_EHT_SIG_NON_OFDMA_INFO0_PRE_FEC_PAD_FACTOR	GENMASK(11, 10)
+#define HAL_RX_EHT_SIG_NON_OFDMA_INFO0_DISAMBIGUITY		BIT(12)
+#define HAL_RX_EHT_SIG_NON_OFDMA_INFO0_DISREGARD		GENMASK(16, 13)
+#define HAL_RX_EHT_SIG_NON_OFDMA_INFO0_NUM_USERS		GENMASK(19, 17)
+
+struct hal_eht_sig_non_ofdma_cmn_eb {
+	__le32 info0;
+	union hal_eht_sig_user_field user_field;
+} __packed;
+
+#define HAL_RX_EHT_SIG_OFDMA_EB1_SPATIAL_REUSE		GENMASK_ULL(3, 0)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_GI_LTF			GENMASK_ULL(5, 4)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_NUM_LFT_SYM		GENMASK_ULL(8, 6)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_LDPC_EXTRA_SYM		BIT(9)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_PRE_FEC_PAD_FACTOR	GENMASK_ULL(11, 10)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_PRE_DISAMBIGUITY	BIT(12)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_DISREGARD		GENMASK_ULL(16, 13)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_RU_ALLOC_1_1		GENMASK_ULL(25, 17)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_RU_ALLOC_1_2		GENMASK_ULL(34, 26)
+#define HAL_RX_EHT_SIG_OFDMA_EB1_CRC			GENMASK_ULL(30, 27)
+
+struct hal_eht_sig_ofdma_cmn_eb1 {
+	__le64 info0;
+} __packed;
+
+#define HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_1		GENMASK_ULL(0, 8)
+#define HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_2		GENMASK_ULL(17, 9)
+#define HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_3		GENMASK_ULL(26, 18)
+#define HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_4		GENMASK_ULL(35, 27)
+#define HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_5		GENMASK_ULL(44, 36)
+#define HAL_RX_EHT_SIG_OFDMA_EB2_RU_ALLOC_2_6		GENMASK_ULL(53, 45)
+#define HAL_RX_EHT_SIG_OFDMA_EB2_MCS			GNEMASK_ULL(57, 54)
+
+struct hal_eht_sig_ofdma_cmn_eb2 {
+	__le64 info0;
+} __packed;
+
+enum hal_eht_bw {
+	HAL_EHT_BW_20,
+	HAL_EHT_BW_40,
+	HAL_EHT_BW_80,
+	HAL_EHT_BW_160,
+	HAL_EHT_BW_320_1,
+	HAL_EHT_BW_320_2,
+};
+
+#define HAL_RX_USIG_CMN_INFO0_PHY_VERSION	GENMASK(2, 0)
+#define HAL_RX_USIG_CMN_INFO0_BW		GENMASK(5, 3)
+#define HAL_RX_USIG_CMN_INFO0_UL_DL		BIT(6)
+#define HAL_RX_USIG_CMN_INFO0_BSS_COLOR		GENMASK(12, 7)
+#define HAL_RX_USIG_CMN_INFO0_TXOP		GENMASK(19, 13)
+#define HAL_RX_USIG_CMN_INFO0_DISREGARD		GENMASK(25, 20)
+#define HAL_RX_USIG_CMN_INFO0_VALIDATE		BIT(26)
+
+struct hal_mon_usig_cmn {
+	__le32 info0;
+} __packed;
+
+#define HAL_RX_USIG_TB_INFO0_PPDU_TYPE_COMP_MODE	GENMASK(1, 0)
+#define HAL_RX_USIG_TB_INFO0_VALIDATE			BIT(2)
+#define HAL_RX_USIG_TB_INFO0_SPATIAL_REUSE_1		GENMASK(6, 3)
+#define HAL_RX_USIG_TB_INFO0_SPATIAL_REUSE_2		GENMASK(10, 7)
+#define HAL_RX_USIG_TB_INFO0_DISREGARD_1		GENMASK(15, 11)
+#define HAL_RX_USIG_TB_INFO0_CRC			GENMASK(19, 16)
+#define HAL_RX_USIG_TB_INFO0_TAIL			GENMASK(25, 20)
+#define HAL_RX_USIG_TB_INFO0_RX_INTEG_CHECK_PASS	BIT(31)
+
+struct hal_mon_usig_tb {
+	__le32 info0;
+} __packed;
+
+#define HAL_RX_USIG_MU_INFO0_PPDU_TYPE_COMP_MODE	GENMASK(1, 0)
+#define HAL_RX_USIG_MU_INFO0_VALIDATE_1			BIT(2)
+#define HAL_RX_USIG_MU_INFO0_PUNC_CH_INFO		GENMASK(7, 3)
+#define HAL_RX_USIG_MU_INFO0_VALIDATE_2			BIT(8)
+#define HAL_RX_USIG_MU_INFO0_EHT_SIG_MCS		GENMASK(10, 9)
+#define HAL_RX_USIG_MU_INFO0_NUM_EHT_SIG_SYM		GENMASK(15, 11)
+#define HAL_RX_USIG_MU_INFO0_CRC			GENMASK(20, 16)
+#define HAL_RX_USIG_MU_INFO0_TAIL			GENMASK(26, 21)
+#define HAL_RX_USIG_MU_INFO0_RX_INTEG_CHECK_PASS	BIT(31)
+
+struct hal_mon_usig_mu {
+	__le32 info0;
+} __packed;
+
+union hal_mon_usig_non_cmn {
+	struct hal_mon_usig_tb tb;
+	struct hal_mon_usig_mu mu;
+};
+
+struct hal_mon_usig_hdr {
+	struct hal_mon_usig_cmn usig_1;
+	union hal_mon_usig_non_cmn usig_2;
+} __packed;
+
+#define HAL_RX_USR_INFO0_RECEPTION_TYPE			GENMASK(2, 0)
+#define HAL_RX_USR_INFO0_STBC				BIT(3)
+#define HAL_RX_USR_INFO0_PKT_TYPE			GENMASK(7, 4)
+#define HAL_RX_USR_INFO0_USR_RSSI			GENMASK(15, 8)
+#define HAL_RX_USR_INFO0_PHY_PPDU_ID			GENMASK(31, 16)
+
+#define HAL_RX_USR_INFO1_DL_OFMDA_USR_IDX		GENMASK(7, 0)
+#define HAL_RX_USR_INFO1_RX_BW				GENMASK(15, 13)
+#define HAL_RX_USR_INFO1_MIMO_SS_BITMAP			GENMASK(23, 16)
+#define HAL_RX_USR_INFO1_HE_RANGING_NDP			BIT(25)
+#define HAL_RX_USR_INFO1_SGI				GENMASK(27, 26)
+#define HAL_RX_USR_INFO1_MCS				GENMASK(31, 28)
+
+#define HAL_RX_USR_INFO2_RU_TYPE_80_3			GENMASK(3, 0)
+#define HAL_RX_USR_INFO2_RU_TYPE_80_2			GENMASK(7, 4)
+#define HAL_RX_USR_INFO2_RU_TYPE_80_1			GENMASK(11, 8)
+#define HAL_RX_USR_INFO2_RU_TYPE_80_0			GENMASK(15, 12)
+#define HAL_RX_USR_INFO2_LDPC				BIT(16)
+#define HAL_RX_USR_INFO2_STA_DCM			BIT(17)
+#define HAL_RX_USR_INFO2_STREAM_OFFSET			GENMASK(20, 18)
+#define HAL_RX_USR_INFO2_NSS				GENMASK(23, 21)
+#define HAL_RX_USR_INFO2_DL_OFDMA_CONTENT_CHAN		BIT(31)
+
+#define HAL_RX_USR_INFO3_RU_START_IDX_80_3		GENMASK(7, 2)
+#define HAL_RX_USR_INFO3_RU_START_IDX_80_2		GENMASK(15, 10)
+#define HAL_RX_USR_INFO3_RU_START_IDX_80_1		GENMASK(23, 18)
+#define HAL_RX_USR_INFO3_RU_START_IDX_80_0		GENMASK(31, 26)
+
+struct hal_receive_user_info {
+	__le32 info0;
+	__le32 info1;
+	__le32 info2;
+	__le32 info3;
+	__le32 user_fd_rssi_seg0;
+	__le32 user_fd_rssi_seg1;
+	__le32 user_fd_rssi_seg2;
+	__le32 user_fd_rssi_seg3;
+} __packed;
+
+enum hal_mon_reception_type{
+	HAL_RECEPTION_TYPE_SU,
+	HAL_RECEPTION_TYPE_DL_MU_MIMO,
+	HAL_RECEPTION_TYPE_DL_MU_OFMA,
+	HAL_RECEPTION_TYPE_DL_MU_OFDMA_MIMO,
+	HAL_RECEPTION_TYPE_UL_MU_MIMO,
+	HAL_RECEPTION_TYPE_UL_MU_OFDMA,
+	HAL_RECEPTION_TYPE_UL_MU_OFDMA_MIMO,
+};
+/* Different allowed RU in 11BE */
+#define HAL_EHT_RU_26		0ULL
+#define HAL_EHT_RU_52		1ULL
+#define HAL_EHT_RU_78		2ULL
+#define HAL_EHT_RU_106		3ULL
+#define HAL_EHT_RU_132		4ULL
+#define HAL_EHT_RU_242		5ULL
+#define HAL_EHT_RU_484		6ULL
+#define HAL_EHT_RU_726		7ULL
+#define HAL_EHT_RU_996		8ULL
+#define HAL_EHT_RU_996x2	9ULL
+#define HAL_EHT_RU_996x3	10ULL
+#define HAL_EHT_RU_996x4	11ULL
+#define HAL_EHT_RU_NONE		15ULL
+#define HAL_EHT_RU_INVALID	31ULL
+/*
+ * MRUs spanning above 80Mhz
+ * HAL_EHT_RU_996_484 = HAL_EHT_RU_484 + HAL_EHT_RU_996 + 4 (reserved)
+ */
+#define HAL_EHT_RU_996_484	18ULL
+#define HAL_EHT_RU_996x2_484	28ULL
+#define HAL_EHT_RU_996x3_484	40ULL
+#define HAL_EHT_RU_996_484_242	23ULL
+
+#define NUM_RU_BITS_PER80	16
+#define NUM_RU_BITS_PER20	4
+
+/* Different per_80Mhz band in 320Mhz bandwidth */
+#define HAL_80_0	0
+#define HAL_80_1	1
+#define HAL_80_2	2
+#define HAL_80_3	3
+
+#define HAL_RU_SHIFT(num_80mhz_band, ru_index_per_80)	\
+		((NUM_RU_BITS_PER80 * (num_80mhz_band)) +	\
+		 (NUM_RU_BITS_PER20 * (ru_index_per_80)))
+
+/* MRU-996+484 */
+#define HAL_EHT_RU_996_484_0	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_0, 1)) |	\
+				 (HAL_EHT_RU_996 << HAL_RU_SHIFT(HAL_80_1, 0)))
+#define HAL_EHT_RU_996_484_1	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996 << HAL_RU_SHIFT(HAL_80_1, 0)))
+#define HAL_EHT_RU_996_484_2	((HAL_EHT_RU_996 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_1, 1)))
+#define HAL_EHT_RU_996_484_3	((HAL_EHT_RU_996 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_1, 0)))
+#define HAL_EHT_RU_996_484_4	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_2, 1)) |	\
+				 (HAL_EHT_RU_996 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996_484_5	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996_484_6	((HAL_EHT_RU_996 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_3, 1)))
+#define HAL_EHT_RU_996_484_7	((HAL_EHT_RU_996 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_3, 0)))
+
+/* MRU-996x2+484 */
+#define HAL_EHT_RU_996x2_484_0	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_0, 1)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_2, 0)))
+#define HAL_EHT_RU_996x2_484_1	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_2, 0)))
+#define HAL_EHT_RU_996x2_484_2	((HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_1, 1)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_2, 0)))
+#define HAL_EHT_RU_996x2_484_3	((HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_2, 0)))
+#define HAL_EHT_RU_996x2_484_4	((HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_2, 1)))
+#define HAL_EHT_RU_996x2_484_5	((HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_2, 0)))
+#define HAL_EHT_RU_996x2_484_6	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_1, 1)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x2_484_7	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x2_484_8	((HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_2, 1)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x2_484_9	((HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x2_484_10	((HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_3, 1)))
+#define HAL_EHT_RU_996x2_484_11	((HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x2 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_3, 0)))
+
+/* MRU-996x3+484 */
+#define HAL_EHT_RU_996x3_484_0	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_0, 1)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x3_484_1	((HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x3_484_2	((HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_1, 1)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x3_484_3	((HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x3_484_4	((HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_2, 1)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x3_484_5	((HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_3, 0)))
+#define HAL_EHT_RU_996x3_484_6	((HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_3, 1)))
+#define HAL_EHT_RU_996x3_484_7	((HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_0, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_1, 0)) |	\
+				 (HAL_EHT_RU_996x3 << HAL_RU_SHIFT(HAL_80_2, 0)) |	\
+				 (HAL_EHT_RU_484 << HAL_RU_SHIFT(HAL_80_3, 0)))
+
+#define HAL_SET_RU_PER80(ru_320mhz, ru_per80, ru_idx_per80mhz, num_80mhz) \
+			((ru_320mhz) |= ((uint64_t)(ru_per80) << \
+			(((num_80mhz) * NUM_RU_BITS_PER80) + \
+			((ru_idx_per80mhz) * NUM_RU_BITS_PER20))))
+
+#define RU_26			1
+#define RU_52			2
+#define RU_106			4
+#define RU_242			9
+#define RU_484			18
+#define RU_996			37
+#define RU_2X996		74
+#define RU_3X996		111
+#define RU_4X996		148
+#define RU_52_26		RU_52 + RU_26
+#define RU_106_26		RU_106 + RU_26
+#define RU_484_242		RU_484 + RU_242
+#define RU_996_484		RU_996 + RU_484
+#define RU_996_484_242		RU_996 + RU_484_242
+#define RU_2X996_484		RU_2X996 + RU_484
+#define RU_3X996_484		RU_3X996 + RU_484
+
+enum ath12k_eht_ru_size {
+	ATH12K_EHT_RU_26,
+	ATH12K_EHT_RU_52,
+	ATH12K_EHT_RU_106,
+	ATH12K_EHT_RU_242,
+	ATH12K_EHT_RU_484,
+	ATH12K_EHT_RU_996,
+	ATH12K_EHT_RU_996x2,
+	ATH12K_EHT_RU_996x4,
+	ATH12K_EHT_RU_52_26,
+	ATH12K_EHT_RU_106_26,
+	ATH12K_EHT_RU_484_242,
+	ATH12K_EHT_RU_996_484,
+	ATH12K_EHT_RU_996_484_242,
+	ATH12K_EHT_RU_996x2_484,
+	ATH12K_EHT_RU_996x3,
+	ATH12K_EHT_RU_996x3_484,
+	ATH12K_EHT_RU_INVALID,
+};
+
 void ath12k_hal_reo_status_queue_stats(struct ath12k_base *ab, u32 *reo_desc,
 				       struct hal_reo_status *status);
 void ath12k_hal_reo_flush_queue_status(struct ath12k_base *ab, u32 *reo_desc,
@@ -702,4 +1098,142 @@ void ath12k_hal_rx_reo_ent_buf_paddr_get
 #define HAL_RX_MPDU_ERR_MSDU_LEN		BIT(5)
 #define HAL_RX_MPDU_ERR_MPDU_LEN		BIT(6)
 #define HAL_RX_MPDU_ERR_UNENCRYPTED_FRAME	BIT(7)
+
+/* U-SIG Common Mask */
+#define USIG_PHY_VERSION_KNOWN	0x00000001
+#define USIG_BW_KNOWN		0x00000002
+#define USIG_UL_DL_KNOWN	0x00000004
+#define USIG_BSS_COLOR_KNOWN	0x00000008
+#define USIG_TXOP_KNOWN		0x00000010
+
+#define USIG_PHY_VERSION_SHIFT	12
+#define USIG_BW_SHIFT		15
+#define USIG_UL_DL_SHIFT	18
+#define USIG_BSS_COLOR_SHIFT	19
+#define USIG_TXOP_SHIFT		25
+
+/* U-SIG MU/TB Value */
+#define USIG_DISREGARD_SHIFT			0
+#define USIG_PPDU_TYPE_N_COMP_MODE_SHIFT	6
+#define USIG_VALIDATE_SHIFT			8
+
+#define USIG_MU_VALIDATE1_SHIFT			5
+#define USIG_MU_PUNCTURE_CH_INFO_SHIFT		9
+#define USIG_MU_VALIDATE2_SHIFT			12
+#define USIG_MU_EHT_SIG_MCS_SHIFT		15
+#define USIG_MU_NUM_EHT_SIG_SYM_SHIFT		17
+
+#define USIG_TB_SPATIAL_REUSE_1_SHIFT		9
+#define USIG_TB_SPATIAL_REUSE_2_SHIFT		13
+#define USIG_TB_DISREGARD1_SHIFT		17
+
+#define USIG_CRC_SHIFT				22
+#define USIG_TAIL_SHIFT				26
+
+/* U-SIG MU/TB Mask */
+#define USIG_DISREGARD_KNOWN			0x00000001
+#define USIG_PPDU_TYPE_N_COMP_MODE_KNOWN	0x00000004
+#define USIG_VALIDATE_KNOWN			0x00000008
+
+#define USIG_MU_VALIDATE1_KNOWN			0x00000002
+#define USIG_MU_PUNCTURE_CH_INFO_KNOWN		0x00000010
+#define USIG_MU_VALIDATE2_KNOWN			0x00000020
+#define USIG_MU_EHT_SIG_MCS_KNOWN		0x00000040
+#define USIG_MU_NUM_EHT_SIG_SYM_KNOWN		0x00000080
+#define USIG_TB_SPATIAL_REUSE_1_KNOWN		0x00000010
+#define USIG_TB_SPATIAL_REUSE_2_KNOWN		0x00000020
+#define USIG_TB_DISREGARD1_KNOWN		0x00000040
+
+#define USIG_CRC_KNOWN				0x00000100
+#define USIG_TAIL_KNOWN				0x00000200
+
+/* EHT known mask */
+#define EHT_CONTENT_CH_INDEX_KNOWN		0x00000001
+#define EHT_SPATIAL_REUSE_KNOWN			0x00000002
+#define EHT_GUARD_INTERVAL_KNOWN		0x00000004
+#define EHT_LTF_KNOWN				0x00000008
+#define EHT_EHT_LTF_KNOWN			0x00000010
+#define EHT_LDPC_EXTRA_SYMBOL_SEG_KNOWN		0x00000020
+#define EHT_PRE_FEC_PADDING_FACTOR_KNOWN	0x00000040
+#define EHT_PE_DISAMBIGUITY_KNOWN		0x00000080
+#define EHT_DISREARD_KNOWN			0x00000100
+#define EHT_CRC1_KNOWN				0x00002000
+#define EHT_TAIL1_KNOWN				0x00004000
+#define EHT_CRC2_KNOWN				0x00008000
+#define EHT_TAIL2_KNOWN				0x00010000
+#define EHT_RU_MRU_SIZE_KNOWN			0x00400000
+#define EHT_RU_MRU_INDEX_KNOWN			0x00800000
+#define EHT_TB_RU_ALLOCATION_KNOWN		0x01000000
+
+#define EHT_NUM_NON_OFDMA_USERS_KNOWN		0x00080000
+#define EHT_USER_ENC_BLOCK_CRC_KNOWN		0x00100000
+#define EHT_USER_ENC_BLOCK_TAIL_KNOWN		0x00200000
+
+#define EHT_NDP_DISREGARD_KNOWN			0x00000200
+#define EHT_NDP_NSS_KNOWN			0x00020000
+#define EHT_NDP_BEAMFORMED_KNOWN		0x00040000
+
+#define EHT_NUM_KNOWN_RU_ALLOCATIONS_SHIFT	10
+
+/* EHT data0 Mask/SHIFT */
+#define EHT_CONTENT_CH_INDEX_SHIFT		0
+#define EHT_SPATIAL_REUSE_SHIFT			3
+#define EHT_GI_SHIFT				7
+#define EHT_LTF_SHIFT				9
+#define EHT_EHT_LTF_SHIFT			11
+#define EHT_LDPC_EXTRA_SYMBOL_SEG_SHIFT		14
+#define EHT_PRE_FEC_PADDING_FACTOR_SHIFT	15
+#define EHT_PE_DISAMBIGUITY_SHIFT		17
+#define EHT_NDP_DISREGARD_SHIFT			18
+#define EHT_DISREGARD_SHIFT			18
+#define EHT_CRC1_SHIFT				22
+#define EHT_TAIL1_SHIFT				26
+
+/* EHT data1 Mask/SHIFT */
+#define EHT_RU_MRU_SIZE_SHIFT			0
+#define EHT_RU_MRU_INDEX_SHIFT			5
+#define EHT_RU_ALLOCATION1_1_SHIFT		13
+#define EHT_RU_ALLOCATION1_2_SHIFT		22
+
+/* EHT data2 Mask/SHIFT */
+#define EHT_RU_ALLOCATION2_1_SHIFT		0
+#define EHT_RU_ALLOCATION2_2_SHIFT		9
+#define EHT_RU_ALLOCATION2_3_SHIFT		18
+
+/* EHT data3 Mask/SHIFT */
+#define EHT_RU_ALLOCATION2_4_SHIFT		0
+#define EHT_RU_ALLOCATION2_5_SHIFT		9
+#define EHT_RU_ALLOCATION2_6_SHIFT		18
+
+/* EHT data4 Mask/SHIFT */
+#define EHT_CRC2_SHIFT				0
+#define EHT_TAIL2_SHIFT				4
+#define EHT_NDP_NSS_SHIFT			12
+#define EHT_NDP_BEAMFORMED_SHIFT		16
+#define EHT_NUM_NON_OFDMA_USERS_SHIFT		17
+#define EHT_USER_ENC_BLOCK_CRC_SHIFT		20
+#define EHT_USER_ENC_BLOCK_TAIL_SHIFT		24
+
+/* EHT data5 Mask/SHIFT */
+#define EHT_TB_RU_PS160_SHIFT			0
+#define EHT_TB_RU_PS80_SHIFT			1
+#define EHT_TB_RU_B7_B1_SHIFT			2
+
+/* EHT user info Mask/SHIFT */
+#define EHT_USER_STA_ID_KNOWN			0x00000001
+#define EHT_USER_MCS_KNOWN			0x00000002
+#define EHT_USER_CODING_KNOWN			0x00000004
+#define EHT_USER_RESERVED_KNOWN			0x00000008
+#define EHT_USER_NSS_KNOWN			0x00000010
+#define EHT_USER_BEAMFORMING_KNOWN		0x00000020
+#define EHT_USER_SPATIAL_CONFIG_KNOWN		0x00000040
+
+#define EHT_USER_DATA_FOR_THIS_USER_SHIFT	7
+#define EHT_USER_STA_ID_SHIFT			8
+#define EHT_USER_CODING_SHIFT			19
+#define EHT_USER_MCS_SHIFT			20
+#define EHT_USER_NSS_SHIFT			24
+#define EHT_USER_RESERVED_SHIFT			28
+#define EHT_USER_BEAMFORMING_SHIFT		29
+#define EHT_USER_SPATIAL_CONFIG_SHIFT		24
 #endif
--- a/drivers/net/wireless/ath/ath12k/dp_mon.h
+++ b/drivers/net/wireless/ath/ath12k/dp_mon.h
@@ -8,6 +8,7 @@
 #define ATH12K_DP_MON_H
 
 #include "core.h"
+#include "debugfs_htt_stats.h"
 
 #define ATH12K_DP_TX_MONITOR_MODE 0
 #define ATH12K_DP_RX_MONITOR_MODE 1
--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
@@ -14,7 +14,6 @@
 #define HTT_MAX_STRING_LEN 256
 #define HTT_MAX_PRINT_CHAR_PER_ELEM 15
 
-#define HTT_TLV_HDR_LEN 4
 
 #define PRINT_ARRAY_TO_BUF(out, buflen, arr, str, len, newline)				\
 	do {										\
--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
@@ -10,6 +10,7 @@
 #define HTT_STATS_COOKIE_LSB    GENMASK_ULL(31, 0)
 #define HTT_STATS_COOKIE_MSB    GENMASK_ULL(63, 32)
 #define HTT_STATS_MAGIC_VALUE   0xF0F0F0F0
+#define HTT_TLV_HDR_LEN                4
 
 enum htt_tlv_tag_t {
 	HTT_STATS_TX_PDEV_CMN_TAG                           = 0,
