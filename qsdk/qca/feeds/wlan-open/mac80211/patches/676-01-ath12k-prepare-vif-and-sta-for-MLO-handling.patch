From 0144e259111a1bc79b965f9b0f3ac7e0161b7f2c Mon Sep 17 00:00:00 2001
From: Sriram R <quic_srirrama@quicinc.com>
Date: Tue, 8 Nov 2022 14:21:41 +0530
Subject: [PATCH] ath12k: prepare vif and sta for MLO handling

Use arvif and arsta per radio and not per hw which comprises
multiple links. Also configs from mac80211 will be done
per link, hence do some refactoring so that these configs
are applied at link level.

Split ath12k_vif which is the driver private of ieee80211_vif
to store link specific information.
Buy default the ath12k vif will have a preallocated link vif
called by deflink which will be used by non ML and the first
link vif of ML vif. Remaining link vifs are allocated during
channel assignment where vdev create/start happens. THis link
vif will be freed during interface down.

Currently change_vif_links() mac80211 op is not used, rather
these links are set during channel assign.

To refactor existing ath12k_vif to make use of link vifs, following
changes are made,
1. ieee80211_vif attribute in functions across ath12k is limited to
 functions which are interface to mac80211 only.
2. THese functions which passed ieee80211_vif are replaced with ath12k_link_vif which is previously
arvif/ath12k_vif and internally ath12k_vif and vif are fetched.
3. ath12k_vif now called by varname ahvif stores multiple arvifs and
pointer to ieee80211_vif.
4. To avoid passing link_id across multiple functions and validating
them the arvif of corresponding link id is fetched and passed in these
functions and validation is done common to these functions.
5. Currently 0 is used as the default link id for non ML and these
link info is used across the driver. Later this will be replaced with
appropriate link id passed from mac80211 with MLO support
6. For mac ops which doesnt get link_id, it implies the config or info
is common for the vif, and hence it will be applied to all arvifs.

Also, move link specific sta info to ath12k_link_sta
and use deflink currently for all link specific
operations.

Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/core.c        |    2 +-
 drivers/net/wireless/ath/ath12k/core.h        |   99 +-
 drivers/net/wireless/ath/ath12k/debugfs.c     |   26 +-
 drivers/net/wireless/ath/ath12k/debugfs.h     |    8 +-
 drivers/net/wireless/ath/ath12k/debugfs_sta.c |   65 +-
 drivers/net/wireless/ath/ath12k/debugfs_sta.h |    4 +-
 drivers/net/wireless/ath/ath12k/dp.c          |   25 +-
 drivers/net/wireless/ath/ath12k/dp.h          |    6 +-
 drivers/net/wireless/ath/ath12k/dp_mon.c      |   22 +-
 drivers/net/wireless/ath/ath12k/dp_rx.c       |   48 +-
 drivers/net/wireless/ath/ath12k/dp_rx.h       |    2 +-
 drivers/net/wireless/ath/ath12k/dp_tx.c       |   35 +-
 drivers/net/wireless/ath/ath12k/dp_tx.h       |    4 +-
 drivers/net/wireless/ath/ath12k/mac.c         | 1663 ++++++++++++-----
 drivers/net/wireless/ath/ath12k/mac.h         |   11 +-
 drivers/net/wireless/ath/ath12k/peer.c        |   14 +-
 drivers/net/wireless/ath/ath12k/peer.h        |    2 +-
 drivers/net/wireless/ath/ath12k/spectral.c    |    6 +-
 drivers/net/wireless/ath/ath12k/spectral.h    |    4 +-
 drivers/net/wireless/ath/ath12k/testmode.c    |    3 +-
 drivers/net/wireless/ath/ath12k/wmi.c         |   50 +-
 21 files changed, 1410 insertions(+), 689 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -1268,7 +1268,7 @@ static void ath12k_core_restart(struct w
 	int ret;
 	struct ath12k *ar;
 	struct ath12k_pdev *pdev;
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	struct ath12k_hw *ah;
 	int i, j;
 
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -311,12 +311,11 @@ struct ath12k_vif_cache {
 	u64 bss_conf_changed;
 };
 
-struct ath12k_vif {
+struct ath12k_link_vif {
 	u32 vdev_id;
-	enum wmi_vdev_type vdev_type;
-	enum wmi_vdev_subtype vdev_subtype;
 	u32 beacon_interval;
 	u32 dtim_period;
+	u8 addr[ETH_ALEN];
 	u16 ast_hash;
 	u16 ast_idx;
 	u16 tcl_metadata;
@@ -324,7 +323,6 @@ struct ath12k_vif {
 	u8 search_type;
 
 	struct ath12k *ar;
-	struct ieee80211_vif *vif;
 
 	int bank_id;
 	u8 vdev_id_check_en;
@@ -332,39 +330,18 @@ struct ath12k_vif {
 	u16 tx_seq_no;
 	struct wmi_wmm_params_all_arg wmm_params;
 	struct list_head list;
-	union {
-		struct {
-			u32 uapsd;
-		} sta;
-		struct {
-			/* 127 stations; wmi limit */
-			u8 tim_bitmap[16];
-			u8 tim_len;
-			u32 ssid_len;
-			u8 ssid[IEEE80211_MAX_SSID_LEN];
-			bool hidden_ssid;
-			/* P2P_IE with NoA attribute for P2P_GO case */
-			u32 noa_len;
-			u8 *noa_data;
-		} ap;
-	} u;
 
 	bool is_created;
 	bool is_started;
 	bool is_up;
 	bool spectral_enabled;
-	u32 aid;
 	u8 bssid[ETH_ALEN];
 	struct cfg80211_bitrate_mask bitrate_mask;
 	int num_legacy_stations;
 	int rtscts_prot_mode;
 	int txpower;
-	bool rsnie_present;
-	bool wpaie_present;
 	struct ieee80211_chanctx_conf chanctx;
 	struct ath12k_reg_tpc_power_info reg_tpc_info;
-	u32 key_cipher;
-	u8 tx_encap_type;
 	u8 vdev_stats_id;
 	struct ath12k_fw_vdev_ol_stats vdev_stats;
 	u8 nontransmitting_vif_count;
@@ -378,13 +355,48 @@ struct ath12k_vif {
 	struct work_struct update_bcn_template_work;
 	u64 obss_color_bitmap;
 	struct work_struct update_obss_color_notify_work;
+	u8 link_id;
+	struct ath12k_vif *ahvif;
+};
+
+struct ath12k_vif {
+	enum wmi_vdev_type vdev_type;
+	enum wmi_vdev_subtype vdev_subtype;
+	struct ieee80211_vif *vif;
+	struct ath12k_hw *ah;
+	bool rsnie_present;
+	bool wpaie_present;
+	u8 tx_encap_type;
+	u32 key_cipher;
+	union {
+		struct {
+			u32 uapsd;
+		} sta;
+		struct {
+			/* 127 stations; wmi limit */
+			u8 tim_bitmap[16];
+			u8 tim_len;
+			u32 ssid_len;
+			u8 ssid[IEEE80211_MAX_SSID_LEN];
+			bool hidden_ssid;
+			/* P2P_IE with NoA attribute for P2P_GO case */
+			u32 noa_len;
+			u8 *noa_data;
+		} ap;
+	} u;
+
+	struct ath12k_link_vif deflink;
+	struct ath12k_link_vif *link[IEEE80211_MLD_MAX_NUM_LINKS];
+	/* indicates bitmap of link vdev created in FW */
+	u16 links_map;
+	u32 aid;
 	struct ath12k_mgmt_frame_stats mgmt_stats;
 };
 
 struct ath12k_vif_iter {
 	u32 vdev_id;
 	struct ath12k *ar;
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 };
 
 #define HAL_AST_IDX_INVALID	0xFFFF
@@ -534,40 +546,50 @@ struct ath12k_driver_rx_pkts_flow {
 	atomic_t pkts_out;
 };
 
-struct ath12k_sta {
-	struct ath12k_vif *arvif;
+struct ath12k_link_sta {
+	struct ath12k_link_vif *arvif;
+	struct ath12k_sta *ahsta;
 
 	/* the following are protected by ar->data_lock */
 	u32 changed; /* IEEE80211_RC_* */
 	u32 bw;
 	u32 nss;
 	u32 smps;
-	enum hal_pn_type pn_type;
 
 	struct work_struct update_wk;
-	struct work_struct set_4addr_wk;
 	struct rate_info txrate;
 	u32 peer_nss;
 	struct rate_info last_txrate;
 	u64 rx_duration;
 	u64 tx_duration;
 	u8 rssi_comb;
+
 	struct ath12k_htt_tx_stats *tx_stats;
 	struct ath12k_rx_peer_stats *rx_stats;
+	struct ath12k_driver_tx_pkts_flow drv_tx_pkts;
+	struct ath12k_driver_rx_pkts_flow drv_rx_pkts;
 	struct ath12k_wbm_tx_stats *wbm_tx_stats;
 
-#ifdef CPTCFG_MAC80211_DEBUGFS
-	/* protected by conf_mutex */
-	bool aggr_mode;
-#endif
-
-	bool use_4addr_set;
 	u16 tcl_metadata;
 	u32 bw_prev;
-	struct ath12k_driver_tx_pkts_flow drv_tx_pkts;
-	struct ath12k_driver_rx_pkts_flow drv_rx_pkts;
+	u8 link_id;
 };
 
+struct ath12k_sta {
+	struct ath12k_vif *ahvif;
+ #ifdef CPTCFG_MAC80211_DEBUGFS
+	/* protected by conf_mutex */
+	bool aggr_mode;
+ #endif
+	bool use_4addr_set;
+	struct work_struct set_4addr_wk;
+	enum hal_pn_type pn_type;
+
+	struct ath12k_link_sta deflink;
+	struct ath12k_link_sta *link[IEEE80211_MLD_MAX_NUM_LINKS];
+	/* indicates bitmap of link sta created in FW */
+	u16 links_map;
+ };
 #define ATH12K_HALF_20MHZ_BW 10
 #define ATH12K_5G_MIN_CENTER 4900
 #define ATH12K_5G_MAX_CENTER 5920
@@ -1305,7 +1327,7 @@ static inline struct ath12k_skb_rxcb *AT
 	return (struct ath12k_skb_rxcb *)skb->cb;
 }
 
-static inline struct ath12k_vif *ath12k_vif_to_arvif(struct ieee80211_vif *vif)
+static inline struct ath12k_vif *ath12k_vif_to_ahvif(struct ieee80211_vif *vif)
 {
 	return (struct ath12k_vif *)vif->drv_priv;
 }
--- a/drivers/net/wireless/ath/ath12k/debugfs.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs.c
@@ -379,7 +379,7 @@ static const struct file_operations fops
 static int ath12k_open_bcn_stats(struct inode *inode, struct file *file)
 {
 	struct ath12k *ar = inode->i_private;
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	struct stats_request_params req_param;
 	void *buf = NULL;
 	int ret;
@@ -2353,7 +2353,7 @@ static ssize_t ath12k_dump_mgmt_stats(st
 					size_t count, loff_t *ppos)
 {
 	struct ath12k *ar = file->private_data;
-	struct ath12k_vif *arvif = NULL;
+	struct ath12k_link_vif *arvif = NULL;
 	struct ath12k_mgmt_frame_stats *mgmt_stats;
 	int len = 0, ret, i;
 	int size = (TARGET_NUM_VDEVS - 1) * 1500;
@@ -2380,9 +2380,9 @@ static ssize_t ath12k_dump_mgmt_stats(st
 		if (!arvif)
 			break;
 
-		if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR)
+		if (arvif->ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR)
 			continue;
-		mgmt_stats = &arvif->mgmt_stats;
+		mgmt_stats = &arvif->ahvif->mgmt_stats;
 		len += scnprintf(buf + len, size - len, "MGMT frame stats for vdev %u :\n", arvif->vdev_id);
 		len += scnprintf(buf + len, size - len, "  TX stats :\n ");
 		len += scnprintf(buf + len, size - len, "  Success frames:\n");
@@ -2524,7 +2524,7 @@ static ssize_t ath12k_write_twt_add_dial
 					   const char __user *ubuf,
 					   size_t count, loff_t *ppos)
 {
-	struct ath12k_vif *arvif = file->private_data;
+	struct ath12k_link_vif *arvif = file->private_data;
 	struct wmi_twt_add_dialog_params params = { 0 };
 	u8 buf[128] = {0};
 	int ret;
@@ -2573,7 +2573,7 @@ static ssize_t ath12k_write_twt_del_dial
 					   const char __user *ubuf,
 					   size_t count, loff_t *ppos)
 {
-	struct ath12k_vif *arvif = file->private_data;
+	struct ath12k_link_vif *arvif = file->private_data;
 	struct wmi_twt_del_dialog_params params = { 0 };
 	u8 buf[64] = {0};
 	int ret;
@@ -2612,7 +2612,7 @@ static ssize_t ath12k_write_twt_pause_di
 					     const char __user *ubuf,
 					     size_t count, loff_t *ppos)
 {
-	struct ath12k_vif *arvif = file->private_data;
+	struct ath12k_link_vif *arvif = file->private_data;
 	struct wmi_twt_pause_dialog_params params = { 0 };
 	u8 buf[64] = {0};
 	int ret;
@@ -2651,7 +2651,7 @@ static ssize_t ath12k_write_twt_resume_d
 					      const char __user *ubuf,
 					      size_t count, loff_t *ppos)
 {
-	struct ath12k_vif *arvif = file->private_data;
+	struct ath12k_link_vif *arvif = file->private_data;
 	struct wmi_twt_resume_dialog_params params = { 0 };
 	u8 buf[64] = {0};
 	int ret;
@@ -2708,11 +2708,13 @@ static const struct file_operations ath1
 	.open = simple_open
 };
 
-int ath12k_debugfs_add_interface(struct ath12k_vif *arvif)
+int ath12k_debugfs_add_interface(struct ath12k_link_vif *arvif)
 {
-	if (arvif->vif->type == NL80211_IFTYPE_AP && !arvif->debugfs_twt) {
+	struct ath12k_vif *ahvif = arvif->ahvif;
+
+	if (ahvif->vif->type == NL80211_IFTYPE_AP && !arvif->debugfs_twt) {
 		arvif->debugfs_twt = debugfs_create_dir("twt",
-							arvif->vif->debugfs_dir);
+							ahvif->vif->debugfs_dir);
 		if (!arvif->debugfs_twt || IS_ERR(arvif->debugfs_twt)) {
 			ath12k_warn(arvif->ar->ab,
 				    "failed to create directory %p\n",
@@ -2736,7 +2738,7 @@ int ath12k_debugfs_add_interface(struct
 	return 0;
 }
 
-void ath12k_debugfs_remove_interface(struct ath12k_vif *arvif)
+void ath12k_debugfs_remove_interface(struct ath12k_link_vif *arvif)
 {
 	debugfs_remove_recursive(arvif->debugfs_twt);
 	arvif->debugfs_twt = NULL;
--- a/drivers/net/wireless/ath/ath12k/debugfs.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs.h
@@ -243,8 +243,8 @@ static inline int ath12k_debugfs_rx_filt
 	return ar->debug.rx_filter;
 }
 
-int ath12k_debugfs_add_interface(struct ath12k_vif *arvif);
-void ath12k_debugfs_remove_interface(struct ath12k_vif *arvif);
+int ath12k_debugfs_add_interface(struct ath12k_link_vif *arvif);
+void ath12k_debugfs_remove_interface(struct ath12k_link_vif *arvif);
 
 #else
 static inline int ath12k_debugfs_create(void)
@@ -322,11 +322,11 @@ static inline int ath12k_debugfs_rx_filt
 	return 0;
 }
 
-static inline int ath12k_debugfs_add_interface(struct ath12k_vif *arvif)
+static inline int ath12k_debugfs_add_interface(struct ath12k_link_vif *arvif)
 {
 }
 
-static inline void ath12k_debugfs_remove_interface(struct ath12k_vif *arvif)
+static inline void ath12k_debugfs_remove_interface(struct ath12k_link_vif *arvif)
 {
 }
 #endif /* CPTCFG_MAC80211_DEBUGFS*/
--- a/drivers/net/wireless/ath/ath12k/debugfs_sta.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs_sta.c
@@ -14,7 +14,7 @@
 #include "debugfs_htt_stats.h"
 #include "debugfs.h"
 
-void ath12k_debugfs_sta_add_tx_stats(struct ath12k_sta *arsta,
+void ath12k_debugfs_sta_add_tx_stats(struct ath12k_link_sta *arsta,
 				     struct ath12k_per_peer_tx_stats *peer_stats,
 				     u8 legacy_rate_idx)
 {
@@ -200,7 +200,8 @@ static ssize_t ath12k_dbg_sta_dump_tx_st
 					    size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	struct ath12k_htt_data_stats *stats;
 	static const char *str_name[ATH12K_STATS_TYPE_MAX] = {"success", "fail",
@@ -391,7 +392,8 @@ static ssize_t ath12k_dbg_sta_dump_rx_st
 					    size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	struct ath12k_rx_peer_stats *rx_stats = arsta->rx_stats;
 	int len = 0, i, retval = 0;
@@ -661,7 +663,8 @@ static int
 ath12k_dbg_sta_open_htt_peer_stats(struct inode *inode, struct file *file)
 {
 	struct ieee80211_sta *sta = inode->i_private;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	struct debug_htt_stats_req *stats_req;
 	int type = ar->debug.htt_stats.type;
@@ -697,7 +700,8 @@ static int
 ath12k_dbg_sta_release_htt_peer_stats(struct inode *inode, struct file *file)
 {
 	struct ieee80211_sta *sta = inode->i_private;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 
 	mutex_lock(&ar->conf_mutex);
@@ -734,7 +738,8 @@ static ssize_t ath12k_dbg_sta_write_peer
 						size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	int ret, enable;
 
@@ -774,7 +779,8 @@ static ssize_t ath12k_dbg_sta_read_peer_
 					       size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	char buf[32] = {0};
 	int len;
@@ -801,7 +807,8 @@ static ssize_t ath12k_dbg_sta_write_delb
 					  size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	u32 tid, initiator, reason;
 	int ret;
@@ -822,7 +829,7 @@ static ssize_t ath12k_dbg_sta_write_delb
 
 	mutex_lock(&ar->conf_mutex);
 	if (ar->state != ATH12K_STATE_ON ||
-	    arsta->aggr_mode != ATH12K_DBG_AGGR_MODE_MANUAL) {
+	    ahsta->aggr_mode != ATH12K_DBG_AGGR_MODE_MANUAL) {
 		ret = count;
 		goto out;
 	}
@@ -852,7 +859,8 @@ static ssize_t ath12k_dbg_sta_write_addb
 					       size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	u32 tid, status;
 	int ret;
@@ -873,7 +881,7 @@ static ssize_t ath12k_dbg_sta_write_addb
 
 	mutex_lock(&ar->conf_mutex);
 	if (ar->state != ATH12K_STATE_ON ||
-	    arsta->aggr_mode != ATH12K_DBG_AGGR_MODE_MANUAL) {
+	    ahsta->aggr_mode != ATH12K_DBG_AGGR_MODE_MANUAL) {
 		ret = count;
 		goto out;
 	}
@@ -902,7 +910,8 @@ static ssize_t ath12k_dbg_sta_write_addb
 					  size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	u32 tid, buf_size;
 	int ret;
@@ -923,7 +932,7 @@ static ssize_t ath12k_dbg_sta_write_addb
 
 	mutex_lock(&ar->conf_mutex);
 	if (ar->state != ATH12K_STATE_ON ||
-	    arsta->aggr_mode != ATH12K_DBG_AGGR_MODE_MANUAL) {
+	    ahsta->aggr_mode != ATH12K_DBG_AGGR_MODE_MANUAL) {
 		ret = count;
 		goto out;
 	}
@@ -953,7 +962,8 @@ static ssize_t ath12k_dbg_sta_read_aggr_
 					     size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	char buf[64];
 	int len = 0;
@@ -961,7 +971,7 @@ static ssize_t ath12k_dbg_sta_read_aggr_
 	mutex_lock(&ar->conf_mutex);
 	len = scnprintf(buf, sizeof(buf) - len,
 			"aggregation mode: %s\n\n%s\n%s\n",
-			(arsta->aggr_mode == ATH12K_DBG_AGGR_MODE_AUTO) ?
+			(ahsta->aggr_mode == ATH12K_DBG_AGGR_MODE_AUTO) ?
 			"auto" : "manual", "auto = 0", "manual = 1");
 	mutex_unlock(&ar->conf_mutex);
 
@@ -973,7 +983,8 @@ static ssize_t ath12k_dbg_sta_write_aggr
 					      size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	u32 aggr_mode;
 	int ret;
@@ -986,7 +997,7 @@ static ssize_t ath12k_dbg_sta_write_aggr
 
 	mutex_lock(&ar->conf_mutex);
 	if (ar->state != ATH12K_STATE_ON ||
-	    aggr_mode == arsta->aggr_mode) {
+	    aggr_mode == ahsta->aggr_mode) {
 		ret = count;
 		goto out;
 	}
@@ -998,7 +1009,7 @@ static ssize_t ath12k_dbg_sta_write_aggr
 		goto out;
 	}
 
-	arsta->aggr_mode = aggr_mode;
+	ahsta->aggr_mode = aggr_mode;
 out:
 	mutex_unlock(&ar->conf_mutex);
 	return ret;
@@ -1018,7 +1029,8 @@ ath12k_write_htt_peer_stats_reset(struct
 				  size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	struct htt_ext_stats_cfg_params cfg_params = { 0 };
 	int ret;
@@ -1078,7 +1090,8 @@ ath12k_dbg_sta_dump_driver_tx_pkts_flow(
 					size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	int len = 0, ret_val;
 	const int size = ATH12K_DRV_TX_STATS_SIZE;
@@ -1123,7 +1136,8 @@ static ssize_t ath12k_dbg_sta_reset_tx_s
 					     size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	int ret, reset;
 
@@ -1161,7 +1175,8 @@ ath12k_dbg_sta_dump_driver_rx_pkts_flow(
 					size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	struct ath12k_rx_peer_stats *rx_stats = arsta->rx_stats;
 	int len = 0, ret_val = 0;
@@ -1211,7 +1226,8 @@ static ssize_t ath12k_dbg_sta_reset_rx_s
 					     size_t count, loff_t *ppos)
 {
 	struct ieee80211_sta *sta = file->private_data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	struct ath12k *ar = arsta->arvif->ar;
 	int ret, reset;
 
@@ -1250,7 +1266,8 @@ void ath12k_debugfs_sta_op_add(struct ie
 
 	mutex_lock(&ah->conf_mutex);
 
-	ar = ath12k_get_ar_by_vif(hw, vif);
+	/* TODO for ML vifs */
+	ar = ath12k_get_ar_by_vif(hw, vif, 0);
 	if (!ar) {
 		mutex_unlock(&ah->conf_mutex);
 		return;
--- a/drivers/net/wireless/ath/ath12k/debugfs_sta.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs_sta.h
@@ -17,7 +17,7 @@
 
 void ath12k_debugfs_sta_op_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			       struct ieee80211_sta *sta, struct dentry *dir);
-void ath12k_debugfs_sta_add_tx_stats(struct ath12k_sta *arsta,
+void ath12k_debugfs_sta_add_tx_stats(struct ath12k_link_sta *arsta,
 				     struct ath12k_per_peer_tx_stats *peer_stats,
 				     u8 legacy_rate_idx);
 void ath12k_debugfs_sta_update_txcompl(struct ath12k *ar,
@@ -28,7 +28,7 @@ void ath12k_debugfs_sta_update_txcompl(s
 #define ath12k_debugfs_sta_op_add NULL
 
 static inline void
-ath12k_debugfs_sta_add_tx_stats(struct ath12k_sta *arsta,
+ath12k_debugfs_sta_add_tx_stats(struct ath12k_link_sta *arsta,
 				struct ath12k_per_peer_tx_stats *peer_stats,
 				u8 legacy_rate_idx)
 {
--- a/drivers/net/wireless/ath/ath12k/dp.c
+++ b/drivers/net/wireless/ath/ath12k/dp.c
@@ -342,22 +342,23 @@ int ath12k_dp_srng_setup(struct ath12k_b
 }
 
 static
-void ath12k_dp_tx_get_vdev_bank_config(struct ath12k_base *ab, struct ath12k_vif *arvif,
+void ath12k_dp_tx_get_vdev_bank_config(struct ath12k_base *ab, struct ath12k_link_vif *arvif,
 				       u32 *bank_config)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	enum hal_encrypt_type encrypt_type = 0;
 
 	/* Only valid for raw frames with HW crypto enabled.
 	 * With SW crypto, mac80211 sets key per packet
 	 */
-	if (arvif->tx_encap_type == HAL_TCL_ENCAP_TYPE_RAW &&
+	if (ahvif->tx_encap_type == HAL_TCL_ENCAP_TYPE_RAW &&
 	    test_bit(ATH12K_FLAG_HW_CRYPTO_DISABLED, &ab->dev_flags) &&
-	    arvif->key_cipher != INVALID_CIPHER)
-		encrypt_type = ath12k_dp_tx_get_encrypt_type(arvif->key_cipher);
+	    ahvif->key_cipher != INVALID_CIPHER)
+		encrypt_type = ath12k_dp_tx_get_encrypt_type(ahvif->key_cipher);
 	else
 		encrypt_type = HAL_ENCRYPT_TYPE_OPEN;
 
-	*bank_config |= u32_encode_bits(arvif->tx_encap_type,
+	*bank_config |= u32_encode_bits(ahvif->tx_encap_type,
 					HAL_TX_BANK_CONFIG_ENCAP_TYPE) |
 			u32_encode_bits(encrypt_type,
 					HAL_TX_BANK_CONFIG_ENCRYPT_TYPE);
@@ -374,7 +375,7 @@ void ath12k_dp_tx_get_vdev_bank_config(s
 					HAL_TX_ADDRY_EN),
 					HAL_TX_BANK_CONFIG_ADDRY_EN);
 
-	*bank_config |= u32_encode_bits(ieee80211_vif_is_mesh(arvif->vif) ? 3 : 0,
+	*bank_config |= u32_encode_bits(ieee80211_vif_is_mesh(ahvif->vif) ? 3 : 0,
 					HAL_TX_BANK_CONFIG_MESH_EN) |
 			u32_encode_bits(arvif->vdev_id_check_en,
 					HAL_TX_BANK_CONFIG_VDEV_ID_CHECK_EN);
@@ -382,7 +383,7 @@ void ath12k_dp_tx_get_vdev_bank_config(s
 	*bank_config |= u32_encode_bits(0, HAL_TX_BANK_CONFIG_DSCP_TIP_MAP_ID);
 }
 
-static int ath12k_dp_tx_get_bank_profile(struct ath12k_base *ab, struct ath12k_vif *arvif,
+static int ath12k_dp_tx_get_bank_profile(struct ath12k_base *ab, struct ath12k_link_vif *arvif,
 					 struct ath12k_dp *dp)
 {
 	int bank_id = DP_INVALID_BANK_ID;
@@ -439,7 +440,7 @@ void ath12k_dp_tx_put_bank_profile(struc
 	spin_unlock_bh(&dp->tx_bank_lock);
 }
 
-void ath12k_dp_tx_update_bank_profile(struct ath12k_vif *arvif)
+void ath12k_dp_tx_update_bank_profile(struct ath12k_link_vif *arvif)
 {
 	struct ath12k_base *ab = arvif->ar->ab;
 	struct ath12k_dp *dp = &ab->dp;
@@ -1101,9 +1102,11 @@ int ath12k_dp_htt_connect(struct ath12k_
 	return 0;
 }
 
-static void ath12k_dp_update_vdev_search(struct ath12k_vif *arvif)
+static void ath12k_dp_update_vdev_search(struct ath12k_link_vif *arvif)
 {
-	switch (arvif->vdev_type) {
+	struct ath12k_vif *ahvif = arvif->ahvif;
+
+	switch (ahvif->vdev_type) {
 	case WMI_VDEV_TYPE_STA:
 		/* TODO Verify the search type and flags since ast hash
 		 * is not part of peer mapv3
@@ -1122,7 +1125,7 @@ static void ath12k_dp_update_vdev_search
 	}
 }
 
-void ath12k_dp_vdev_tx_attach(struct ath12k *ar, struct ath12k_vif *arvif)
+void ath12k_dp_vdev_tx_attach(struct ath12k *ar, struct ath12k_link_vif *arvif)
 {
 	struct ath12k_base *ab = ar->ab;
 
--- a/drivers/net/wireless/ath/ath12k/dp.h
+++ b/drivers/net/wireless/ath/ath12k/dp.h
@@ -15,7 +15,7 @@
 struct ath12k_base;
 struct ath12k_peer;
 struct ath12k_dp;
-struct ath12k_vif;
+struct ath12k_link_vif;
 struct hal_tcl_status_ring;
 struct ath12k_ext_irq_grp;
 
@@ -2066,7 +2066,7 @@ int ath12k_dp_service_srng(struct ath12k
 			   struct ath12k_ext_irq_grp *irq_grp,
 			   int budget);
 int ath12k_dp_htt_connect(struct ath12k_dp *dp);
-void ath12k_dp_vdev_tx_attach(struct ath12k *ar, struct ath12k_vif *arvif);
+void ath12k_dp_vdev_tx_attach(struct ath12k *ar, struct ath12k_link_vif *arvif);
 void ath12k_dp_free(struct ath12k_base *ab);
 int ath12k_dp_alloc(struct ath12k_base *ab);
 void ath12k_dp_cc_config(struct ath12k_base *ab);
@@ -2092,5 +2092,5 @@ struct ath12k_rx_desc_info *ath12k_dp_ge
 						  u32 cookie);
 struct ath12k_tx_desc_info *ath12k_dp_get_tx_desc(struct ath12k_base *ab,
 						  u32 desc_id);
-void ath12k_dp_tx_update_bank_profile(struct ath12k_vif *arvif);
+void ath12k_dp_tx_update_bank_profile(struct ath12k_link_vif *arvif);
 #endif
--- a/drivers/net/wireless/ath/ath12k/dp_mon.c
+++ b/drivers/net/wireless/ath/ath12k/dp_mon.c
@@ -3294,7 +3294,7 @@ ath12k_dp_mon_rx_update_peer_rate_table_
 }
 
 static void ath12k_dp_mon_rx_update_peer_su_stats(struct ath12k *ar,
-						  struct ath12k_sta *arsta,
+						  struct ath12k_link_sta *arsta,
 						  struct hal_rx_mon_ppdu_info *ppdu_info)
 {
 	struct ath12k_rx_peer_stats *rx_stats = arsta->rx_stats;
@@ -3459,7 +3459,8 @@ ath12k_dp_mon_rx_update_user_stats(struc
 				   struct hal_rx_mon_ppdu_info *ppdu_info,
 				   u32 uid)
 {
-	struct ath12k_sta *arsta = NULL;
+	struct ath12k_sta *ahsta = NULL;
+	struct ath12k_link_sta *arsta;
 	struct ath12k_rx_peer_stats *rx_stats = NULL;
 	struct hal_rx_user_status *user_stats = &ppdu_info->userstats[uid];
 	struct ath12k_peer *peer;
@@ -3476,7 +3477,8 @@ ath12k_dp_mon_rx_update_user_stats(struc
 		return;
 	}
 
-	arsta = (struct ath12k_sta *)peer->sta->drv_priv;
+	ahsta = (struct ath12k_sta *)peer->sta->drv_priv;
+	arsta = &ahsta->deflink;
 	rx_stats = arsta->rx_stats;
 
 	if (!rx_stats)
@@ -3605,7 +3607,7 @@ int ath12k_dp_mon_srng_process(struct at
 	struct hal_rx_mon_ppdu_info *ppdu_info = &pmon->mon_ppdu_info;
 	struct sk_buff_head skb_list;
 	struct ath12k_peer *peer = NULL;
-	struct ath12k_sta *arsta = NULL;
+	struct ath12k_sta *ahsta = NULL;
 	u64 cookie;
 	u32 hal_status, end_reason, ppdu_id;
 	int num_buffs_reaped = 0, srng_id, buf_id;
@@ -3714,8 +3716,9 @@ move_next:
 		}
 
 		if (ppdu_info->reception_type == HAL_RX_RECEPTION_TYPE_SU) {
-			arsta = (struct ath12k_sta *)peer->sta->drv_priv;
-			ath12k_dp_mon_rx_update_peer_su_stats(ar, arsta, ppdu_info);
+			ahsta = (struct ath12k_sta *)peer->sta->drv_priv;
+			ath12k_dp_mon_rx_update_peer_su_stats(ar, &ahsta->deflink,
+							      ppdu_info);
 		} else if ((ppdu_info->fc_valid) &&
 			   (ppdu_info->ast_index != HAL_AST_IDX_INVALID)) {
 			ath12k_dp_mon_rx_process_ulofdma(ppdu_info);
@@ -3748,7 +3751,7 @@ int ath12k_dp_mon_rx_process_stats(struc
 	struct dp_srng *mon_dst_ring;
 	struct hal_srng *srng;
 	struct dp_rxdma_ring *buf_ring;
-	struct ath12k_sta *arsta = NULL;
+	struct ath12k_sta *ahsta = NULL;
 	struct ath12k_peer *peer;
 	struct sk_buff_head skb_list;
 	u64 cookie;
@@ -3859,8 +3862,9 @@ move_next:
 		}
 
 		if (ppdu_info->reception_type == HAL_RX_RECEPTION_TYPE_SU) {
-			arsta = (struct ath12k_sta *)peer->sta->drv_priv;
-			ath12k_dp_mon_rx_update_peer_su_stats(ar, arsta,
+			ahsta = (struct ath12k_sta *)peer->sta->drv_priv;
+			/* TODO Extend for Link STA */
+			ath12k_dp_mon_rx_update_peer_su_stats(ar, &ahsta->deflink,
 							      ppdu_info);
 		} else if ((ppdu_info->fc_valid) &&
 			   (ppdu_info->ast_index != HAL_AST_IDX_INVALID)) {
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -1095,13 +1095,15 @@ int ath12k_dp_rx_ampdu_start(struct ath1
 			     struct ieee80211_ampdu_params *params)
 {
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_sta *arsta = (void *)params->sta->drv_priv;
+	struct ath12k_sta *ahsta = (void *)params->sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	int vdev_id = arsta->arvif->vdev_id;
 	int ret;
 
+	/* TODO Handle per link in ath12k_mac_op_ampdu_action() for ML STA */
 	ret = ath12k_dp_rx_peer_tid_setup(ar, params->sta->addr, vdev_id,
 					  params->tid, params->buf_size,
-					  params->ssn, arsta->pn_type);
+					  params->ssn, ahsta->pn_type);
 	if (ret)
 		ath12k_warn(ab, "failed to setup rx tid %d\n", ret);
 
@@ -1113,7 +1115,8 @@ int ath12k_dp_rx_ampdu_stop(struct ath12
 {
 	struct ath12k_base *ab = ar->ab;
 	struct ath12k_peer *peer;
-	struct ath12k_sta *arsta = (void *)params->sta->drv_priv;
+	struct ath12k_sta *ahsta = (void *)params->sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
 	int vdev_id = arsta->arvif->vdev_id;
 	bool active;
 	int ret;
@@ -1145,7 +1148,7 @@ int ath12k_dp_rx_ampdu_stop(struct ath12
 	return ret;
 }
 
-int ath12k_dp_rx_peer_pn_replay_config(struct ath12k_vif *arvif,
+int ath12k_dp_rx_peer_pn_replay_config(struct ath12k_link_vif *arvif,
 				       const u8 *peer_addr,
 				       enum set_key_cmd key_cmd,
 				       struct ieee80211_key_conf *key)
@@ -1432,7 +1435,8 @@ ath12k_update_per_peer_tx_stats(struct a
 	struct ath12k_base *ab = ar->ab;
 	struct ath12k_peer *peer;
 	struct ieee80211_sta *sta;
-	struct ath12k_sta *arsta;
+	struct ath12k_sta *ahsta;
+	struct ath12k_link_sta *arsta;
 	struct htt_ppdu_stats_user_rate *user_rate;
 	struct htt_ppdu_stats *ppdu_stats = &ppdu_info->ppdu_stats;
 	struct ath12k_per_peer_tx_stats *peer_stats = &ar->peer_tx_stats;
@@ -1559,7 +1563,8 @@ ath12k_update_per_peer_tx_stats(struct a
 	}
 
 	sta = peer->sta;
-	arsta = (struct ath12k_sta *)sta->drv_priv;
+	ahsta = (struct ath12k_sta *)sta->drv_priv;
+	arsta = &ahsta->deflink;
 
 	memset(&arsta->txrate, 0, sizeof(arsta->txrate));
 
@@ -1900,7 +1905,7 @@ static void ath12k_htt_vdev_txrx_stats_h
 {
 	struct htt_t2h_vdev_txrx_stats_ind *vdev_tlv;
 	struct htt_t2h_vdev_common_stats_tlv *soc_tlv;
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	const struct htt_tlv *tlv;
 	u32 *data = (u32 *)skb->data;
 	u32 vdev_id;
@@ -2829,7 +2834,8 @@ static void ath12k_dp_rx_deliver_msdu(st
 	u8 decap = DP_RX_DECAP_TYPE_RAW;
 	bool is_mcbc = rxcb->is_mcbc;
 	bool is_eapol = rxcb->is_eapol;
-	struct ath12k_sta *arsta = NULL;
+	struct ath12k_link_sta *arsta = NULL;
+	struct ath12k_sta *ahsta = NULL;
 
 	if (status->encoding == RX_ENC_HE && !(status->flag & RX_FLAG_RADIOTAP_HE) &&
 	    !(status->flag & RX_FLAG_SKIP_MONITOR)) {
@@ -2895,9 +2901,10 @@ static void ath12k_dp_rx_deliver_msdu(st
 	if (ath12k_debugfs_is_extd_rx_stats_enabled(ar)) {
 		if (!(status->flag & RX_FLAG_ONLY_MONITOR)) {
 			spin_lock_bh(&ar->ab->base_lock);
-			if (peer && peer->sta)
-				arsta =
-				(struct ath12k_sta *)peer->sta->drv_priv;
+			if (peer && peer->sta) {
+				ahsta = (struct ath12k_sta *)peer->sta->drv_priv;
+				arsta = &ahsta->deflink;
+			}
 			spin_unlock_bh(&ar->ab->base_lock);
 			if (arsta)
 				atomic_inc(&arsta->drv_rx_pkts.pkts_out);
@@ -3047,7 +3054,8 @@ int ath12k_dp_rx_process(struct ath12k_b
 	u32 *rx_desc;
 	int i;
 	u64 desc_va;
-	struct ath12k_sta *arsta = NULL;
+	struct ath12k_sta *ahsta = NULL;
+	struct ath12k_link_sta *arsta = NULL;
 	struct ath12k_peer *peer = NULL;
 	struct ath12k *ar;
 
@@ -3122,9 +3130,10 @@ try_again:
 			rcu_read_lock();
 			spin_lock_bh(&ab->base_lock);
 			peer = ath12k_peer_find_by_id(ab, rxcb->peer_id);
-			if (peer && peer->sta)
-				arsta =
-				(struct ath12k_sta *)peer->sta->drv_priv;
+			if (peer && peer->sta) {
+				ahsta = (struct ath12k_sta *)peer->sta->drv_priv;
+				arsta = &ahsta->deflink;
+			}
 			spin_unlock_bh(&ab->base_lock);
 			if (arsta)
 				atomic_inc(&arsta->drv_rx_pkts.pkts_frm_hw);
@@ -3970,7 +3979,8 @@ static int ath12k_dp_rx_h_null_q_desc(st
 	struct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);
 	u32 hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;
 	bool fast_rx;
-	struct ath12k_sta *arsta = NULL;
+	struct ath12k_sta *ahsta = NULL;
+	struct ath12k_link_sta *arsta = NULL;
 	struct ath12k_peer *peer = NULL;
 
 	msdu_len = ath12k_dp_rx_h_msdu_len(ab, desc);
@@ -4038,8 +4048,10 @@ static int ath12k_dp_rx_h_null_q_desc(st
 		spin_lock_bh(&ar->ab->base_lock);
 		if (peer_id)
 			peer = ath12k_peer_find_by_id(ar->ab, rxcb->peer_id);
-		if (peer && peer->sta)
-			arsta = (struct ath12k_sta *)peer->sta->drv_priv;
+		if (peer && peer->sta) {
+			ahsta = (struct ath12k_sta *)peer->sta->drv_priv;
+			arsta = &ahsta->deflink;
+		}
 		spin_unlock_bh(&ar->ab->base_lock);
 		if (arsta)
 			atomic_inc(&arsta->drv_rx_pkts.pkts_frm_hw);
--- a/drivers/net/wireless/ath/ath12k/dp_rx.h
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.h
@@ -88,7 +88,7 @@ int ath12k_dp_rx_ampdu_start(struct ath1
 			     struct ieee80211_ampdu_params *params);
 int ath12k_dp_rx_ampdu_stop(struct ath12k *ar,
 			    struct ieee80211_ampdu_params *params);
-int ath12k_dp_rx_peer_pn_replay_config(struct ath12k_vif *arvif,
+int ath12k_dp_rx_peer_pn_replay_config(struct ath12k_link_vif *arvif,
 				       const u8 *peer_addr,
 				       enum set_key_cmd key_cmd,
 				       struct ieee80211_key_conf *key);
--- a/drivers/net/wireless/ath/ath12k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.c
@@ -13,7 +13,7 @@
 #include <linux/dma-mapping.h>
 
 static enum hal_tcl_encap_type
-ath12k_dp_tx_get_encap_type(struct ath12k_vif *arvif, struct sk_buff *skb)
+ath12k_dp_tx_get_encap_type(struct ath12k_link_vif *arvif, struct sk_buff *skb)
 {
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
 	struct ath12k_base *ab = arvif->ar->ab;
@@ -117,9 +117,10 @@ static void ath12k_hal_tx_cmd_ext_desc_s
 						HAL_TX_MSDU_EXT_INFO1_ENCRYPT_TYPE);
 }
 
-int ath12k_dp_tx(struct ath12k *ar, struct ath12k_vif *arvif,
-		 struct ath12k_sta *arsta, struct sk_buff *skb)
+int ath12k_dp_tx(struct ath12k *ar, struct ath12k_link_vif *arvif,
+		 struct ath12k_sta *ahsta, struct sk_buff *skb)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k_base *ab = ar->ab;
 	struct ath12k_dp *dp = &ab->dp;
 	struct hal_tx_info ti = {0};
@@ -177,9 +178,10 @@ tcl_ring_sel:
 	ti.bank_id = arvif->bank_id;
 
 	if (ieee80211_has_a4(hdr->frame_control) &&
-	    is_multicast_ether_addr(hdr->addr3) && arsta &&
-	    arsta->use_4addr_set) {
-		ti.meta_data_flags = arsta->tcl_metadata;
+	    is_multicast_ether_addr(hdr->addr3) && ahsta &&
+	    ahsta->use_4addr_set) {
+		/* TODO set tcl metadata based on primary link sta ? */
+		ti.meta_data_flags = ahsta->deflink.tcl_metadata;
 		ti.flags0 |= FIELD_PREP(HAL_TCL_DATA_CMD_INFO2_TO_FW, 1);
 	} else {
 		ti.meta_data_flags = arvif->tcl_metadata;
@@ -234,8 +236,8 @@ tcl_ring_sel:
 		goto fail_remove_tx_buf;
 	}
 
-	if (unlikely((arvif->tx_encap_type == HAL_TCL_ENCAP_TYPE_ETHERNET &&
-	    !(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)))) {
+	if (unlikely((ahvif->tx_encap_type == HAL_TCL_ENCAP_TYPE_ETHERNET &&
+	     !(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)))) {
 		msdu_ext_desc = true;
 
 		if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
@@ -244,7 +246,7 @@ tcl_ring_sel:
 		}
 	}
 
-	if (unlikely(arvif->tx_encap_type == HAL_TCL_ENCAP_TYPE_RAW)) {
+	if (unlikely(ahvif->tx_encap_type == HAL_TCL_ENCAP_TYPE_RAW)) {
 		if (skb->protocol == cpu_to_be16(ETH_P_ARP)) {
 			ti.encap_type = HAL_TCL_ENCAP_TYPE_RAW;
 			ti.encrypt_type = HAL_ENCRYPT_TYPE_OPEN;
@@ -267,7 +269,7 @@ tcl_ring_sel:
 	ti.desc_id = tx_desc->desc_id;
 	ti.data_len = skb->len;
 	skb_cb->paddr = ti.paddr;
-	skb_cb->vif = arvif->vif;
+	skb_cb->vif = ahvif->vif;
 	skb_cb->ar = ar;
 
 	if (unlikely(msdu_ext_desc)) {
@@ -523,7 +525,8 @@ void ath12k_dp_tx_update_txcompl(struct
 	enum hal_tx_rate_stats_sgi sgi;
 	enum hal_tx_rate_stats_bw bw;
 	struct ath12k_peer *peer;
-	struct ath12k_sta *arsta;
+	struct ath12k_sta *ahsta;
+	struct ath12k_link_sta *arsta;
 	struct ieee80211_sta *sta;
 	u16 rate, ru_tones;
 	u8 mcs, rate_idx, ofdma;
@@ -537,8 +540,10 @@ void ath12k_dp_tx_update_txcompl(struct
 		goto err_out;
 	}
 
+	/* TODO move to per link stats */
 	sta = peer->sta;
-	arsta = (struct ath12k_sta *)sta->drv_priv;
+	ahsta = (struct ath12k_sta *)sta->drv_priv;
+	arsta = &ahsta->deflink;
 
 	memset(&arsta->txrate, 0, sizeof(arsta->txrate));
 	pkt_type = FIELD_GET(HAL_TX_RATE_STATS_INFO0_PKT_TYPE,
@@ -662,7 +667,8 @@ static void ath12k_dp_tx_complete_msdu(s
 	struct ieee80211_tx_info *info;
 	struct ath12k_skb_cb *skb_cb;
 	struct ath12k_peer *peer;
-	struct ath12k_sta *arsta;
+	struct ath12k_sta *ahsta;
+	struct ath12k_link_sta *arsta;
 	struct rate_info rate;
 	struct hal_tx_status ts = { 0 };
 	enum hal_wbm_tqm_rel_reason rel_status;
@@ -777,7 +783,8 @@ static void ath12k_dp_tx_complete_msdu(s
 		 return;
 	}
 
-	arsta = (struct ath12k_sta *)peer->sta->drv_priv;
+	ahsta = (struct ath12k_sta *)peer->sta->drv_priv;
+	arsta = &ahsta->deflink;
 	status.sta = peer->sta;
 	status.skb = msdu;
 	status.info = info;
--- a/drivers/net/wireless/ath/ath12k/dp_tx.h
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.h
@@ -17,8 +17,8 @@ struct ath12k_dp_htt_wbm_tx_status {
 
 void ath12k_dp_tx_update_txcompl(struct ath12k *ar, struct hal_tx_status *ts);
 int ath12k_dp_tx_htt_h2t_ver_req_msg(struct ath12k_base *ab);
-int ath12k_dp_tx(struct ath12k *ar, struct ath12k_vif *arvif,
-		 struct ath12k_sta *arsta, struct sk_buff *skb);
+int ath12k_dp_tx(struct ath12k *ar, struct ath12k_link_vif *arvif,
+		 struct ath12k_sta *ahsta, struct sk_buff *skb);
 void ath12k_dp_tx_completion_handler(struct ath12k_base *ab, int ring_id);
 
 int ath12k_dp_tx_htt_h2t_ppdu_stats_req(struct ath12k *ar, u32 mask);
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -247,9 +247,11 @@ static const u32 ath12k_smps_map[] = {
 	[WLAN_HT_CAP_SM_PS_DISABLED] = WMI_PEER_SMPS_PS_NONE,
 };
 
-static int ath12k_mac_vdev_create(struct ath12k *ar, struct ieee80211_vif *vif);
+static int ath12k_mac_vdev_create(struct ath12k *ar, struct ath12k_link_vif *arvif);
 static int ath12k_start_vdev_delay(struct ath12k *ar,
 				   struct ieee80211_vif *vif);
+static void ath12k_update_bcn_template_work(struct work_struct *work);
+static void ath12k_update_obss_color_notify_work(struct work_struct *work);
 
 enum nl80211_he_ru_alloc ath12k_mac_phy_he_ru_to_nl80211_he_ru_alloc(u16 ru_phy)
 {
@@ -514,12 +516,22 @@ static u8 ath12k_parse_mpdudensity(u8 mp
 }
 
 static int ath12k_mac_vif_chan(struct ieee80211_vif *vif,
-			       struct cfg80211_chan_def *def)
-{
+			       struct cfg80211_chan_def *def,
+			       u8 link_id)
+ {
+	struct ieee80211_bss_conf *link_conf;
 	struct ieee80211_chanctx_conf *conf;
 
 	rcu_read_lock();
-	conf = rcu_dereference(vif->bss_conf.chanctx_conf);
+	
+	link_conf = rcu_dereference(vif->link_conf[link_id]);
+
+	if (!link_conf) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+
+	conf = rcu_dereference(link_conf->chanctx_conf);
 	if (!conf) {
 		rcu_read_unlock();
 		return -ENOENT;
@@ -576,14 +588,32 @@ static void ath12k_get_arvif_iter(void *
 				  struct ieee80211_vif *vif)
 {
 	struct ath12k_vif_iter *arvif_iter = data;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
+	u16 links_map;
+	u8 link_id;
 
-	if ((arvif->vdev_id == arvif_iter->vdev_id) &&
-	    (arvif->ar == arvif_iter->ar))
-		arvif_iter->arvif = arvif;
+	/* TODO Revisit lock usage for ahvif->link. Currently this is
+	 * used with vif protected by rcu lock and since the ahvif->links_map
+	 * or link wont be modified it is safe to access below without its mutex
+	 */
+	links_map = ahvif->links_map;
+
+	for_each_set_bit(link_id, &links_map, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arvif = ahvif->link[link_id];
+
+		if (WARN_ON(arvif == NULL))
+			continue;
+
+		if ((arvif->vdev_id == arvif_iter->vdev_id) &&
+		    (arvif->ar == arvif_iter->ar)) {
+			arvif_iter->arvif = arvif;
+			break;
+		}
+	}
 }
 
-struct ath12k_vif *ath12k_mac_get_arvif(struct ath12k *ar, u32 vdev_id)
+struct ath12k_link_vif *ath12k_mac_get_arvif(struct ath12k *ar, u32 vdev_id)
 {
 	struct ath12k_vif_iter arvif_iter;
 	u32 flags;
@@ -605,12 +635,12 @@ struct ath12k_vif *ath12k_mac_get_arvif(
 	return arvif_iter.arvif;
 }
 
-struct ath12k_vif *ath12k_mac_get_arvif_by_vdev_id(struct ath12k_base *ab,
+struct ath12k_link_vif *ath12k_mac_get_arvif_by_vdev_id(struct ath12k_base *ab,
 						   u32 vdev_id)
 {
 	int i;
 	struct ath12k_pdev *pdev;
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 
 	for (i = 0; i < ab->num_radios; i++) {
 		pdev = rcu_dereference(ab->pdevs_active[i]);
@@ -652,9 +682,11 @@ static struct ath12k *ath12k_get_ar_by_c
 	return ath12k_mac_get_ar_by_band(hw, ctx->def.chan->band);
 }
 
-struct ath12k *ath12k_get_ar_by_vif(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+struct ath12k *ath12k_get_ar_by_vif(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+				    u8 link_id)
 {
-	struct ath12k_vif *arvif;
+	struct ath12k_vif *ahvif;
+	struct ath12k_link_vif *arvif;
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar = NULL;
 
@@ -663,9 +695,14 @@ struct ath12k *ath12k_get_ar_by_vif(stru
 	if (!vif)
 		return NULL;
 
-	arvif = ath12k_vif_to_arvif(vif);
+	ahvif = ath12k_vif_to_ahvif(vif);
 
-	if (arvif->is_created)
+	if (!(ahvif->links_map & BIT(link_id)))
+		return NULL;
+
+	arvif = ahvif->link[link_id];
+
+	if (arvif && arvif->is_created)
 		ar = arvif->ar;
 
 	return ar;
@@ -734,7 +771,7 @@ static void ath12k_pdev_caps_update(stru
 static int ath12k_mac_txpower_recalc(struct ath12k *ar)
 {
 	struct ath12k_pdev *pdev = ar->pdev;
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	int ret, txpower = -1;
 	u32 param;
 
@@ -788,7 +825,7 @@ fail:
 	return ret;
 }
 
-static int ath12k_recalc_rtscts_prot(struct ath12k_vif *arvif)
+static int ath12k_recalc_rtscts_prot(struct ath12k_link_vif *arvif)
 {
 	struct ath12k *ar = arvif->ar;
 	u32 vdev_param, rts_cts = 0;
@@ -827,7 +864,7 @@ static int ath12k_recalc_rtscts_prot(str
 	return ret;
 }
 
-static int ath12k_mac_set_kickout(struct ath12k_vif *arvif)
+static int ath12k_mac_set_kickout(struct ath12k_link_vif *arvif)
 {
 	struct ath12k *ar = arvif->ar;
 	u32 param;
@@ -1257,10 +1294,11 @@ out:
 	return ret;
 }
 
-static void ath12k_mac_setup_bcn_tmpl_vif_params(struct ath12k_vif *arvif,
+static void ath12k_mac_setup_bcn_tmpl_vif_params(struct ath12k_link_vif *arvif,
 						 struct sk_buff *bcn)
 {
 	struct ieee80211_mgmt *mgmt;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ieee80211_vht_cap *vht_cap;
 	u8 *ies;
 	const u8 *vht_cap_ie;
@@ -1269,25 +1307,31 @@ static void ath12k_mac_setup_bcn_tmpl_vi
 	mgmt = (struct ieee80211_mgmt *)bcn->data;
 	ies += sizeof(mgmt->u.beacon);
 
-	if (cfg80211_find_ie(WLAN_EID_RSN, ies, (skb_tail_pointer(bcn) - ies)))
-		arvif->rsnie_present = true;
+	/* avoid ie parsing if already done for this ahvif */
+	if (!ahvif->rsnie_present &&
+	    cfg80211_find_ie(WLAN_EID_RSN, ies, (skb_tail_pointer(bcn) - ies)))
+		ahvif->rsnie_present = true;
+
 	vht_cap_ie = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, ies, (skb_tail_pointer(bcn) - ies));
 	if (vht_cap_ie && vht_cap_ie[1] >= sizeof(*vht_cap)) {
 		vht_cap = (void *)(vht_cap_ie + 2);
 		arvif->vht_cap = vht_cap->vht_cap_info;
 	}
 
-	if (cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,
+	/* avoid ie parsing if already done for this ahvif */
+	if (!ahvif->wpaie_present &&
+	    cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,
 				    WLAN_OUI_TYPE_MICROSOFT_WPA,
 				    ies, (skb_tail_pointer(bcn) - ies)))
-		arvif->wpaie_present = true;
+		ahvif->wpaie_present = true;
 }
 
 
-static bool ath12k_mac_setup_bcn_tmpl_nontx_vif_params(struct ath12k_vif *tx_arvif,
-						       struct ath12k_vif *arvif,
+static bool ath12k_mac_setup_bcn_tmpl_nontx_vif_params(struct ath12k_link_vif *tx_arvif,
+						       struct ath12k_link_vif *arvif,
 						       struct sk_buff *bcn)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ieee80211_mgmt *mgmt;
 	const u8 *ies, *profile, *next_profile;
 	int ies_len;
@@ -1295,7 +1339,7 @@ static bool ath12k_mac_setup_bcn_tmpl_no
 	if (arvif == tx_arvif)
 		return true;
 
-	arvif->rsnie_present = tx_arvif->rsnie_present;
+	ahvif->rsnie_present = ahvif->rsnie_present;
 
 	ies = bcn->data + ieee80211_get_hdrlen_from_skb(bcn);
 	ies += sizeof(mgmt->u.beacon);
@@ -1322,14 +1366,14 @@ static bool ath12k_mac_setup_bcn_tmpl_no
 			profile += (2 + profile[1]); /* nontx capabilities */
 			profile_len -= (2 + profile[1]);
 			profile += (2 + profile[1]); /* SSID */
-			if (profile[2] == arvif->vif->bss_conf.bssid_index) {
+			if (profile[2] == ahvif->vif->bss_conf.bssid_index) {
 				profile_len -= 5;
 				profile = profile + 5;
 
 				if (cfg80211_find_ie(WLAN_EID_RSN, profile,
 						     profile_len))
-					arvif->rsnie_present = true;
-				else if (tx_arvif->rsnie_present) {
+					ahvif->rsnie_present = true;
+				else if (ahvif->rsnie_present) {
 					nie = cfg80211_find_ext_ie(WLAN_EID_EXT_NON_INHERITANCE,
 								   profile,
 								   profile_len);
@@ -1341,7 +1385,7 @@ static bool ath12k_mac_setup_bcn_tmpl_no
 						for (i = 0; i < nie_len; i++) {
 							if (nie[i] ==
 								WLAN_EID_RSN) {
-								arvif->rsnie_present = false;
+								ahvif->rsnie_present = false;
 								break;
 							}
 						}
@@ -1358,7 +1402,7 @@ static bool ath12k_mac_setup_bcn_tmpl_no
 	return false;
 }
 
-static int __ath12k_mac_setup_bcn_tmpl(struct ath12k_vif *arvif,
+static int __ath12k_mac_setup_bcn_tmpl(struct ath12k_link_vif *arvif,
 				       struct sk_buff *bcn,
 				       struct ieee80211_mutable_offsets offs,
 				       int ema_idx, int ema_cnt)
@@ -1378,20 +1422,25 @@ static int __ath12k_mac_setup_bcn_tmpl(s
 	return ath12k_wmi_bcn_tmpl(ar, arvif->vdev_id, &offs, bcn, ema_param);
 }
 
-static int ath12k_mac_setup_bcn_tmpl_ema(struct ath12k_vif *arvif)
+static int ath12k_mac_setup_bcn_tmpl_ema(struct ath12k_link_vif *arvif)
 {
-	struct ath12k_vif *tx_arvif;
+	struct ath12k_link_vif *tx_arvif;
+	struct ath12k_vif *tx_ahvif, *ahvif = arvif->ahvif;
 	struct ieee80211_ema_beacons *beacons;
 	u8 i = 0;
 	int ret = 0;
 	bool found_vdev = false;
 
-	if (!arvif->vif->mbssid_tx_vif)
+	if (!ahvif->vif->mbssid_tx_vif)
 		return -1;
 
-	tx_arvif = (void *)arvif->vif->mbssid_tx_vif->drv_priv;
+	/* FIXME there could be multiple tx link vifs, so this basically
+	 * requires change for MLO
+	 */
+	tx_ahvif = (void *) ahvif->vif->mbssid_tx_vif->drv_priv;
+	tx_arvif = &tx_ahvif->deflink;
 	beacons = ieee80211_beacon_get_template_ema_list(tx_arvif->ar->ah->hw,
-							 tx_arvif->vif, 0);
+							 tx_ahvif->vif, 0);
 	if (!beacons || !beacons->cnt) {
 		ath12k_warn(arvif->ar->ab,
 			    "failed to get ema beacon templates from mac80211\n");
@@ -1403,7 +1452,7 @@ static int ath12k_mac_setup_bcn_tmpl_ema
 						     beacons->bcn[0].skb);
 		found_vdev = true;
 	} else {
-		arvif->wpaie_present= tx_arvif->wpaie_present;
+		ahvif->wpaie_present = ahvif->wpaie_present;
 	}
 
 	for (i = 0; i < beacons->cnt; i++) {
@@ -1428,17 +1477,24 @@ static int ath12k_mac_setup_bcn_tmpl_ema
 	return ret;
 }
 
-static int ath12k_mac_setup_bcn_tmpl_non_ema(struct ath12k_vif *arvif)
+static int ath12k_mac_setup_bcn_tmpl_non_ema(struct ath12k_link_vif *arvif)
 {
-	struct ath12k_vif *tx_arvif = arvif;
+	struct ath12k_link_vif *tx_arvif = arvif;
+	struct ath12k_vif *tx_ahvif = arvif->ahvif;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ieee80211_mutable_offsets offs = {};
 	struct sk_buff *bcn;
 	int ret;
 
-	if (arvif->vif->mbssid_tx_vif)
-		tx_arvif = (void *)arvif->vif->mbssid_tx_vif->drv_priv;
+	/* FIXME there could be multiple tx link vifs, so this basically
+	 * requires change for MLO
+	 */
+	if (ahvif->vif->mbssid_tx_vif) {
+		tx_ahvif = (void *) ahvif->vif->mbssid_tx_vif->drv_priv;
+		tx_arvif = &tx_ahvif->deflink;
+	}
 
-	bcn = ieee80211_beacon_get_template(tx_arvif->ar->ah->hw, tx_arvif->vif,
+	bcn = ieee80211_beacon_get_template(tx_arvif->ar->ah->hw, ahvif->vif,
 					    &offs, 0);
 	if (!bcn) {
 		ath12k_warn(arvif->ar->ab,
@@ -1463,15 +1519,19 @@ static int ath12k_mac_setup_bcn_tmpl_non
 	return ret;
 }
 
-static int ath12k_mac_setup_bcn_tmpl(struct ath12k_vif *arvif)
+static int ath12k_mac_setup_bcn_tmpl(struct ath12k_link_vif *arvif)
 {
-	struct ieee80211_vif *vif = arvif->vif;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
 
-	if (arvif->vdev_type != WMI_VDEV_TYPE_AP)
+	if (ahvif->vdev_type != WMI_VDEV_TYPE_AP)
 		return 0;
 
+	/* FIXME there could be multiple tx link vifs, so this basically
+	 * requires change for MLO. For simpler case mbssid_tx_vif is NULL
+	 */
 	if (vif->mbssid_tx_vif &&
-	    arvif != (void *)vif->mbssid_tx_vif->drv_priv &&
+	    ahvif != (void *)vif->mbssid_tx_vif->drv_priv &&
 	    arvif->is_up)
 		return 0;
 
@@ -1482,9 +1542,9 @@ static int ath12k_mac_setup_bcn_tmpl(str
 }
 
 
-void ath12k_mac_bcn_tx_event(struct ath12k_vif *arvif)
+void ath12k_mac_bcn_tx_event(struct ath12k_link_vif *arvif)
 {
-	struct ieee80211_vif *vif = arvif->vif;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct ath12k *ar = arvif->ar;
 
 	if (!vif->bss_conf.color_change_active && !arvif->bcca_zero_sent)
@@ -1503,16 +1563,23 @@ void ath12k_mac_bcn_tx_event(struct ath1
 	ieee80211_queue_work(ar->ah->hw, &arvif->update_bcn_template_work);
 }
 
-static void ath12k_control_beaconing(struct ath12k_vif *arvif,
+static void ath12k_control_beaconing(struct ath12k_link_vif *arvif,
 				     struct ieee80211_bss_conf *info)
 {
 	struct ath12k *ar = arvif->ar;
-	struct ath12k_vif *tx_arvif = NULL;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k_vif *tx_ahvif = NULL;
+	struct ath12k_link_vif *tx_arvif = NULL;
 	int ret = 0;
 	struct vdev_up_params params = { 0 };
 
-	if (arvif->vif->mbssid_tx_vif)
-		tx_arvif = (void *)arvif->vif->mbssid_tx_vif->drv_priv;
+	/* FIXME there could be multiple tx link vifs, so this basically
+	 * requires change for MLO. For Non MLO no change in behavior
+	 */
+	if (ahvif->vif->mbssid_tx_vif) {
+		tx_ahvif = (void *) ahvif->vif->mbssid_tx_vif->drv_priv;
+		tx_arvif = &tx_ahvif->deflink;
+	}
 
 	lockdep_assert_held(&arvif->ar->conf_mutex);
 
@@ -1539,12 +1606,12 @@ static void ath12k_control_beaconing(str
 
 	arvif->tx_seq_no = 0x1000;
 
-	arvif->aid = 0;
+	ahvif->aid = 0;
 
 	ether_addr_copy(arvif->bssid, info->bssid);
 
 	params.vdev_id = arvif->vdev_id;
-	params.aid = arvif->aid;
+	params.aid = ahvif->aid;
 	params.bssid = arvif->bssid;
 	if (tx_arvif) {
 		params.tx_bssid = tx_arvif->bssid;
@@ -1566,12 +1633,16 @@ static void ath12k_control_beaconing(str
 }
 
 static void ath12k_peer_assoc_h_basic(struct ath12k *ar,
-				      struct ieee80211_vif *vif,
-				      struct ieee80211_sta *sta,
+				      struct ath12k_link_vif *arvif,
+				      struct ath12k_link_sta *arsta,
 				      struct peer_assoc_params *arg)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	u32 aid;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -1591,30 +1662,36 @@ static void ath12k_peer_assoc_h_basic(st
 }
 
 static void ath12k_peer_assoc_h_crypto(struct ath12k *ar,
-				       struct ieee80211_vif *vif,
-				       struct ieee80211_sta *sta,
+				       struct ath12k_link_vif *arvif,
+				       struct ath12k_link_sta *arsta,
 				       struct peer_assoc_params *arg)
 {
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct ieee80211_bss_conf *info = &vif->bss_conf;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct cfg80211_chan_def def;
 	struct cfg80211_bss *bss;
-	struct ath12k_vif *arvif = (struct ath12k_vif *)vif->drv_priv;
 	const u8 *rsnie = NULL;
 	const u8 *wpaie = NULL;
 	struct ieee80211_hw *hw;
+	u8 link_id = arvif->link_id;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return;
 
 	hw = ar->ah->hw;
 	bss = cfg80211_get_bss(hw->wiphy, def.chan, info->bssid, NULL, 0,
 			       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
 
-	if (arvif->rsnie_present || arvif->wpaie_present) {
+	if (ahvif->rsnie_present || ahvif->wpaie_present) {
 		arg->need_ptk_4_way = true;
-		if (arvif->wpaie_present)
+		if (ahvif->wpaie_present)
 			arg->need_gtk_2_way = true;
 	} else if (bss) {
 		const struct cfg80211_bss_ies *ies;
@@ -1654,11 +1731,11 @@ static void ath12k_peer_assoc_h_crypto(s
 }
 
 static void ath12k_peer_assoc_h_rates(struct ath12k *ar,
-				      struct ieee80211_vif *vif,
-				      struct ieee80211_sta *sta,
+				      struct ath12k_link_vif *arvif,
+				      struct ath12k_link_sta *arsta,
 				      struct peer_assoc_params *arg)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct wmi_rate_set_arg *rateset = &arg->peer_legacy_rates;
 	struct cfg80211_chan_def def;
 	const struct ieee80211_supported_band *sband;
@@ -1667,10 +1744,15 @@ static void ath12k_peer_assoc_h_rates(st
 	u32 ratemask;
 	u8 rate;
 	int i;
+	u8 link_id = arvif->link_id;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return;
 
 	band = def.chan->band;
@@ -1716,22 +1798,28 @@ ath12k_peer_assoc_h_vht_masked(const u16
 }
 
 static void ath12k_peer_assoc_h_ht(struct ath12k *ar,
-				   struct ieee80211_vif *vif,
-				   struct ieee80211_sta *sta,
+				   struct ath12k_link_vif *arvif,
+				   struct ath12k_link_sta *arsta,
 				   struct peer_assoc_params *arg)
 {
-	const struct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	const struct ieee80211_sta_ht_cap *ht_cap;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct cfg80211_chan_def def;
 	enum nl80211_band band;
 	const u8 *ht_mcs_mask;
 	int i, n;
 	u8 max_nss;
 	u32 stbc;
+	u8 link_id = arvif->link_id;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+	ht_cap = &sta->deflink.ht_cap;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return;
 
 	if (!ht_cap->ht_supported)
@@ -1912,12 +2000,12 @@ static u8 ath12k_get_nss_160mhz(struct a
 }
 
 static void ath12k_peer_assoc_h_vht(struct ath12k *ar,
-				    struct ieee80211_vif *vif,
-				    struct ieee80211_sta *sta,
+				    struct ath12k_link_vif *arvif,
+				    struct ath12k_link_sta *arsta,
 				    struct peer_assoc_params *arg)
 {
-	const struct ieee80211_sta_vht_cap *vht_cap = &sta->deflink.vht_cap;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	const struct ieee80211_sta_vht_cap *vht_cap;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct cfg80211_chan_def def;
 	enum nl80211_band band;
 	u16 *vht_mcs_mask;
@@ -1927,8 +2015,14 @@ static void ath12k_peer_assoc_h_vht(stru
 	int i, vht_nss, nss_idx;
 	bool user_rate_valid = true;
 	u32 rx_nss, tx_nss, nss_160;
+	u8 link_id = arvif->link_id;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	vht_cap = &sta->deflink.vht_cap;
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return;
 
 	if (!vht_cap->vht_supported)
@@ -2114,13 +2208,13 @@ ath12k_peer_assoc_h_he_masked(const u16
 
 
 static void ath12k_peer_assoc_h_he(struct ath12k *ar,
-				   struct ieee80211_vif *vif,
-				   struct ieee80211_sta *sta,
+				   struct ath12k_link_vif *arvif,
+				   struct ath12k_link_sta *arsta,
 				   struct peer_assoc_params *arg)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct cfg80211_chan_def def;
-	const struct ieee80211_sta_he_cap *he_cap = &sta->deflink.he_cap;
+	const struct ieee80211_sta_he_cap *he_cap;
 	int i;
 	u8 ampdu_factor, rx_mcs_80, rx_mcs_160, max_nss;
 	u16 mcs_160_map, mcs_80_map;
@@ -2132,8 +2226,14 @@ static void ath12k_peer_assoc_h_he(struc
 	int he_nss, nss_idx;
 	bool user_rate_valid = true;
 	u32 rx_nss, tx_nss, nss_160;
+	u8 link_id = arvif->link_id;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+	he_cap = &sta->deflink.he_cap;
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return;
 
 	if (!he_cap->has_he)
@@ -2354,16 +2454,23 @@ static void ath12k_peer_assoc_h_he(struc
 }
 
 static void ath12k_peer_assoc_h_he_6ghz(struct ath12k *ar,
-					struct ieee80211_vif *vif,
-					struct ieee80211_sta *sta,
+				        struct ath12k_link_vif *arvif,
+				        struct ath12k_link_sta *arsta,
 					struct peer_assoc_params *arg)
 {
-	const struct ieee80211_sta_he_cap *he_cap = &sta->deflink.he_cap;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
+	const struct ieee80211_sta_he_cap *he_cap;
 	struct cfg80211_chan_def def;
 	enum nl80211_band band;
 	u8  ampdu_factor;
+	u8 link_id = arvif->link_id;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+	he_cap = &sta->deflink.he_cap;
+ 
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return;
 
 	band = def.chan->band;
@@ -2532,25 +2639,32 @@ ath12k_peer_assoc_h_eht_masked(const u16
 }
 
 static void ath12k_peer_assoc_h_eht(struct ath12k *ar,
-				    struct ieee80211_vif *vif,
-				    struct ieee80211_sta *sta,
+				    struct ath12k_link_vif *arvif,
+				    struct ath12k_link_sta *arsta,
 				    struct peer_assoc_params *arg)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct cfg80211_chan_def def;
-	const struct ieee80211_sta_eht_cap *eht_cap = &sta->deflink.eht_cap;
-	const struct ieee80211_eht_mcs_nss_supp *mcs_nss =
-						&eht_cap->eht_mcs_nss_supp;
-	const struct ieee80211_eht_mcs_nss_supp_bw *mcs_nss_supp_bw =
-							&mcs_nss->bw._80;
+	const struct ieee80211_sta_eht_cap *eht_cap;
+	const struct ieee80211_eht_mcs_nss_supp *mcs_nss;
+	const struct ieee80211_eht_mcs_nss_supp_bw *mcs_nss_supp_bw;
 	u8 mcs_idx = WMI_EHTCAP_TXRX_MCS_NSS_IDX_80;
 	enum nl80211_band band;
 	u16 *eht_mcs_mask;
 	u8 max_nss;
 	int eht_nss, nss_idx;
 	bool user_rate_valid = true;
+	u8 link_id = arvif->link_id;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	eht_cap = &sta->deflink.eht_cap;
+	mcs_nss = &eht_cap->eht_mcs_nss_supp;
+	mcs_nss_supp_bw = &mcs_nss->bw._80;
+
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return;
 
 	band = def.chan->band;
@@ -2671,11 +2785,16 @@ static void ath12k_peer_assoc_h_eht(stru
 		   sta->deflink.addr, arg->peer_nss, arg->peer_he_mcs_count, arg->ru_punct_bitmap);
 }
 
-static void ath12k_peer_assoc_h_smps(struct ieee80211_sta *sta,
+static void ath12k_peer_assoc_h_smps(struct ath12k_link_sta *arsta,
 				     struct peer_assoc_params *arg)
 {
-	const struct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;
+	const struct ieee80211_sta_ht_cap *ht_cap;
 	int smps;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+	ht_cap = &sta->deflink.ht_cap;
 
 	if (!ht_cap->ht_supported && !sta->deflink.he_6ghz_capa.capa)
 		return;
@@ -2704,13 +2823,17 @@ static void ath12k_peer_assoc_h_smps(str
 }
 
 static void ath12k_peer_assoc_h_qos(struct ath12k *ar,
-				    struct ieee80211_vif *vif,
-				    struct ieee80211_sta *sta,
+				    struct ath12k_link_vif *arvif,
+				    struct ath12k_link_sta *arsta,
 				    struct peer_assoc_params *arg)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
-	switch (arvif->vdev_type) {
+	switch (ahvif->vdev_type) {
 	case WMI_VDEV_TYPE_AP:
 		if (sta->wme) {
 			/* TODO: Check WME vs QoS */
@@ -2740,13 +2863,17 @@ static void ath12k_peer_assoc_h_qos(stru
 }
 
 static int ath12k_peer_assoc_qos_ap(struct ath12k *ar,
-				    struct ath12k_vif *arvif,
-				    struct ieee80211_sta *sta)
+				    struct ath12k_link_vif *arvif,
+				    struct ath12k_link_sta *arsta)
 {
 	struct ap_ps_params params;
 	u32 max_sp;
 	u32 uapsd;
 	int ret;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -2806,15 +2933,23 @@ err:
 	return ret;
 }
 
-static bool ath12k_mac_sta_has_ofdm_only(struct ieee80211_sta *sta)
+static bool ath12k_mac_sta_has_ofdm_only(struct ath12k_link_sta *arsta)
 {
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 	return sta->deflink.supp_rates[NL80211_BAND_2GHZ] >>
-	       ATH12K_MAC_FIRST_OFDM_RATE_IDX;
+				ATH12K_MAC_FIRST_OFDM_RATE_IDX;
 }
 
 static enum wmi_phy_mode ath12k_mac_get_phymode_vht(struct ath12k *ar,
-						    struct ieee80211_sta *sta)
+						    struct ath12k_link_sta *arsta)
 {
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 	if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160) {
 		switch (sta->deflink.vht_cap.cap &
 			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {
@@ -2841,8 +2976,12 @@ static enum wmi_phy_mode ath12k_mac_get_
 }
 
 static enum wmi_phy_mode ath12k_mac_get_phymode_he(struct ath12k *ar,
-						   struct ieee80211_sta *sta)
+						   struct ath12k_link_sta *arsta)
 {
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 	if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160) {
 		if (sta->deflink.he_cap.he_cap_elem.phy_cap_info[0] &
 		     IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G)
@@ -2867,8 +3006,12 @@ static enum wmi_phy_mode ath12k_mac_get_
 }
 
 static enum wmi_phy_mode ath12k_mac_get_phymode_eht(struct ath12k *ar,
-						   struct ieee80211_sta *sta)
+						    struct ath12k_link_sta *arsta)
 {
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 	if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_320)
 		if (sta->deflink.eht_cap.eht_cap_elem.phy_cap_info[0] &
 		    IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ)
@@ -2897,11 +3040,11 @@ static enum wmi_phy_mode ath12k_mac_get_
 }
 
 static void ath12k_peer_assoc_h_phymode(struct ath12k *ar,
-					struct ieee80211_vif *vif,
-					struct ieee80211_sta *sta,
+				        struct ath12k_link_vif *arvif,
+				        struct ath12k_link_sta *arsta,
 					struct peer_assoc_params *arg)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct cfg80211_chan_def def;
 	enum nl80211_band band;
 	const u8 *ht_mcs_mask;
@@ -2909,8 +3052,13 @@ static void ath12k_peer_assoc_h_phymode(
 	const u16 *he_mcs_mask;
 	const u16 *eht_mcs_mask;
 	enum wmi_phy_mode phymode = MODE_UNKNOWN;
+	u8 link_id = arvif->link_id;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return;
 
 	band = def.chan->band;
@@ -2947,7 +3095,7 @@ static void ath12k_peer_assoc_h_phymode(
 				phymode = MODE_11NG_HT40;
 			else
 				phymode = MODE_11NG_HT20;
-		} else if (ath12k_mac_sta_has_ofdm_only(sta)) {
+		} else if (ath12k_mac_sta_has_ofdm_only(arsta)) {
 			phymode = MODE_11G;
 		} else {
 			phymode = MODE_11B;
@@ -2958,13 +3106,13 @@ static void ath12k_peer_assoc_h_phymode(
 		/* Check EHT first */
 		if (sta->deflink.eht_cap.has_eht &&
 		    !ath12k_peer_assoc_h_eht_masked(eht_mcs_mask)) {
-			phymode = ath12k_mac_get_phymode_eht(ar, sta);
+			phymode = ath12k_mac_get_phymode_eht(ar, arsta);
 		} else if (sta->deflink.he_cap.has_he &&
 			   !ath12k_peer_assoc_h_he_masked(he_mcs_mask)) {
-			phymode = ath12k_mac_get_phymode_he(ar, sta);
+			phymode = ath12k_mac_get_phymode_he(ar, arsta);
 		} else if (sta->deflink.vht_cap.vht_supported &&
 			   !ath12k_peer_assoc_h_vht_masked(vht_mcs_mask)) {
-			phymode = ath12k_mac_get_phymode_vht(ar, sta);
+			phymode = ath12k_mac_get_phymode_vht(ar, arsta);
 		} else if (sta->deflink.ht_cap.ht_supported &&
 			   !ath12k_peer_assoc_h_ht_masked(ht_mcs_mask)) {
 			if (sta->deflink.bandwidth >= IEEE80211_STA_RX_BW_40)
@@ -2987,40 +3135,37 @@ static void ath12k_peer_assoc_h_phymode(
 }
 
 static void ath12k_peer_assoc_prepare(struct ath12k *ar,
-				      struct ieee80211_vif *vif,
-				      struct ieee80211_sta *sta,
+				      struct ath12k_link_vif *arvif,
+				      struct ath12k_link_sta *arsta,
 				      struct peer_assoc_params *arg,
 				      bool reassoc)
 {
-	struct ath12k_sta *arsta;
-
 	lockdep_assert_held(&ar->conf_mutex);
 
-	arsta = (struct ath12k_sta *)sta->drv_priv;
-
 	memset(arg, 0, sizeof(*arg));
 
 	reinit_completion(&ar->peer_assoc_done);
 
 	arg->peer_new_assoc = !reassoc;
-	ath12k_peer_assoc_h_basic(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_crypto(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_rates(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_phymode(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_ht(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_vht(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_he(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_he_6ghz(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_eht(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_qos(ar, vif, sta, arg);
-	ath12k_peer_assoc_h_smps(sta, arg);
+	ath12k_peer_assoc_h_basic(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_crypto(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_rates(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_phymode(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_ht(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_vht(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_he(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_he_6ghz(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_eht(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_qos(ar, arvif, arsta, arg);
+	ath12k_peer_assoc_h_smps(arsta, arg);
 
 	arsta->peer_nss = arg->peer_nss;
 
 	/* TODO: amsdu_disable req? */
 }
 
-static int ath12k_setup_peer_smps(struct ath12k *ar, struct ath12k_vif *arvif,
+static int ath12k_setup_peer_smps(struct ath12k *ar,
+				  struct ath12k_link_vif *arvif,
 				  const u8 *addr,
 				  const struct ieee80211_sta_ht_cap *ht_cap,
 				  u16 he_6ghz_capa)
@@ -3045,31 +3190,32 @@ static int ath12k_setup_peer_smps(struct
 					 ath12k_smps_map[smps]);
 }
 
-static bool ath12k_mac_set_he_txbf_conf(struct ath12k_vif *arvif)
+static bool ath12k_mac_set_he_txbf_conf(struct ath12k_link_vif *arvif)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
 	u32 param = WMI_VDEV_PARAM_SET_HEMU_MODE;
 	u32 value = 0;
 	int ret;
 
-	if (!arvif->vif->bss_conf.he_support)
+	if (!ahvif->vif->bss_conf.he_support)
 		return true;
 
-	if (arvif->vif->bss_conf.he_su_beamformer) {
+	if (ahvif->vif->bss_conf.he_su_beamformer) {
 		value |= FIELD_PREP(HE_MODE_SU_TX_BFER, HE_SU_BFER_ENABLE);
-		if (arvif->vif->bss_conf.he_mu_beamformer &&
-		    arvif->vdev_type == WMI_VDEV_TYPE_AP)
+		if (ahvif->vif->bss_conf.he_mu_beamformer &&
+		    ahvif->vdev_type == WMI_VDEV_TYPE_AP)
 			value |= FIELD_PREP(HE_MODE_MU_TX_BFER, HE_MU_BFER_ENABLE);
 	}
 
-	if (arvif->vif->type != NL80211_IFTYPE_MESH_POINT) {
+	if (ahvif->vif->type != NL80211_IFTYPE_MESH_POINT) {
 		value |= FIELD_PREP(HE_MODE_DL_OFDMA, HE_DL_MUOFDMA_ENABLE) |
 			 FIELD_PREP(HE_MODE_UL_OFDMA, HE_UL_MUOFDMA_ENABLE);
 
-		if (arvif->vif->bss_conf.he_full_ul_mumimo)
+		if (ahvif->vif->bss_conf.he_full_ul_mumimo)
 			value |= FIELD_PREP(HE_MODE_UL_MUMIMO, HE_UL_MUMIMO_ENABLE);
 
-		if (arvif->vif->bss_conf.he_su_beamformee)
+		if (ahvif->vif->bss_conf.he_su_beamformee)
 			value |= FIELD_PREP(HE_MODE_SU_TX_BFEE, HE_SU_BFEE_ENABLE);
 	}
 
@@ -3096,16 +3242,17 @@ static bool ath12k_mac_set_he_txbf_conf(
 }
 
 static bool ath12k_mac_vif_recalc_sta_he_txbf(struct ath12k *ar,
-					      struct ieee80211_vif *vif,
+					      struct ath12k_link_vif *arvif,
 					      struct ieee80211_sta_he_cap *he_cap)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct ieee80211_he_cap_elem he_cap_elem = {0};
 	struct ieee80211_sta_he_cap *cap_band;
 	struct cfg80211_chan_def def;
 	u32 param = WMI_VDEV_PARAM_SET_HEMU_MODE;
 	u32 hemode = 0;
 	int ret;
+	u8 link_id = arvif->link_id;
 
 	if (!vif->bss_conf.he_support)
 		return true;
@@ -3113,7 +3260,7 @@ static bool ath12k_mac_vif_recalc_sta_he
 	if (vif->type != NL80211_IFTYPE_STATION)
 		return false;
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return false;
 
 	if (def.chan->band == NL80211_BAND_2GHZ)
@@ -3161,33 +3308,34 @@ static bool ath12k_mac_vif_recalc_sta_he
 	return true;
 }
 
-static bool ath12k_mac_set_eht_txbf_conf(struct ath12k_vif *arvif)
+static bool ath12k_mac_set_eht_txbf_conf(struct ath12k_link_vif *arvif)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
 	u32 param = WMI_VDEV_PARAM_SET_EHT_MU_MODE;
 	u32 value = 0;
 	int ret;
 
-	if (!arvif->vif->bss_conf.eht_support)
+	if (!ahvif->vif->bss_conf.eht_support)
 		return true;
 
-	if (arvif->vif->bss_conf.eht_su_beamformer) {
+	if (ahvif->vif->bss_conf.eht_su_beamformer) {
 		value |= FIELD_PREP(EHT_MODE_SU_TX_BFER, EHT_SU_BFER_ENABLE);
-		if (arvif->vif->bss_conf.eht_mu_beamformer &&
-		    arvif->vdev_type == WMI_VDEV_TYPE_AP)
+		if (ahvif->vif->bss_conf.eht_mu_beamformer &&
+		    ahvif->vdev_type == WMI_VDEV_TYPE_AP)
 			value |= FIELD_PREP(EHT_MODE_MU_TX_BFER, EHT_MU_BFER_ENABLE) |
 				 FIELD_PREP(EHT_MODE_DL_OFDMA_MUMIMO, EHT_DL_MUOFDMA_ENABLE) |
 				 FIELD_PREP(EHT_MODE_UL_OFDMA_MUMIMO, EHT_UL_MUOFDMA_ENABLE);
 	}
 
-	if (arvif->vif->type != NL80211_IFTYPE_MESH_POINT) {
+	if (ahvif->vif->type != NL80211_IFTYPE_MESH_POINT) {
 		value |= FIELD_PREP(EHT_MODE_DL_OFDMA, EHT_DL_MUOFDMA_ENABLE) |
 			 FIELD_PREP(EHT_MODE_UL_OFDMA, EHT_UL_MUOFDMA_ENABLE);
 
-		if (arvif->vif->bss_conf.eht_80mhz_full_bw_ul_mumimo)
+		if (ahvif->vif->bss_conf.eht_80mhz_full_bw_ul_mumimo)
 			value |= FIELD_PREP(EHT_MODE_MUMIMO, EHT_UL_MUMIMO_ENABLE);
 
-		if (arvif->vif->bss_conf.eht_su_beamformee)
+		if (ahvif->vif->bss_conf.eht_su_beamformee)
 			value |= FIELD_PREP(EHT_MODE_SU_TX_BFEE, EHT_SU_BFEE_ENABLE);
 	}
 
@@ -3202,12 +3350,15 @@ static bool ath12k_mac_set_eht_txbf_conf
 }
 
 static void ath12k_bss_assoc(struct ath12k *ar,
-			     struct ieee80211_vif *vif,
+			     struct ath12k_link_vif *arvif,
 			     struct ieee80211_bss_conf *bss_conf)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
 	struct peer_assoc_params peer_arg;
 	struct ieee80211_sta *ap_sta;
+	struct ath12k_link_sta *arsta;
+	struct ath12k_sta *ahsta;
 	struct ath12k_peer *peer;
 	struct ieee80211_sta_he_cap he_cap;
 	bool is_auth = false;
@@ -3216,8 +3367,11 @@ static void ath12k_bss_assoc(struct ath1
 
 	lockdep_assert_held(&ar->conf_mutex);
 
+	if (!arvif)
+		return;
+
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac vdev %i assoc bssid %pM aid %d\n",
-		   arvif->vdev_id, arvif->bssid, arvif->aid);
+		   arvif->vdev_id, arvif->bssid, ahvif->aid);
 
 	rcu_read_lock();
 
@@ -3228,10 +3382,14 @@ static void ath12k_bss_assoc(struct ath1
 		rcu_read_unlock();
 		return;
 	}
+
+	ahsta = (struct ath12k_sta *)ap_sta->drv_priv;
+	arsta = &ahsta->deflink;
+
 	/* he_cap here is updated at assoc success for sta mode only */
 	he_cap = ap_sta->deflink.he_cap;
 
-	ath12k_peer_assoc_prepare(ar, vif, ap_sta, &peer_arg, false);
+	ath12k_peer_assoc_prepare(ar, arvif, arsta, &peer_arg, false);
 
 	rcu_read_unlock();
 
@@ -3258,7 +3416,7 @@ static void ath12k_bss_assoc(struct ath1
 		return;
 	}
 
-	if (!ath12k_mac_vif_recalc_sta_he_txbf(ar, vif, &he_cap)) {
+	if (!ath12k_mac_vif_recalc_sta_he_txbf(ar, arvif, &he_cap)) {
 		ath12k_warn(ar->ab, "failed to recalc he txbf for vdev %i on bss %pM\n",
 			    arvif->vdev_id, bss_conf->bssid);
 		return;
@@ -3266,11 +3424,11 @@ static void ath12k_bss_assoc(struct ath1
 
 	WARN_ON(arvif->is_up);
 
-	arvif->aid = vif->cfg.aid;
+	ahvif->aid = vif->cfg.aid;
 	ether_addr_copy(arvif->bssid, bss_conf->bssid);
 
 	params.vdev_id = arvif->vdev_id;
-	params.aid = arvif->aid;
+	params.aid = ahvif->aid;
 	params.bssid = arvif->bssid;
 	ret = ath12k_wmi_vdev_up(ar, &params);
 	if (ret) {
@@ -3311,9 +3469,11 @@ static void ath12k_bss_assoc(struct ath1
 }
 
 static void ath12k_bss_disassoc(struct ath12k *ar,
-				struct ieee80211_vif *vif)
+				struct ath12k_link_vif *arvif)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv, *tx_arvif;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k_vif *tx_ahvif;
+	struct ath12k_link_vif *tx_arvif;
 	int ret;
 
 	lockdep_assert_held(&ar->conf_mutex);
@@ -3327,8 +3487,11 @@ static void ath12k_bss_disassoc(struct a
 			    arvif->vdev_id, ret);
 
 	arvif->is_up = false;
-	if (arvif->vif->mbssid_tx_vif) {
-		tx_arvif = (void *)arvif->vif->mbssid_tx_vif->drv_priv;
+
+	/* FIXME mbssid for MLO */
+	if (ahvif->vif->mbssid_tx_vif) {
+		tx_ahvif = (void *) ahvif->vif->mbssid_tx_vif->drv_priv;
+		tx_arvif = &tx_ahvif->deflink;
 		if (tx_arvif != arvif)
 			tx_arvif->nontransmitting_vif_count--;
 	}
@@ -3362,10 +3525,10 @@ static u32 ath12k_mac_get_rate_hw_value(
 }
 
 static void ath12k_recalculate_mgmt_rate(struct ath12k *ar,
-					 struct ieee80211_vif *vif,
-					 struct cfg80211_chan_def *def)
+					 struct ath12k_link_vif *arvif,
+					 struct cfg80211_chan_def *def,
+					 struct ieee80211_bss_conf *link_conf)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
 	const struct ieee80211_supported_band *sband;
 	u8 basic_rate_idx;
 	int hw_rate_code;
@@ -3376,7 +3539,7 @@ static void ath12k_recalculate_mgmt_rate
 	lockdep_assert_held(&ar->conf_mutex);
 
 	sband = ar->ah->hw->wiphy->bands[def->chan->band];
-	basic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;
+	basic_rate_idx = ffs(link_conf->basic_rates) - 1;
 	bitrate = sband->bitrates[basic_rate_idx].bitrate;
 
 	hw_rate_code = ath12k_mac_get_rate_hw_value(bitrate);
@@ -3398,9 +3561,10 @@ static void ath12k_recalculate_mgmt_rate
 		ath12k_warn(ar->ab, "failed to set beacon tx rate %d\n", ret);
 }
 
-static int ath12k_mac_fils_discovery(struct ath12k_vif *arvif,
+static int ath12k_mac_fils_discovery(struct ath12k_link_vif *arvif,
 				     struct ieee80211_bss_conf *info)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
 	struct sk_buff *tmpl;
 	struct ath12k_hw *ah = ar->ah;
@@ -3411,7 +3575,7 @@ static int ath12k_mac_fils_discovery(str
 	if (info->fils_discovery.max_interval) {
 		interval = info->fils_discovery.max_interval;
 
-		tmpl = ieee80211_get_fils_discovery_tmpl(ah->hw, arvif->vif);
+		tmpl = ieee80211_get_fils_discovery_tmpl(ah->hw, ahvif->vif);
 		if (tmpl)
 			ret = ath12k_wmi_fils_discovery_tmpl(ar, arvif->vdev_id,
 							     tmpl);
@@ -3420,7 +3584,7 @@ static int ath12k_mac_fils_discovery(str
 		interval = info->unsol_bcast_probe_resp_interval;
 
 		tmpl = ieee80211_get_unsol_bcast_probe_resp_tmpl(ah->hw,
-								 arvif->vif);
+								 ahvif->vif);
 		if (tmpl)
 			ret = ath12k_wmi_probe_resp_tmpl(ar, arvif->vdev_id,
 							 tmpl);
@@ -3622,11 +3786,12 @@ static int ath12k_mac_config_obss_pd(str
 }
 
 static void ath12k_mac_bss_info_changed(struct ath12k *ar,
-					struct ieee80211_vif *vif,
+					struct ath12k_link_vif *arvif,
 					struct ieee80211_bss_conf *info,
 					u64 changed)
 {
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
 	struct cfg80211_chan_def def;
 	u32 param_id, param_value;
 	enum nl80211_band band;
@@ -3639,6 +3804,7 @@ static void ath12k_mac_bss_info_changed(
 	u8 rateidx;
 	u32 rate;
 	bool color_collision_detect;
+	u8 link_id = arvif->link_id;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -3719,10 +3885,10 @@ static void ath12k_mac_bss_info_changed(
 
 	if (changed & BSS_CHANGED_SSID &&
 	    vif->type == NL80211_IFTYPE_AP) {
-		arvif->u.ap.ssid_len = vif->cfg.ssid_len;
+		ahvif->u.ap.ssid_len = vif->cfg.ssid_len;
 		if (vif->cfg.ssid_len)
-			memcpy(arvif->u.ap.ssid, vif->cfg.ssid, vif->cfg.ssid_len);
-		arvif->u.ap.hidden_ssid = info->hidden_ssid;
+			memcpy(ahvif->u.ap.ssid, vif->cfg.ssid, vif->cfg.ssid_len);
+		ahvif->u.ap.hidden_ssid = info->hidden_ssid;
 	}
 
 	if (changed & BSS_CHANGED_BSSID && !is_zero_ether_addr(info->bssid))
@@ -3832,9 +3998,9 @@ static void ath12k_mac_bss_info_changed(
 
 	if (changed & BSS_CHANGED_ASSOC) {
 		if (vif->cfg.assoc)
-			ath12k_bss_assoc(ar, vif, info);
+			ath12k_bss_assoc(ar, arvif, info);
 		else
-			ath12k_bss_disassoc(ar, vif);
+			ath12k_bss_disassoc(ar, arvif);
 	}
 
 	if (changed & BSS_CHANGED_TXPOWER) {
@@ -3843,8 +4009,8 @@ static void ath12k_mac_bss_info_changed(
 
 		if (ar->supports_6ghz && info->chandef.chan &&
                     info->chandef.chan->band == NL80211_BAND_6GHZ &&
-                    (arvif->vdev_type == WMI_VDEV_TYPE_STA ||
-                     arvif->vdev_type == WMI_VDEV_TYPE_AP) &&
+                    (ahvif->vdev_type == WMI_VDEV_TYPE_STA ||
+                     ahvif->vdev_type == WMI_VDEV_TYPE_AP) &&
                     test_bit(WMI_TLV_SERVICE_EXT_TPC_REG_SUPPORT,
                              ar->ab->wmi_ab.svc_map)) {
                         ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
@@ -3856,7 +4022,7 @@ static void ath12k_mac_bss_info_changed(
 	}
 
 	if (changed & BSS_CHANGED_MCAST_RATE &&
-	    !ath12k_mac_vif_chan(arvif->vif, &def)) {
+	    !ath12k_mac_vif_chan(ahvif->vif, &def, link_id)) {
 		band = def.chan->band;
 		mcast_rate = vif->bss_conf.mcast_rate[band];
 
@@ -3900,8 +4066,8 @@ static void ath12k_mac_bss_info_changed(
 	}
 
 	if (changed & BSS_CHANGED_BASIC_RATES &&
-	    !ath12k_mac_vif_chan(arvif->vif, &def))
-		ath12k_recalculate_mgmt_rate(ar, vif, &def);
+	    !ath12k_mac_vif_chan(ahvif->vif, &def, link_id))
+		ath12k_recalculate_mgmt_rate(ar, arvif, &def, info);
 
 	if (changed & BSS_CHANGED_TWT) {
 		if (info->twt_requester || info->twt_responder)
@@ -3921,7 +4087,7 @@ static void ath12k_mac_bss_info_changed(
 							    arvif->vdev_id,
 							    info->he_bss_color.color,
 							    ATH12K_BSS_COLOR_AP_PERIODS,
-							    arvif->vif->bss_conf.nontransmitted ?
+							    ahvif->vif->bss_conf.nontransmitted ?
 							    0 : color_collision_detect);
 			if (ret)
 				ath12k_warn(ar->ab, "failed to set bss color collision on vdev %i: %d\n",
@@ -3972,16 +4138,52 @@ static void ath12k_mac_bss_info_changed(
 	}
 }
 
+static void ath12k_mac_op_vif_cfg_changed(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif,
+					  u64 changed)
+{
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif;
+	struct ath12k *ar;
+
+	if (changed & BSS_CHANGED_SSID &&
+	    vif->type == NL80211_IFTYPE_AP) {
+		ahvif->u.ap.ssid_len = vif->cfg.ssid_len;
+		if (vif->cfg.ssid_len)
+			memcpy(ahvif->u.ap.ssid, vif->cfg.ssid, vif->cfg.ssid_len);
+	}
+
+	if (changed & BSS_CHANGED_ASSOC) {
+		/* TODO Handle STA ML assoc */
+		arvif = &ahvif->deflink;
+		ar = arvif->ar;
+		if (vif->cfg.assoc)
+			ath12k_bss_assoc(ar, arvif, &vif->bss_conf);
+		else
+			ath12k_bss_disassoc(ar, arvif);
+	}
+}
+
 static void ath12k_mac_op_bss_info_changed(struct ieee80211_hw *hw,
 					   struct ieee80211_vif *vif,
 					   struct ieee80211_bss_conf *info,
 					   u64 changed)
 {
 	struct ath12k_hw *ah = hw->priv;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif;
 	struct ath12k *ar;
+	u8 link_id = info->link_id;
 
 	mutex_lock(&ah->conf_mutex);
+	arvif = ahvif->link[link_id];
+
+	if (arvif == NULL) {
+		/* TODO handle link based ahvif caching */
+		mutex_unlock(&ah->conf_mutex);
+		return;
+	}
+
 	if (!arvif->is_created) {
 		ath12k_info(NULL,
 			    "bss info parameter changes %llx cached to apply after vdev create on channel assign\n",
@@ -3995,15 +4197,14 @@ static void ath12k_mac_op_bss_info_chang
 
 	mutex_lock(&ar->conf_mutex);
 
-	ath12k_mac_bss_info_changed(ar, vif, info, changed);
+	ath12k_mac_bss_info_changed(ar, arvif, info, changed);
 
 	mutex_unlock(&ar->conf_mutex);
 	mutex_unlock(&ah->conf_mutex);
 }
 
-static int ath12k_mac_vdev_delete(struct ath12k *ar, struct ieee80211_vif *vif)
+static int ath12k_mac_vdev_delete(struct ath12k *ar, struct ath12k_link_vif *arvif)
 {
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
 	unsigned long time_left;
 	int ret = 0;
 
@@ -4043,6 +4244,61 @@ clean_up:
 	return ret;
 }
 
+static struct ath12k_link_vif *
+ath12k_mac_get_link_vif( struct ath12k_hw *ah, struct ieee80211_vif *vif, u8 link_id)
+{
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
+	int i;
+
+	lockdep_assert_held(&ah->conf_mutex);
+
+	if(ahvif->link[link_id])
+		return ahvif->link[link_id];
+
+	/* Not a ML vif */
+	if (!vif->valid_links) {
+		link_id = 0;
+		arvif =  &ahvif->deflink;
+	} else {
+		/* first link vif is fetched from deflink*/
+		if (!ahvif->links_map)
+			arvif = &ahvif->deflink;
+		else
+			arvif = (struct ath12k_link_vif *)
+					kzalloc(sizeof(struct ath12k_link_vif),
+						GFP_KERNEL);
+
+		if (arvif == NULL)
+			return NULL;
+
+	}
+
+	ahvif->link[link_id] = arvif;
+	arvif->ahvif = ahvif;
+	arvif->link_id = link_id;
+	ahvif->links_map |= BIT(link_id);
+
+	for (i = 0; i < ARRAY_SIZE(arvif->bitrate_mask.control); i++) {
+		arvif->bitrate_mask.control[i].legacy = 0xffffffff;
+		arvif->bitrate_mask.control[i].gi = NL80211_TXRATE_FORCE_SGI;
+		memset(arvif->bitrate_mask.control[i].ht_mcs, 0xff,
+		       sizeof(arvif->bitrate_mask.control[i].ht_mcs));
+		memset(arvif->bitrate_mask.control[i].vht_mcs, 0xff,
+		       sizeof(arvif->bitrate_mask.control[i].vht_mcs));
+		memset(arvif->bitrate_mask.control[i].he_mcs, 0xff,
+		       sizeof(arvif->bitrate_mask.control[i].he_mcs));
+		memset(arvif->bitrate_mask.control[i].eht_mcs, 0xff,
+		       sizeof(arvif->bitrate_mask.control[i].eht_mcs));
+	}
+	
+	INIT_LIST_HEAD(&arvif->list);
+	INIT_WORK(&arvif->update_obss_color_notify_work, ath12k_update_obss_color_notify_work);
+	INIT_WORK(&arvif->update_bcn_template_work, ath12k_update_bcn_template_work);
+
+	return arvif;
+}
+
 static struct ath12k*
 ath12k_mac_select_scan_device(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif,
@@ -4246,7 +4502,7 @@ static int ath12k_mac_op_hw_scan(struct
 				 struct ieee80211_scan_request *hw_req)
 {
 	struct ath12k_hw *ah = hw->priv;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_link_vif *arvif;
 	struct cfg80211_scan_request *req = &hw_req->req;
 	struct ath12k *ar;
 	struct scan_req_params arg;
@@ -4266,6 +4522,8 @@ static int ath12k_mac_op_hw_scan(struct
 		return -EINVAL;
 	}
 
+	/* TODO ML vif handling */
+	arvif = ath12k_mac_get_link_vif(ah, vif, 0);  
 	/* If the vif is already assigned to a specific vdev of an ar,
 	 * check whether its already started, vdev which is started
 	 * are not allowed to switch to a new radio.
@@ -4280,7 +4538,7 @@ static int ath12k_mac_op_hw_scan(struct
 			mutex_unlock(&ah->conf_mutex);
 			return -EINVAL;
 		} else if (ar != arvif->ar) {
-			ret = ath12k_mac_vdev_delete(arvif->ar, vif);
+			ret = ath12k_mac_vdev_delete(arvif->ar, arvif);
 			if (ret)
 				ath12k_warn(arvif->ar->ab, "unable to delete scan vdev %d\n", ret);
 		} else {
@@ -4290,7 +4548,7 @@ static int ath12k_mac_op_hw_scan(struct
 
 	if (create) {
 		mutex_lock(&ar->conf_mutex);
-		ret = ath12k_mac_vdev_create(ar, vif);
+		ret = ath12k_mac_vdev_create(ar, arvif);
 		if (ret) {
 			mutex_unlock(&ar->conf_mutex);
 			mutex_unlock(&ah->conf_mutex);
@@ -4376,11 +4634,26 @@ exit:
 static void ath12k_mac_op_cancel_hw_scan(struct ieee80211_hw *hw,
 					 struct ieee80211_vif *vif)
 {
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif;
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
+	/* TODO we currently use temp link id as 0, for runtime
+	 * force AP scan handle accordingly by identifying the
+	 * active scan link
+	 */
+	u8 link_id = 0;
 
 	mutex_lock(&ah->conf_mutex);
+
+	if (!(ahvif->links_map & BIT(link_id))) {
+		mutex_unlock(&ah->conf_mutex);
+		ath12k_err(NULL, "unable to select device to cancel scan\n");
+		return;
+	}
+
+	arvif = ahvif->link[link_id];
+
 	if (!arvif->is_created) {
 		ath12k_err(NULL, "unable to select device to cancel scan\n");
 		mutex_unlock(&ah->conf_mutex);
@@ -4397,12 +4670,13 @@ static void ath12k_mac_op_cancel_hw_scan
 	cancel_delayed_work_sync(&ar->scan.timeout);
 }
 
-static int ath12k_install_key(struct ath12k_vif *arvif,
+static int ath12k_install_key(struct ath12k_link_vif *arvif,
 			      struct ieee80211_key_conf *key,
 			      enum set_key_cmd cmd,
 			      const u8 *macaddr, u32 flags)
 {
 	int ret;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
 	struct wmi_vdev_install_key_arg arg = {
 		.vdev_id = arvif->vdev_id,
@@ -4464,15 +4738,15 @@ install:
 	if (!wait_for_completion_timeout(&ar->install_key_done, 1 * HZ))
 		return -ETIMEDOUT;
 
-	if (ether_addr_equal(macaddr, arvif->vif->addr)) {
-		arvif->key_cipher = key->cipher;
+	if (ether_addr_equal(macaddr, arvif->addr)) {
+		ahvif->key_cipher = key->cipher;
 		ath12k_dp_tx_update_bank_profile(arvif);
 	}
 
 	return ar->install_key_status ? -EINVAL : 0;
 }
 
-static int ath12k_clear_peer_keys(struct ath12k_vif *arvif,
+static int ath12k_clear_peer_keys(struct ath12k_link_vif *arvif,
 				  const u8 *addr)
 {
 	struct ath12k *ar = arvif->ar;
@@ -4515,20 +4789,37 @@ static int ath12k_clear_peer_keys(struct
 }
 
 static int ath12k_mac_set_key(struct ath12k *ar, enum set_key_cmd cmd,
-			      struct ieee80211_vif *vif,
-			      struct ieee80211_sta *sta,
+			      struct ath12k_link_vif *arvif,
+			      struct ath12k_link_sta *arsta,
 			      struct ieee80211_key_conf *key)
 {
 	struct ath12k_base *ab;
 	struct ath12k_peer *peer;
-	struct ath12k_sta *arsta;
+	struct ath12k_sta *ahsta = NULL;
 	const u8 *peer_addr;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
+	struct ieee80211_bss_conf *link_conf;
 	int ret = 0;
 	u32 flags = 0;
+	u8 link_id = arvif->link_id;
+	struct ieee80211_sta *sta = NULL;
+
+	if (arsta) {
+		ahsta = arsta->ahsta;
+		sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+	}
 
 	lockdep_assert_held(&ar->ah->conf_mutex);
 
+	rcu_read_lock();
+	link_conf = rcu_dereference(vif->link_conf[link_id]);
+
+	if (!link_conf) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
+
 	ab = ar->ab;
 
 	/* BIP needs to be done in software */
@@ -4536,28 +4827,33 @@ static int ath12k_mac_set_key(struct ath
 	    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||
 	    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256 ||
 	    key->cipher == WLAN_CIPHER_SUITE_BIP_CMAC_256) {
+		rcu_read_unlock();
 		ret = 1;
 		goto out;
 	}
 
 	if (test_bit(ATH12K_FLAG_HW_CRYPTO_DISABLED, &ar->ab->dev_flags)) {
+		rcu_read_unlock();
 		ret = 1;
 		goto out;
 	}
 
 	if (key->keyidx > WMI_MAX_KEY_INDEX) {
+		rcu_read_unlock();
 		ret = -ENOSPC;
 		goto out;
 	}
 
-	mutex_lock(&ar->conf_mutex);
-
 	if (sta)
 		peer_addr = sta->addr;
-	else if (arvif->vdev_type == WMI_VDEV_TYPE_STA)
-		peer_addr = vif->bss_conf.bssid;
+	else if (ahvif->vdev_type == WMI_VDEV_TYPE_STA)
+		peer_addr = link_conf->bssid;
 	else
-		peer_addr = vif->addr;
+		peer_addr = link_conf->addr;
+
+	rcu_read_unlock();
+
+	mutex_lock(&ar->conf_mutex);
 
 	key->hw_key_idx = key->keyidx;
 
@@ -4621,8 +4917,6 @@ static int ath12k_mac_set_key(struct ath
 		ath12k_warn(ab, "peer %pM disappeared!\n", peer_addr);
 
 	if (sta) {
-		arsta = (struct ath12k_sta *)sta->drv_priv;
-
 		switch (key->cipher) {
 		case WLAN_CIPHER_SUITE_TKIP:
 		case WLAN_CIPHER_SUITE_CCMP:
@@ -4630,12 +4924,12 @@ static int ath12k_mac_set_key(struct ath
 		case WLAN_CIPHER_SUITE_GCMP:
 		case WLAN_CIPHER_SUITE_GCMP_256:
 			if (cmd == SET_KEY)
-				arsta->pn_type = HAL_PN_TYPE_WPA;
+				ahsta->pn_type = HAL_PN_TYPE_WPA;
 			else
-				arsta->pn_type = HAL_PN_TYPE_NONE;
+				ahsta->pn_type = HAL_PN_TYPE_NONE;
 			break;
 		default:
-			arsta->pn_type = HAL_PN_TYPE_NONE;
+			ahsta->pn_type = HAL_PN_TYPE_NONE;
 			break;
 		}
 	}
@@ -4654,11 +4948,17 @@ static int ath12k_mac_op_set_key(struct
 {
 	struct ath12k *ar;
 	struct ath12k_hw *ah = hw->priv;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif;
+	struct ath12k_link_sta *arsta = NULL;
+	struct ath12k_sta *ahsta;
 	int ret;
 
 	mutex_lock(&ah->conf_mutex);
 
+	/* TODO modify for all link vif configuration */
+	arvif = &ahvif->deflink;
+
 	if (!arvif->is_created) {
 		arvif->cache.key_conf.cmd = cmd;
 		arvif->cache.key_conf.sta = sta;
@@ -4675,7 +4975,12 @@ static int ath12k_mac_op_set_key(struct
 	}
 
 	ar = arvif->ar;
-	ret = ath12k_mac_set_key(ar, cmd, vif, sta, key);
+
+	if (sta) {
+		ahsta = (struct ath12k_sta *)sta->drv_priv;
+		arsta = &ahsta->deflink;
+	}
+	ret = ath12k_mac_set_key(ar, cmd, arvif, arsta, key);
 
 	mutex_unlock(&ah->conf_mutex);
 	return ret;
@@ -4752,8 +5057,8 @@ ath12k_mac_bitrate_mask_num_eht_rates(st
 }
 
 static int
-ath12k_mac_set_peer_vht_fixed_rate(struct ath12k_vif *arvif,
-				   struct ieee80211_sta *sta,
+ath12k_mac_set_peer_vht_fixed_rate(struct ath12k_link_vif *arvif,
+				   struct ath12k_link_sta *arsta,
 				   const struct cfg80211_bitrate_mask *mask,
 				   enum nl80211_band band)
 {
@@ -4761,6 +5066,10 @@ ath12k_mac_set_peer_vht_fixed_rate(struc
 	u8 vht_rate, nss;
 	u32 rate_code;
 	int ret, i;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -4798,8 +5107,8 @@ ath12k_mac_set_peer_vht_fixed_rate(struc
 }
 
 static int
-ath12k_mac_set_peer_he_fixed_rate(struct ath12k_vif *arvif,
-				  struct ieee80211_sta *sta,
+ath12k_mac_set_peer_he_fixed_rate(struct ath12k_link_vif *arvif,
+				  struct ath12k_link_sta *arsta,
 				  const struct cfg80211_bitrate_mask *mask,
 				  enum nl80211_band band)
 {
@@ -4807,6 +5116,10 @@ ath12k_mac_set_peer_he_fixed_rate(struct
 	u8 he_rate, nss;
 	u32 rate_code;
 	int ret, i;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -4849,8 +5162,8 @@ ath12k_mac_set_peer_he_fixed_rate(struct
 }
 
 static int
-ath12k_mac_set_peer_ht_fixed_rate(struct ath12k_vif *arvif,
-				 struct ieee80211_sta *sta,
+ath12k_mac_set_peer_ht_fixed_rate(struct ath12k_link_vif *arvif,
+				 struct ath12k_link_sta *arsta,
 				 const struct cfg80211_bitrate_mask *mask,
 				 enum nl80211_band band)
 {
@@ -4858,6 +5171,10 @@ ath12k_mac_set_peer_ht_fixed_rate(struct
 	u8 ht_rate, nss;
 	u32 rate_code;
 	int ret, i;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -4900,8 +5217,8 @@ ath12k_mac_set_peer_ht_fixed_rate(struct
 }
 
 static int
-ath12k_mac_set_peer_eht_fixed_rate(struct ath12k_vif *arvif,
-				   struct ieee80211_sta *sta,
+ath12k_mac_set_peer_eht_fixed_rate(struct ath12k_link_vif *arvif,
+				   struct ath12k_link_sta *arsta,
 				   const struct cfg80211_bitrate_mask *mask,
 				   enum nl80211_band band)
 {
@@ -4909,6 +5226,10 @@ ath12k_mac_set_peer_eht_fixed_rate(struc
 	u8 eht_rate, nss;
 	u32 rate_code;
 	int ret, i;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -4953,9 +5274,12 @@ ath12k_mac_set_peer_eht_fixed_rate(struc
 static int ath12k_station_assoc(struct ath12k *ar,
 				struct ieee80211_vif *vif,
 				struct ieee80211_sta *sta,
-				bool reassoc)
+				bool reassoc, u8 link_id)
 {
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif = ahvif->link[link_id];
+	struct ath12k_link_sta *arsta;
+	struct ath12k_sta *ahsta;
 	struct peer_assoc_params peer_arg;
 	int ret = 0;
 	struct cfg80211_chan_def def;
@@ -4965,13 +5289,19 @@ static int ath12k_station_assoc(struct a
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	if (WARN_ON(ath12k_mac_vif_chan(vif, &def)))
+	if (!arvif)
+		return -EINVAL;
+
+	if (WARN_ON(ath12k_mac_vif_chan(vif, &def, link_id)))
 		return -EPERM;
 
 	band = def.chan->band;
 	mask = &arvif->bitrate_mask;
 
-	ath12k_peer_assoc_prepare(ar, vif, sta, &peer_arg, reassoc);
+	ahsta = (struct ath12k_sta *)sta->drv_priv;
+	arsta = ahsta->link[link_id];
+
+	ath12k_peer_assoc_prepare(ar, arvif, arsta, &peer_arg, reassoc);
 
 	peer_arg.is_assoc = true;
 	ret = ath12k_wmi_send_peer_assoc_cmd(ar, &peer_arg);
@@ -4998,22 +5328,22 @@ static int ath12k_station_assoc(struct a
 	 * Note that all other rates and NSS will be disabled for this peer.
 	 */
 	if (sta->deflink.vht_cap.vht_supported && num_vht_rates == 1) {
-		ret = ath12k_mac_set_peer_vht_fixed_rate(arvif, sta, mask,
+		ret = ath12k_mac_set_peer_vht_fixed_rate(arvif, arsta, mask,
 							 band);
 		if (ret)
 			return ret;
 	} else if (sta->deflink.he_cap.has_he && num_he_rates == 1) {
-		ret = ath12k_mac_set_peer_he_fixed_rate(arvif, sta, mask,
+		ret = ath12k_mac_set_peer_he_fixed_rate(arvif, arsta, mask,
 							band);
 		if (ret)
 			return ret;
 	} else if (sta->deflink.eht_cap.has_eht && num_eht_rates == 1) {
-		ret = ath12k_mac_set_peer_eht_fixed_rate(arvif, sta, mask,
+		ret = ath12k_mac_set_peer_eht_fixed_rate(arvif, arsta, mask,
 							 band);
 		if (ret)
 			return ret;
 	} else if (sta->deflink.ht_cap.ht_supported && num_ht_rates == 1) {
-		ret = ath12k_mac_set_peer_ht_fixed_rate(arvif, sta, mask,
+		ret = ath12k_mac_set_peer_ht_fixed_rate(arvif, arsta, mask,
 							band);
 		if (ret)
 			return ret;
@@ -5042,7 +5372,7 @@ static int ath12k_station_assoc(struct a
 	}
 
 	if (sta->wme && sta->uapsd_queues) {
-		ret = ath12k_peer_assoc_qos_ap(ar, arvif, sta);
+		ret = ath12k_peer_assoc_qos_ap(ar, arvif, arsta);
 		if (ret) {
 			ath12k_warn(ar->ab, "failed to set qos params for STA %pM for vdev %i: %d\n",
 				    sta->addr, arvif->vdev_id, ret);
@@ -5055,13 +5385,18 @@ static int ath12k_station_assoc(struct a
 
 static int ath12k_station_disassoc(struct ath12k *ar,
 				   struct ieee80211_vif *vif,
-				   struct ieee80211_sta *sta)
+				   struct ieee80211_sta *sta,
+				   u8 link_id)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif = ahvif->link[link_id];
 	int ret = 0;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
+	if (!arvif)
+		return -EINVAL;
+
 	if (!sta->wme) {
 		arvif->num_legacy_stations--;
 		ret = ath12k_recalc_rtscts_prot(arvif);
@@ -5075,8 +5410,9 @@ static int ath12k_station_disassoc(struc
 static void ath12k_sta_rc_update_wk(struct work_struct *wk)
 {
 	struct ath12k *ar;
-	struct ath12k_vif *arvif;
-	struct ath12k_sta *arsta;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_vif *ahvif;
+	struct ath12k_link_sta *arsta;
 	struct ieee80211_sta *sta;
 	struct cfg80211_chan_def def;
 	enum nl80211_band band;
@@ -5090,12 +5426,14 @@ static void ath12k_sta_rc_update_wk(stru
 	struct peer_assoc_params peer_arg;
 	enum wmi_phy_mode peer_phymode;
 
-	arsta = container_of(wk, struct ath12k_sta, update_wk);
+	arsta = container_of(wk, struct ath12k_link_sta, update_wk);
 	sta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);
 	arvif = arsta->arvif;
+	ahvif = arvif->ahvif;
 	ar = arvif->ar;
 
-	if (WARN_ON(ath12k_mac_vif_chan(arvif->vif, &def)))
+	/* TODO get link_id and pass for ML - link STA */
+	if (WARN_ON(ath12k_mac_vif_chan(ahvif->vif, &def, 0)))
 		return;
 
 	band = def.chan->band;
@@ -5126,7 +5464,7 @@ static void ath12k_sta_rc_update_wk(stru
 
 	if (changed & IEEE80211_RC_BW_CHANGED) {
 		/* Get the the peer phymode */
-		ath12k_peer_assoc_h_phymode(ar, arvif->vif, sta, &peer_arg);
+		ath12k_peer_assoc_h_phymode(ar, arvif, arsta, &peer_arg);
 		peer_phymode = peer_arg.peer_phymode;
 
 		if (bw > bw_prev) {
@@ -5217,16 +5555,16 @@ static void ath12k_sta_rc_update_wk(stru
 		 * across HT/VHT and for multiple VHT MCS support.
 		 */
 		if (sta->deflink.vht_cap.vht_supported && num_vht_rates == 1) {
-			ath12k_mac_set_peer_vht_fixed_rate(arvif, sta, mask,
+			ath12k_mac_set_peer_vht_fixed_rate(arvif, arsta, mask,
 							   band);
 		} else if (sta->deflink.he_cap.has_he && num_he_rates == 1) {
-			ath12k_mac_set_peer_he_fixed_rate(arvif, sta, mask,
+			ath12k_mac_set_peer_he_fixed_rate(arvif, arsta, mask,
 							  band);
 		} else if (sta->deflink.eht_cap.has_eht && num_eht_rates == 1) {
-			ath12k_mac_set_peer_eht_fixed_rate(arvif, sta, mask,
+			ath12k_mac_set_peer_eht_fixed_rate(arvif, arsta, mask,
 							   band);
 		} else if (sta->deflink.ht_cap.ht_supported && num_ht_rates == 1) {
-			ath12k_mac_set_peer_ht_fixed_rate(arvif, sta, mask,
+			ath12k_mac_set_peer_ht_fixed_rate(arvif, arsta, mask,
 							  band);
 		} else {
 			/* If the peer is non-VHT/HE/EHT or no fixed VHT/HE/EHT
@@ -5244,7 +5582,7 @@ static void ath12k_sta_rc_update_wk(stru
 				ath12k_warn(ar->ab,
 					    "failed to disable peer fixed rate for STA %pM ret %d\n",
 					    sta->deflink.addr, err);
-			ath12k_peer_assoc_prepare(ar, arvif->vif, sta,
+			ath12k_peer_assoc_prepare(ar, arvif, arsta,
 						  &peer_arg, true);
 
 			peer_arg.is_assoc = false;
@@ -5265,36 +5603,49 @@ err_rc_bw_changed:
 static void ath12k_sta_set_4addr_wk(struct work_struct *wk)
 {
 	struct ath12k *ar;
-	struct ath12k_vif *arvif;
-	struct ath12k_sta *arsta;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_sta *ahsta;
+	struct ath12k_link_sta *arsta;
 	struct ieee80211_sta *sta;
 	int ret = 0;
+	u16 links_map;
+	u8 link_id;
 
-	arsta = container_of(wk, struct ath12k_sta, set_4addr_wk);
-	sta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);
-	arvif = arsta->arvif;
-	ar = arvif->ar;
+	ahsta = container_of(wk, struct ath12k_sta, set_4addr_wk);
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
-	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
-		   "setting USE_4ADDR for peer %pM\n", sta->addr);
+	links_map = ahsta->links_map;
 
-	ret = ath12k_wmi_set_peer_param(ar, sta->addr,
-					arvif->vdev_id,
-					WMI_PEER_USE_4ADDR, 1);
+	for_each_set_bit(link_id, &links_map, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arsta = ahsta->link[link_id];
+		arvif = arsta->arvif;
+		ar = arvif->ar;
 
-	if (ret)
-		ath12k_warn(ar->ab, "failed to set peer %pM 4addr capability: %d\n",
-			    sta->addr, ret);
+		ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
+			   "setting USE_4ADDR for peer %pM\n", sta->addr);
+
+		ret = ath12k_wmi_set_peer_param(ar, sta->addr,
+						arvif->vdev_id,
+						WMI_PEER_USE_4ADDR, 1);
+		if (ret)
+			ath12k_warn(ar->ab, "failed to set peer %pM 4addr capability: %d\n",
+				    sta->addr, ret);
+	}
 }
 
-static int ath12k_mac_inc_num_stations(struct ath12k_vif *arvif,
-				       struct ieee80211_sta *sta)
+static int ath12k_mac_inc_num_stations(struct ath12k_link_vif *arvif,
+				       struct ath12k_link_sta *arsta)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)
 		return 0;
 
 	if (ar->num_stations >= ar->max_num_stations)
@@ -5305,32 +5656,44 @@ static int ath12k_mac_inc_num_stations(s
 	return 0;
 }
 
-static void ath12k_mac_dec_num_stations(struct ath12k_vif *arvif,
-					struct ieee80211_sta *sta)
+static void ath12k_mac_dec_num_stations(struct ath12k_link_vif *arvif,
+				        struct ath12k_link_sta *arsta)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)
 		return;
 
 	ar->num_stations--;
 }
 
 static int ath12k_mac_station_add(struct ath12k *ar,
-				  struct ieee80211_vif *vif,
-				  struct ieee80211_sta *sta)
+				  struct ath12k_link_vif *arvif,
+				  struct ath12k_link_sta *arsta)
 {
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
 	struct peer_create_params peer_param;
 	int ret;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	ret = ath12k_mac_inc_num_stations(arvif, sta);
+	if (!arvif)
+		return -EINVAL;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	ret = ath12k_mac_inc_num_stations(arvif, arsta);
 	if (ret) {
 		ath12k_warn(ab, "refusing to associate station: too many connected already (%d)\n",
 			    ar->max_num_stations);
@@ -5395,7 +5758,7 @@ static int ath12k_mac_station_add(struct
 
 	if (ab->hw_params->vdev_start_delay &&
 	    !arvif->is_started &&
-	    arvif->vdev_type != WMI_VDEV_TYPE_AP) {
+	    ahvif->vdev_type != WMI_VDEV_TYPE_AP) {
 		ret = ath12k_start_vdev_delay(ar, vif);
 		if (ret) {
 			ath12k_warn(ab, "failed to delay vdev start: %d\n", ret);
@@ -5416,7 +5779,7 @@ free_rx_stats:
 	kfree(arsta->rx_stats);
 	arsta->rx_stats = NULL;
 dec_num_station:
-	ath12k_mac_dec_num_stations(arvif, sta);
+	ath12k_mac_dec_num_stations(arvif, arsta);
 exit:
 	return ret;
 }
@@ -5429,14 +5792,22 @@ static int ath12k_mac_op_sta_state(struc
 {
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_link_sta *arsta;
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
 	struct ath12k_peer *peer;
 	int ret = 0;
 
+	/* TODO handle ML link vif/sta separately */
+	if (vif->valid_links)
+		return 0;
+
 	mutex_lock(&ah->conf_mutex);
 
-	ar = ath12k_get_ar_by_vif(hw, vif);
+	arvif = &ahvif->deflink;
+	arsta = &ahsta->deflink;
+	ar = arvif->ar;
 	if (!ar) {
 		ath12k_err(NULL, "unable to determine device to set sta state\n");
 		mutex_unlock(&ah->conf_mutex);
@@ -5447,19 +5818,23 @@ static int ath12k_mac_op_sta_state(struc
 	if ((old_state == IEEE80211_STA_NONE &&
 	     new_state == IEEE80211_STA_NOTEXIST)) {
 		cancel_work_sync(&arsta->update_wk);
-		cancel_work_sync(&arsta->set_4addr_wk);
+		cancel_work_sync(&ahsta->set_4addr_wk);
+		ahsta->link[0] = NULL;
+		ahsta->links_map = 0;
 	}
 
 	mutex_lock(&ar->conf_mutex);
 
 	if (old_state == IEEE80211_STA_NOTEXIST &&
 	    new_state == IEEE80211_STA_NONE) {
+		ahsta->link[0] = arsta;
+		ahsta->links_map = 1;
 		memset(arsta, 0, sizeof(*arsta));
 		arsta->arvif = arvif;
 		INIT_WORK(&arsta->update_wk, ath12k_sta_rc_update_wk);
-		INIT_WORK(&arsta->set_4addr_wk, ath12k_sta_set_4addr_wk);
+		INIT_WORK(&ahsta->set_4addr_wk, ath12k_sta_set_4addr_wk);
 
-		ret = ath12k_mac_station_add(ar, vif, sta);
+		ret = ath12k_mac_station_add(ar, arvif, arsta);
 		if (ret)
 			ath12k_warn(ar->ab, "Failed to add station: %pM for VDEV: %d\n",
 				    sta->addr, arvif->vdev_id);
@@ -5475,7 +5850,7 @@ static int ath12k_mac_op_sta_state(struc
 			ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "Removed peer: %pM for VDEV: %d num_peers : %d\n",
 				   sta->addr, arvif->vdev_id, ar->num_peers);
 
-		ath12k_mac_dec_num_stations(arvif, sta);
+		ath12k_mac_dec_num_stations(arvif, arsta);
 		spin_lock_bh(&ar->ab->base_lock);
 		peer = ath12k_peer_find(ar->ab, arvif->vdev_id, sta->addr);
 		if (peer && peer->sta == sta) {
@@ -5501,7 +5876,7 @@ static int ath12k_mac_op_sta_state(struc
 		   (vif->type == NL80211_IFTYPE_AP ||
 		    vif->type == NL80211_IFTYPE_MESH_POINT ||
 		    vif->type == NL80211_IFTYPE_ADHOC)) {
-		ret = ath12k_station_assoc(ar, vif, sta, false);
+		ret = ath12k_station_assoc(ar, vif, sta, false, 0);
 		if (ret)
 			ath12k_warn(ar->ab, "Failed to associate station: %pM\n",
 				    sta->addr);
@@ -5585,7 +5960,7 @@ static int ath12k_mac_op_sta_state(struc
 		   (vif->type == NL80211_IFTYPE_AP ||
 		    vif->type == NL80211_IFTYPE_MESH_POINT ||
 		    vif->type == NL80211_IFTYPE_ADHOC)) {
-		ret = ath12k_station_disassoc(ar, vif, sta);
+		ret = ath12k_station_disassoc(ar, vif, sta, 0);
 		if (ret)
 			ath12k_warn(ar->ab, "Failed to disassociate station: %pM\n",
 				    sta->addr);
@@ -5602,13 +5977,25 @@ static int ath12k_mac_op_sta_set_txpwr(s
 {
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
 	int ret = 0;
 	s16 txpwr;
+	/* TODO use link id from op after support is available */
+	u8 link_id = 0;
 
 	mutex_lock(&ah->conf_mutex);
 
-	ar = ath12k_get_ar_by_vif(hw, vif);
+	/* TODO get arvif based on link id */
+	arvif = ahvif->link[link_id];
+
+	if (!arvif) {
+		ath12k_err(NULL, "unable to determine device to set sta txpwr\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ar = ath12k_get_ar_by_vif(hw, vif, link_id);
 	if (!ar) {
 		ath12k_err(NULL, "unable to determine device to set sta txpwr\n");
 		ret = -EINVAL;
@@ -5652,11 +6039,11 @@ static void ath12k_mac_op_sta_set_4addr(
 					struct ieee80211_sta *sta, bool enabled)
 {
 	struct ath12k_hw *ah = hw->priv;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
 
-	if (enabled && !arsta->use_4addr_set) {
-		ieee80211_queue_work(ah->hw, &arsta->set_4addr_wk);
-		arsta->use_4addr_set = true;
+	if (enabled && !ahsta->use_4addr_set) {
+		ieee80211_queue_work(ah->hw, &ahsta->set_4addr_wk);
+		ahsta->use_4addr_set = true;
 	}
 }
 
@@ -5665,13 +6052,23 @@ static void ath12k_mac_op_sta_rc_update(
 					struct ieee80211_sta *sta,
 					u32 changed)
 {
-	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_link_sta *arsta;
 	struct ath12k_peer *peer;
 	u32 bw, smps;
+	/* TODO update link id after op supports */
+	u8 link_id = 0;
+
+	arvif = ahvif->link[link_id];
+	arsta = ahsta->link[link_id];
 
+	if (!arvif) {
+		ath12k_err(NULL, "unable to determine device for sta update\n");
+		return;
+	}
 
 	if (arvif->is_created)
 		ar = arvif->ar;
@@ -5686,7 +6083,6 @@ static void ath12k_mac_op_sta_rc_update(
 	peer = ath12k_peer_find(ar->ab, arvif->vdev_id, sta->addr);
 	if (!peer) {
 		spin_unlock_bh(&ar->ab->base_lock);
-		mutex_unlock(&ah->conf_mutex);
 		ath12k_warn(ar->ab, "mac sta rc update failed to find peer %pM on vdev %i\n",
 			    sta->addr, arvif->vdev_id);
 		return;
@@ -5765,14 +6161,14 @@ static void ath12k_mac_op_sta_rc_update(
 	ieee80211_queue_work(hw, &arsta->update_wk);
 }
 
-static int ath12k_conf_tx_uapsd(struct ath12k *ar, struct ieee80211_vif *vif,
+static int ath12k_conf_tx_uapsd(struct ath12k *ar, struct ath12k_link_vif *arvif,
 				u16 ac, bool enable)
 {
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	u32 value = 0;
 	int ret = 0;
 
-	if (arvif->vdev_type != WMI_VDEV_TYPE_STA)
+	if (ahvif->vdev_type != WMI_VDEV_TYPE_STA)
 		return 0;
 
 	switch (ac) {
@@ -5794,20 +6190,21 @@ static int ath12k_conf_tx_uapsd(struct a
 		break;
 	}
 
+	/* TODO move link specific ? */
 	if (enable)
-		arvif->u.sta.uapsd |= value;
+		ahvif->u.sta.uapsd |= value;
 	else
-		arvif->u.sta.uapsd &= ~value;
+		ahvif->u.sta.uapsd &= ~value;
 
 	ret = ath12k_wmi_set_sta_ps_param(ar, arvif->vdev_id,
 					  WMI_STA_PS_PARAM_UAPSD,
-					  arvif->u.sta.uapsd);
+					  ahvif->u.sta.uapsd);
 	if (ret) {
 		ath12k_warn(ar->ab, "could not set uapsd params %d\n", ret);
 		goto exit;
 	}
 
-	if (arvif->u.sta.uapsd)
+	if (ahvif->u.sta.uapsd)
 		value = WMI_STA_PS_RX_WAKE_POLICY_POLL_UAPSD;
 	else
 		value = WMI_STA_PS_RX_WAKE_POLICY_WAKE;
@@ -5823,10 +6220,9 @@ exit:
 }
 
 static int ath12k_mac_conf_tx(struct ath12k *ar,
-			      struct ieee80211_vif *vif, u16 ac,
+			      struct ath12k_link_vif *arvif, u16 ac,
 			      const struct ieee80211_tx_queue_params *params)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
 	struct wmi_wmm_params_arg *p = NULL;
 	int ret;
 
@@ -5867,7 +6263,7 @@ static int ath12k_mac_conf_tx(struct ath
 		goto exit;
 	}
 
-	ret = ath12k_conf_tx_uapsd(ar, vif, ac, params->uapsd);
+	ret = ath12k_conf_tx_uapsd(ar, arvif, ac, params->uapsd);
 
 	if (ret)
 		ath12k_warn(ar->ab, "failed to set sta uapsd: %d\n", ret);
@@ -5883,13 +6279,22 @@ static int ath12k_mac_op_conf_tx(struct
 {
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
 	int ret;
 
+	mutex_lock(&ah->conf_mutex);
+	arvif = &ahvif->deflink;
+
+	/* TODO replace arvif caching to link based ahvif caching */
+	if (arvif == NULL) {
+		mutex_unlock(&ah->conf_mutex);
+		return 0;
+	}
+
 	/* If the tx config is received before a vdev is assigned to vif
 	 * cache the info to be updated once vdev is created
 	 */
-	mutex_lock(&ah->conf_mutex);
 	if (!arvif->is_created) {
 		ath12k_dbg(NULL, ATH12K_DBG_MAC,
 			   "tx queue params cached since vif is not assigned to radio\n");
@@ -5904,7 +6309,7 @@ static int ath12k_mac_op_conf_tx(struct
 	ar = arvif->ar;
 
 	mutex_lock(&ar->conf_mutex);
-	ret = ath12k_mac_conf_tx(ar, vif, ac, params);
+	ret = ath12k_mac_conf_tx(ar, arvif, ac, params);
 	mutex_unlock(&ar->conf_mutex);
 
 	return ret;
@@ -5976,10 +6381,11 @@ ath12k_create_ht_cap(struct ath12k *ar,
 	return ht_cap;
 }
 
-static int ath12k_mac_set_txbf_conf(struct ath12k_vif *arvif)
+static int ath12k_mac_set_txbf_conf(struct ath12k_link_vif *arvif)
 {
 	u32 value = 0;
 	struct ath12k *ar = arvif->ar;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	int nsts;
 	int sound_dim;
 	u32 vht_cap = ar->pdev->cap.vht_cap;
@@ -6007,7 +6413,7 @@ static int ath12k_mac_set_txbf_conf(stru
 		value |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;
 
 		if ((vht_cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE) &&
-		    arvif->vdev_type == WMI_VDEV_TYPE_AP)
+		    ahvif->vdev_type == WMI_VDEV_TYPE_AP)
 			value |= WMI_VDEV_PARAM_TXBF_MU_TX_BFER;
 	}
 
@@ -6017,7 +6423,7 @@ static int ath12k_mac_set_txbf_conf(stru
 		value |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;
 
 		if ((vht_cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE) &&
-		    arvif->vdev_type == WMI_VDEV_TYPE_STA)
+		    ahvif->vdev_type == WMI_VDEV_TYPE_STA)
 			value |= WMI_VDEV_PARAM_TXBF_MU_TX_BFEE;
 	}
 
@@ -6722,7 +7128,7 @@ static int ath12k_mac_vif_txmgmt_idr_rem
 	return 0;
 }
 
-static int ath12k_mac_mgmt_tx_wmi(struct ath12k *ar, struct ath12k_vif *arvif,
+static int ath12k_mac_mgmt_tx_wmi(struct ath12k *ar, struct ath12k_link_vif *arvif,
 				  struct sk_buff *skb)
 {
 	struct ath12k_base *ab = ar->ab;
@@ -6791,7 +7197,8 @@ static void ath12k_mgmt_over_wmi_tx_work
 {
 	struct ath12k *ar = container_of(work, struct ath12k, wmi_mgmt_tx_work);
 	struct ath12k_skb_cb *skb_cb;
-	struct ath12k_vif *arvif;
+	struct ath12k_vif *ahvif;
+	struct ath12k_link_vif *arvif;
 	struct sk_buff *skb;
 	int ret;
 
@@ -6803,7 +7210,9 @@ static void ath12k_mgmt_over_wmi_tx_work
 			continue;
 		}
 
-		arvif = ath12k_vif_to_arvif(skb_cb->vif);
+		ahvif = ath12k_vif_to_ahvif(skb_cb->vif);
+		/* TODO check this for extending link specific */
+		arvif = &ahvif->deflink;
 		mutex_lock(&ar->conf_mutex);
 		if (ar->allocated_vdev_map & (1LL << arvif->vdev_id) &&
 		    arvif->is_started) {
@@ -6867,20 +7276,23 @@ static void ath12k_mac_op_tx(struct ieee
 	struct ath12k_skb_cb *skb_cb = ATH12K_SKB_CB(skb);
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_vif *vif = info->control.vif;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	/* TODO extend link specific */
+	struct ath12k_link_vif *arvif = &ahvif->deflink;
 	struct ath12k *ar = arvif->ar;
 	struct ath12k_hw *ah = ar->ah;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_key_conf *key = info->control.hw_key;
-	struct ath12k_mgmt_frame_stats *mgmt_stats = &arvif->mgmt_stats;
-	struct ath12k_sta *arsta = NULL;
+	struct ath12k_mgmt_frame_stats *mgmt_stats = &ahvif->mgmt_stats;
+	struct ath12k_sta *ahsta = NULL;
+	struct ath12k_link_sta *arsta = NULL;
 	struct ieee80211_sta *sta = control->sta;
 	u32 info_flags = info->flags;
 	bool is_prb_rsp;
 	u16 frm_type = 0;
 	int ret;
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
 		ieee80211_free_txskb(ah->hw, skb);
 		return;
 	}
@@ -6919,8 +7331,8 @@ static void ath12k_mac_op_tx(struct ieee
 		}
 		return;
 	}
-	if (control->sta)
-		arsta = (struct ath12k_sta *)control->sta->drv_priv;
+	if (sta)
+		ahsta = (struct ath12k_sta *)control->sta->drv_priv;
 
 	/* Must call mac80211 tx status handler, else when stats is disabled we
 	 * free the skb from driver. Own tx packets on monitor will also be
@@ -6932,7 +7344,7 @@ static void ath12k_mac_op_tx(struct ieee
 	    test_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags))
 		skb_cb->flags |= ATH12K_SKB_TX_STATUS;
 
-	ret = ath12k_dp_tx(ar, arvif, arsta, skb);
+	ret = ath12k_dp_tx(ar, arvif, ahsta, skb);
 	if (unlikely(ret)) {
 		if (ret == -ENOMEM)
 			ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "failed to transmit frame %d\n",
@@ -6943,13 +7355,11 @@ static void ath12k_mac_op_tx(struct ieee
 		ieee80211_free_txskb(ah->hw, skb);
 	}
 
-	if (ath12k_debugfs_is_extd_tx_stats_enabled(ar) && sta) {
-		arsta = (struct ath12k_sta *)sta->drv_priv;
-		if (arsta) {
-			atomic_inc(&arsta->drv_tx_pkts.pkts_in);
-			if (!ret)
-				atomic_inc(&arsta->drv_tx_pkts.pkts_out);
-		}
+	if (ath12k_debugfs_is_extd_tx_stats_enabled(ar) && ahsta) {
+		arsta = &ahsta->deflink;
+		atomic_inc(&arsta->drv_tx_pkts.pkts_in);
+		if (!ret)
+			atomic_inc(&arsta->drv_tx_pkts.pkts_out);
 	}
 }
 
@@ -7380,7 +7790,7 @@ static void ath12k_mac_op_stop(struct ie
 }
 
 static u8
-ath12k_mac_get_vdev_stats_id(struct ath12k_vif *arvif)
+ath12k_mac_get_vdev_stats_id(struct ath12k_link_vif *arvif)
 {
 	struct ath12k_base *ab = arvif->ar->ab;
 	u8 vdev_stats_id = 0;
@@ -7402,50 +7812,53 @@ ath12k_mac_get_vdev_stats_id(struct ath1
 	return vdev_stats_id;
 }
 
-static int ath12k_mac_setup_vdev_params_mbssid(struct ath12k_vif *arvif,
+static int ath12k_mac_setup_vdev_params_mbssid(struct ath12k_link_vif *arvif,
 					       u32 *flags, u32 *tx_vdev_id)
 {
 	struct ath12k *ar = arvif->ar;
-	struct ath12k_vif *tx_arvif;
+	struct ath12k_link_vif *tx_arvif;
 	struct ieee80211_vif *tx_vif;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 
 	*tx_vdev_id = 0;
-	tx_vif = arvif->vif->mbssid_tx_vif;
+	/* FIXME MBSSID with MLO */
+	tx_vif = arvif->ahvif->vif->mbssid_tx_vif;
 	if (!tx_vif) {
 		*flags = WMI_HOST_VDEV_FLAGS_NON_MBSSID_AP;
 		return 0;
 	}
 
-	tx_arvif = (void *)tx_vif->drv_priv;
+	tx_arvif = &ath12k_vif_to_ahvif(tx_vif)->deflink;
 
-	if (arvif->vif->bss_conf.nontransmitted) {
+	if (ahvif->vif->bss_conf.nontransmitted) {
 		if (ar->ah->hw->wiphy != ieee80211_vif_to_wdev(tx_vif)->wiphy)
 			return -EINVAL;
 
 		*flags = WMI_HOST_VDEV_FLAGS_NON_TRANSMIT_AP;
-		*tx_vdev_id = ath12k_vif_to_arvif(tx_vif)->vdev_id;
+		*tx_vdev_id = tx_arvif->vdev_id;
 	} else if (tx_arvif == arvif) {
 		*flags = WMI_HOST_VDEV_FLAGS_TRANSMIT_AP;
 	} else {
 		return -EINVAL;
 	}
 
-	if (arvif->vif->bss_conf.ema_ap)
+	if (ahvif->vif->bss_conf.ema_ap)
 		*flags |= WMI_HOST_VDEV_FLAGS_EMA_MODE;
 
 	return 0;
 }
 
-static int ath12k_mac_setup_vdev_create_params(struct ath12k_vif *arvif,
+static int ath12k_mac_setup_vdev_create_params(struct ath12k_link_vif *arvif,
 					       struct vdev_create_params *params)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
 	struct ath12k_pdev *pdev = ar->pdev;
 	int ret;
 
 	params->if_id = arvif->vdev_id;
-	params->type = arvif->vdev_type;
-	params->subtype = arvif->vdev_subtype;
+	params->type = ahvif->vdev_type;
+	params->subtype = ahvif->vdev_subtype;
 	params->pdev_id = pdev->pdev_id;
 	params->mbssid_flags = 0;
 	params->mbssid_tx_vdev_id = 0;
@@ -7479,10 +7892,11 @@ static int ath12k_mac_setup_vdev_create_
 }
 
 static void ath12k_mac_update_vif_offload(struct ath12k *ar,
-					  struct ieee80211_vif *vif)
+					  struct ath12k_link_vif *arvif)
 {
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
 	u32 param_id, param_value;
 	int ret;
 
@@ -7494,14 +7908,14 @@ static void ath12k_mac_update_vif_offloa
 					IEEE80211_OFFLOAD_DECAP_ENABLED);
 
 	if (vif->offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
-		arvif->tx_encap_type = ATH12K_HW_TXRX_ETHERNET;
+		ahvif->tx_encap_type = ATH12K_HW_TXRX_ETHERNET;
 	else if (test_bit(ATH12K_FLAG_RAW_MODE, &ab->dev_flags))
-		arvif->tx_encap_type = ATH12K_HW_TXRX_RAW;
+		ahvif->tx_encap_type = ATH12K_HW_TXRX_RAW;
 	else
-		arvif->tx_encap_type = ATH12K_HW_TXRX_NATIVE_WIFI;
+		ahvif->tx_encap_type = ATH12K_HW_TXRX_NATIVE_WIFI;
 
 	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
-					    param_id, arvif->tx_encap_type);
+					    param_id, ahvif->tx_encap_type);
 	if (ret) {
 		ath12k_warn(ab, "failed to set vdev %d tx encap mode: %d\n",
 			    arvif->vdev_id, ret);
@@ -7529,24 +7943,25 @@ static void ath12k_mac_op_update_vif_off
 					     struct ieee80211_vif *vif)
 {
 	struct ath12k_hw *ah = hw->priv;
-	struct ath12k *ar;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif;
 
 	mutex_lock(&ah->conf_mutex);
 
+	/* TODO ML link vifs handling, currently checking default only */
 	/* If the update_vif_offload() is received from mac80211 before
 	 * vdev is created, no action is needed since the flags would
 	 * be applied right after vdev create based on vif->offload_flags
 	 */
-	ar = ath12k_get_ar_by_vif(hw, vif);
-	if (!ar) {
+	arvif = &ahvif->deflink;
+	if (!arvif->ar) {
 		ath12k_info(NULL,
 			    "unable to determine device to apply vif encap/decap flags, setting will be applied on channel assignment\n");
 		mutex_unlock(&ah->conf_mutex);
 		return;
 	}
 
-	ath12k_mac_update_vif_offload(ar, vif);
+	ath12k_mac_update_vif_offload(arvif->ar, arvif);
 	ath12k_dp_tx_update_bank_profile(arvif);
 
 	mutex_unlock(&ah->conf_mutex);
@@ -7554,7 +7969,7 @@ static void ath12k_mac_op_update_vif_off
 
 static void ath12k_update_bcn_template_work(struct work_struct *work)
 {
-	struct ath12k_vif *arvif = container_of(work, struct ath12k_vif,
+	struct ath12k_link_vif *arvif = container_of(work, struct ath12k_link_vif,
 					update_bcn_template_work);
 	struct ath12k *ar = arvif->ar;
 	int ret = -EINVAL;
@@ -7573,7 +7988,7 @@ static void ath12k_update_bcn_template_w
 
 static void ath12k_update_obss_color_notify_work(struct work_struct *work)
 {
-	struct ath12k_vif *arvif = container_of(work, struct ath12k_vif,
+	struct ath12k_link_vif *arvif = container_of(work, struct ath12k_link_vif,
 					update_obss_color_notify_work);
 	struct ath12k *ar;
 
@@ -7584,27 +7999,45 @@ static void ath12k_update_obss_color_not
 
 	mutex_lock(&ar->conf_mutex);
 	if (arvif->is_created)
-		ieeee80211_obss_color_collision_notify(arvif->vif,
+		ieeee80211_obss_color_collision_notify(arvif->ahvif->vif,
 						       arvif->obss_color_bitmap,
 						       GFP_KERNEL);
 	arvif->obss_color_bitmap = 0;
 	mutex_unlock(&ar->conf_mutex);
 }
 
-static int ath12k_mac_vdev_create(struct ath12k *ar, struct ieee80211_vif *vif)
+static int ath12k_mac_vdev_create(struct ath12k *ar, struct ath12k_link_vif *arvif)
 {
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ieee80211_hw *hw = ar->ah->hw;
 	struct vdev_create_params vdev_param = {0};
 	struct peer_create_params peer_param;
+	struct ieee80211_bss_conf *link_conf;
 	u32 param_id, param_value;
 	u16 nss;
 	int i;
 	int ret, vdev_id;
+	u8 link_addr[ETH_ALEN];
+	int txpower;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
+	rcu_read_lock();
+
+	link_conf = rcu_dereference(vif->link_conf[arvif->link_id]);
+
+	if (!link_conf) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
+
+	memcpy(link_addr, link_conf->addr, ETH_ALEN);
+	memcpy(arvif->addr, link_conf->addr, ETH_ALEN);
+	txpower = link_conf->txpower;
+	rcu_read_unlock();
+
 	/* Send vdev stats offload commands to firmware before first vdev
 	 * creation. ie., when num_created_vdevs = 0
 	 */
@@ -7619,22 +8052,22 @@ static int ath12k_mac_vdev_create(struct
 	vdev_id = __ffs64(ab->free_vdev_map);
 
 	arvif->vdev_id = vdev_id;
-	arvif->vdev_subtype = WMI_VDEV_SUBTYPE_NONE;
+	ahvif->vdev_subtype = WMI_VDEV_SUBTYPE_NONE;
 	arvif->ar = ar;
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_UNSPECIFIED:
 	case NL80211_IFTYPE_STATION:
-		arvif->vdev_type = WMI_VDEV_TYPE_STA;
+		ahvif->vdev_type = WMI_VDEV_TYPE_STA;
 		break;
 	case NL80211_IFTYPE_MESH_POINT:
-		arvif->vdev_subtype = WMI_VDEV_SUBTYPE_MESH_11S;
+		ahvif->vdev_subtype = WMI_VDEV_SUBTYPE_MESH_11S;
 		fallthrough;
 	case NL80211_IFTYPE_AP:
-		arvif->vdev_type = WMI_VDEV_TYPE_AP;
+		ahvif->vdev_type = WMI_VDEV_TYPE_AP;
 		break;
 	case NL80211_IFTYPE_MONITOR:
-		arvif->vdev_type = WMI_VDEV_TYPE_MONITOR;
+		ahvif->vdev_type = WMI_VDEV_TYPE_MONITOR;
 		ar->monitor_vdev_id = vdev_id;
 		break;
 	default:
@@ -7643,7 +8076,7 @@ static int ath12k_mac_vdev_create(struct
 	}
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "mac vdev create id %d type %d subtype %d map %llx\n",
-		   arvif->vdev_id, arvif->vdev_type, arvif->vdev_subtype,
+		   arvif->vdev_id, ahvif->vdev_type, ahvif->vdev_subtype,
 		   ab->free_vdev_map);
 
 	/* TODO Revisit this sharing of common queues across all ar's */
@@ -7658,7 +8091,7 @@ static int ath12k_mac_vdev_create(struct
 		goto err;
 	}
 
-	ret = ath12k_wmi_vdev_create(ar, vif->addr, &vdev_param);
+	ret = ath12k_wmi_vdev_create(ar, link_addr, &vdev_param);
 	if (ret) {
 		ath12k_warn(ab, "failed to create WMI vdev %d: %d\n",
 			    arvif->vdev_id, ret);
@@ -7668,7 +8101,7 @@ static int ath12k_mac_vdev_create(struct
 	ar->num_created_vdevs++;
 	arvif->is_created = true;
 	ath12k_dbg(ab, ATH12K_DBG_MAC, "vdev %pM created, vdev_id %d\n",
-		   vif->addr, arvif->vdev_id);
+		   link_addr, arvif->vdev_id);
 
 	ar->allocated_vdev_map |= 1LL << arvif->vdev_id;
 	ab->free_vdev_map &= ~(1LL << arvif->vdev_id);
@@ -7677,7 +8110,7 @@ static int ath12k_mac_vdev_create(struct
 	list_add(&arvif->list, &ar->arvifs);
 	spin_unlock_bh(&ar->data_lock);
 
-	ath12k_mac_update_vif_offload(ar, vif);
+	ath12k_mac_update_vif_offload(ar, arvif);
 
 	nss = get_num_chains(ar->cfg_tx_chainmask) ? : 1;
 	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
@@ -7688,10 +8121,10 @@ static int ath12k_mac_vdev_create(struct
 		goto err_vdev_del;
 	}
 
-	switch (arvif->vdev_type) {
+	switch (ahvif->vdev_type) {
 	case WMI_VDEV_TYPE_AP:
 		peer_param.vdev_id = arvif->vdev_id;
-		peer_param.peer_addr = vif->addr;
+		peer_param.peer_addr = link_addr;
 		peer_param.peer_type = WMI_PEER_TYPE_DEFAULT;
 		ret = ath12k_peer_create(ar, arvif, NULL, &peer_param);
 		if (ret) {
@@ -7752,7 +8185,7 @@ static int ath12k_mac_vdev_create(struct
 		break;
 	}
 
-	arvif->txpower = vif->bss_conf.txpower;
+	arvif->txpower = txpower;
 	ret = ath12k_mac_txpower_recalc(ar);
 	if (ret)
 		goto err_peer_del;
@@ -7781,19 +8214,19 @@ static int ath12k_mac_vdev_create(struct
 	return ret;
 
 err_peer_del:
-	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_AP) {
 		reinit_completion(&ar->peer_delete_done);
 
-		ret = ath12k_wmi_send_peer_delete_cmd(ar, vif->addr,
+		ret = ath12k_wmi_send_peer_delete_cmd(ar, link_addr,
 						      arvif->vdev_id);
 		if (ret) {
 			ath12k_warn(ar->ab, "failed to delete peer vdev_id %d addr %pM\n",
-				    arvif->vdev_id, vif->addr);
+				    arvif->vdev_id, link_addr);
 			goto err;
 		}
 
 		ret = ath12k_wait_for_peer_delete_done(ar, arvif->vdev_id,
-						       vif->addr);
+						       link_addr);
 		if (ret)
 			goto err;
 
@@ -7819,13 +8252,17 @@ err:
 static void ath12k_mac_vif_cache_flush(struct ath12k *ar,  struct ieee80211_vif *vif)
 {
 	struct ath12k_hw *ah = ar->ah;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
 	int ret;
 
 	lockdep_assert_held(&ah->conf_mutex);
 
+	/* TODO extend for all link vifs */
+	arvif = &ahvif->deflink;
+
 	if (arvif->cache.tx_conf.changed) {
-		ret = ath12k_mac_conf_tx(ar, vif, arvif->cache.tx_conf.ac,
+		ret = ath12k_mac_conf_tx(ar, arvif, arvif->cache.tx_conf.ac,
 					 &arvif->cache.tx_conf.tx_queue_params);
 		if (ret)
 			ath12k_warn(ar->ab,
@@ -7833,13 +8270,13 @@ static void ath12k_mac_vif_cache_flush(s
 	}
 
 	if (arvif->cache.bss_conf_changed) {
-		ath12k_mac_bss_info_changed(ar, vif, &vif->bss_conf,
+		ath12k_mac_bss_info_changed(ar, arvif, &vif->bss_conf,
 					    arvif->cache.bss_conf_changed);
 	}
 
 	if (arvif->cache.key_conf.changed) {
 		ret = ath12k_mac_set_key(ar, arvif->cache.key_conf.cmd,
-					 vif, arvif->cache.key_conf.sta,
+					 arvif, NULL,
 					 arvif->cache.key_conf.key);
 		if (ret)
 			ath12k_warn(ar->ab, "unable to apply set key param to vdev %d ret %d\n",
@@ -7850,13 +8287,13 @@ static void ath12k_mac_vif_cache_flush(s
 }
 
 static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
-						    struct ieee80211_vif *vif,
+						    struct ath12k_link_vif *arvif,
 						    struct ieee80211_chanctx_conf *ctx)
 {
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
 	struct ath12k_base *ab;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	u8 bit;
 	int ret;
 
@@ -7891,7 +8328,7 @@ static struct ath12k *ath12k_mac_assign_
 		goto unlock;
 	}
 
-	ret = ath12k_mac_vdev_create(ar, vif);
+	ret = ath12k_mac_vdev_create(ar, arvif);
 	if (ret) {
 		ath12k_warn(ab, "failed to create vdev %d ret %d", bit, ret);
 		goto unlock;
@@ -7911,7 +8348,7 @@ out:
 static int ath12k_mac_op_add_interface(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif)
 {
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
 	struct ath12k_hw *ah = hw->priv;
 	int i;
 
@@ -7924,29 +8361,16 @@ static int ath12k_mac_op_add_interface(s
 	 */
 
 	mutex_lock(&ah->conf_mutex);
-	memset(arvif, 0, sizeof(*arvif));
+	memset(ahvif, 0, sizeof(*ahvif));
 
-	arvif->vdev_type = vif->type;
-	arvif->vif = vif;
+	ahvif->vdev_type = vif->type;
+	ahvif->vif = vif;
+	ahvif->ah = ah;
 
-	INIT_LIST_HEAD(&arvif->list);
-	arvif->key_cipher = INVALID_CIPHER;
+	ahvif->deflink.ahvif = ahvif;
+	ahvif->deflink.link_id = 0;
 
-	INIT_WORK(&arvif->update_obss_color_notify_work, ath12k_update_obss_color_notify_work);
-	INIT_WORK(&arvif->update_bcn_template_work, ath12k_update_bcn_template_work);
-
-	for (i = 0; i < ARRAY_SIZE(arvif->bitrate_mask.control); i++) {
-		arvif->bitrate_mask.control[i].legacy = 0xffffffff;
-		arvif->bitrate_mask.control[i].gi = NL80211_TXRATE_FORCE_SGI;
-		memset(arvif->bitrate_mask.control[i].ht_mcs, 0xff,
-		       sizeof(arvif->bitrate_mask.control[i].ht_mcs));
-		memset(arvif->bitrate_mask.control[i].vht_mcs, 0xff,
-		       sizeof(arvif->bitrate_mask.control[i].vht_mcs));
-		memset(arvif->bitrate_mask.control[i].he_mcs, 0xff,
-		       sizeof(arvif->bitrate_mask.control[i].he_mcs));
-		memset(arvif->bitrate_mask.control[i].eht_mcs, 0xff,
-		       sizeof(arvif->bitrate_mask.control[i].eht_mcs));
-	}
+	ahvif->key_cipher = INVALID_CIPHER;
 
 	/* Allocate Default Queue now and reassign during actual vdev create */
 	vif->cab_queue = ATH12K_HW_DEFAULT_QUEUE;
@@ -7983,25 +8407,25 @@ static void ath12k_mac_vif_unref(struct
 	}
 }
 
-static void ath12k_mac_op_remove_interface(struct ieee80211_hw *hw,
-					   struct ieee80211_vif *vif)
+static void ath12k_mac_remove_link_interface(struct ieee80211_hw *hw,
+					     struct ath12k_link_vif *arvif)
 {
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
 	struct ath12k_base *ab;
 	int ret;
 
 	cancel_work_sync(&arvif->update_obss_color_notify_work);
 	cancel_work_sync(&arvif->update_bcn_template_work);
 
-	mutex_lock(&ah->conf_mutex);
+	lockdep_assert_held(&ah->conf_mutex);
 
-	ar = ath12k_get_ar_by_vif(hw, vif);
+	ar = arvif->ar;
 	if (!ar) {
 		ath12k_dbg(NULL, ATH12K_DBG_MAC,
 			   "unable to determine device to remove interface\n");
-		mutex_unlock(&ah->conf_mutex);
 		return;
 	}
 
@@ -8017,18 +8441,18 @@ static void ath12k_mac_op_remove_interfa
 		ath12k_warn(ab, "failed to stop spectral for vdev %i: %d\n",
 			    arvif->vdev_id, ret);
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
-		ret = ath12k_peer_delete(ar, arvif->vdev_id, vif->addr);
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_AP) {
+		ret = ath12k_peer_delete(ar, arvif->vdev_id, arvif->addr);
 		if (ret)
 			ath12k_warn(ab, "failed to submit AP self-peer removal on vdev %d: %d"
 				    " num_peer : %d\n", arvif->vdev_id, ret, ar->num_peers);
 	}
 
-	ret = ath12k_mac_vdev_delete(ar, vif);
+	ret = ath12k_mac_vdev_delete(ar, arvif);
 	if (ret)
 		goto err_vdev_del;
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
 		ar->monitor_vdev_id = -1;
 		clear_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags);
 	} else if (test_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags) &&
@@ -8037,7 +8461,7 @@ static void ath12k_mac_op_remove_interfa
 	}
 
 	ath12k_dbg(ab, ATH12K_DBG_MAC, "vdev %pM deleted, vdev_id %d\n",
-		   vif->addr, arvif->vdev_id);
+		   arvif->addr, arvif->vdev_id);
 
 err_vdev_del:
 	ath12k_peer_cleanup(ar, arvif->vdev_id);
@@ -8049,7 +8473,7 @@ err_vdev_del:
 
 	ath12k_mac_vif_unref(&ab->dp, vif);
 	ath12k_dp_tx_put_bank_profile(&ab->dp, arvif->bank_id);
-	arvif->key_cipher = INVALID_CIPHER;
+	ahvif->key_cipher = INVALID_CIPHER;
 
 	/* Recalc txpower for remaining vdev */
 	ath12k_mac_txpower_recalc(ar);
@@ -8061,6 +8485,35 @@ err_vdev_del:
 	/* TODO: recal traffic pause state based on the available vdevs */
 
 	mutex_unlock(&ar->conf_mutex);
+}
+
+static void ath12k_mac_op_remove_interface(struct ieee80211_hw *hw,
+					   struct ieee80211_vif *vif)
+{
+	struct ath12k_hw *ah = hw->priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
+	u16 links_map;
+	u8 link_id;
+
+	mutex_lock(&ah->conf_mutex);
+
+	links_map = ahvif->links_map;
+	
+	for_each_set_bit(link_id, &links_map, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arvif = ahvif->link[link_id];
+
+		if (arvif == NULL)
+			continue;
+
+		ath12k_mac_remove_link_interface(hw, arvif);
+
+		if (arvif != &ahvif->deflink)
+			kfree(arvif);
+
+		ahvif->link[link_id] = NULL;
+	}
+
 	mutex_unlock(&ah->conf_mutex);
 }
 
@@ -8156,9 +8609,13 @@ static int ath12k_mac_op_ampdu_action(st
 	struct ath12k *ar;
 	int ret = -EINVAL;
 
+	/* TODO handle for ML link vifs */
+	if (vif->valid_links)
+		return 0;
+
 	mutex_lock(&ah->conf_mutex);
 
-	ar = ath12k_get_ar_by_vif(hw, vif);
+	ar = ath12k_get_ar_by_vif(hw, vif, 0);
 	if (!ar) {
 		ath12k_err(NULL, "unable to determine device to set ampdu params\n");
 		mutex_unlock(&ah->conf_mutex);
@@ -8252,17 +8709,32 @@ static void ath12k_mac_op_remove_chanctx
 	mutex_unlock(&ar->conf_mutex);
 }
 
-static int ath12k_mac_set_6g_nonht_dup_conf(struct ath12k_vif *arvif,
-											const struct cfg80211_chan_def *chandef)
+static int ath12k_mac_set_6g_nonht_dup_conf(struct ath12k_link_vif *arvif,
+					    const struct cfg80211_chan_def *chandef)
 {
 	struct ath12k *ar = arvif->ar;
 	int param_id, ret = 0;
 	uint8_t value = 0;
 	bool is_psc = cfg80211_channel_is_psc(chandef->chan);
 	enum wmi_phy_mode mode = ath12k_phymodes[chandef->chan->band][chandef->width];
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_bss_conf *link_conf;
+	u8 link_addr[ETH_ALEN];
+
+	rcu_read_lock();
+
+	link_conf = rcu_dereference(ahvif->vif->link_conf[arvif->link_id]);
+
+	if (!link_conf) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
 
-	if ((arvif->vdev_type == WMI_VDEV_TYPE_AP) &&
-	    !arvif->vif->bss_conf.nontransmitted &&
+	memcpy(link_addr, link_conf->addr, ETH_ALEN);
+	rcu_read_unlock();
+
+	if ((ahvif->vdev_type == WMI_VDEV_TYPE_AP) &&
+	    !ahvif->vif->bss_conf.nontransmitted &&
 	    (chandef->chan->band == NL80211_BAND_6GHZ)) {
 		param_id = WMI_VDEV_PARAM_6GHZ_PARAMS;
 		if (mode > MODE_11AX_HE20 && !is_psc) {
@@ -8272,17 +8744,18 @@ static int ath12k_mac_set_6g_nonht_dup_c
 		}
 		ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		           "Set 6GHz non-ht dup params for vdev %pM ,vdev_id %d param %d value %d\n",
-		           arvif->vif->addr, arvif->vdev_id, param_id, value);
+			   link_addr, arvif->vdev_id, param_id, value);
 		ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param_id, value);
 	}
 	return ret;
 }
 
 static int
-ath12k_mac_vdev_start_restart(struct ath12k_vif *arvif,
+ath12k_mac_vdev_start_restart(struct ath12k_link_vif *arvif,
 			      const struct cfg80211_chan_def *chandef,
 			      bool restart, bool radar_enabled)
 {
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
 	struct ath12k_base *ab = ar->ab;
 	struct wmi_vdev_start_req_arg arg = {};
@@ -8322,10 +8795,10 @@ ath12k_mac_vdev_start_restart(struct ath
 			return ret;
 	}
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
-		arg.ssid = arvif->u.ap.ssid;
-		arg.ssid_len = arvif->u.ap.ssid_len;
-		arg.hidden_ssid = arvif->u.ap.hidden_ssid;
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_AP) {
+		arg.ssid = ahvif->u.ap.ssid;
+		arg.ssid_len = ahvif->u.ap.ssid_len;
+		arg.hidden_ssid = ahvif->u.ap.hidden_ssid;
 
 		/* For now allow DFS for AP mode */
 		arg.channel.chan_radar =
@@ -8365,16 +8838,16 @@ ath12k_mac_vdev_start_restart(struct ath
 
 	if (ar->supports_6ghz &&
             chandef->chan->band == NL80211_BAND_6GHZ &&
-            (arvif->vdev_type == WMI_VDEV_TYPE_STA || arvif->vdev_type == WMI_VDEV_TYPE_AP) &&
+            (ahvif->vdev_type == WMI_VDEV_TYPE_STA || ahvif->vdev_type == WMI_VDEV_TYPE_AP) &&
             test_bit(WMI_TLV_SERVICE_EXT_TPC_REG_SUPPORT, ar->ab->wmi_ab.svc_map)) {
-                ath12k_mac_fill_reg_tpc_info(ar, arvif->vif, &arvif->chanctx);
+                ath12k_mac_fill_reg_tpc_info(ar, arvif, &arvif->chanctx);
                 ath12k_wmi_send_vdev_set_tpc_power(ar, arvif->vdev_id,
                                                    &arvif->reg_tpc_info);
        }
 
 	ar->num_started_vdevs++;
 	ath12k_dbg(ab, ATH12K_DBG_MAC,  "vdev %pM started, vdev_id %d\n",
-		   arvif->vif->addr, arvif->vdev_id);
+		   arvif->addr, arvif->vdev_id);
 
 	/* Enable CAC Flag in the driver by checking the channel DFS cac time,
 	 * i.e dfs_cac_ms value which will be valid only for radar channels
@@ -8383,7 +8856,7 @@ ath12k_mac_vdev_start_restart(struct ath
 	 * during CAC.
 	 */
 	/* TODO Set the flag for other interface types as required */
-	if (arvif->vdev_type == WMI_VDEV_TYPE_AP &&
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_AP &&
 	    chandef->chan->dfs_cac_ms &&
 	    chandef->chan->dfs_state == NL80211_DFS_USABLE) {
 		set_bit(ATH12K_CAC_RUNNING, &ar->dev_flags);
@@ -8405,7 +8878,7 @@ ath12k_mac_vdev_start_restart(struct ath
 	return 0;
 }
 
-static int ath12k_mac_vdev_stop(struct ath12k_vif *arvif)
+static int ath12k_mac_vdev_stop(struct ath12k_link_vif *arvif)
 {
 	struct ath12k *ar = arvif->ar;
 	int ret;
@@ -8432,7 +8905,7 @@ static int ath12k_mac_vdev_stop(struct a
 
 	ar->num_started_vdevs--;
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "vdev %pM stopped, vdev_id %d\n",
-		   arvif->vif->addr, arvif->vdev_id);
+		   arvif->addr, arvif->vdev_id);
 
 	if (test_bit(ATH12K_CAC_RUNNING, &ar->dev_flags)) {
 		clear_bit(ATH12K_CAC_RUNNING, &ar->dev_flags);
@@ -8445,7 +8918,7 @@ err:
 	return ret;
 }
 
-static int ath12k_mac_vdev_start(struct ath12k_vif *arvif,
+static int ath12k_mac_vdev_start(struct ath12k_link_vif *arvif,
 				 const struct cfg80211_chan_def *chandef,
 				 bool radar_enabled)
 {
@@ -8453,7 +8926,7 @@ static int ath12k_mac_vdev_start(struct
 			radar_enabled);
 }
 
-static int ath12k_mac_vdev_restart(struct ath12k_vif *arvif,
+static int ath12k_mac_vdev_restart(struct ath12k_link_vif *arvif,
 				   const struct cfg80211_chan_def *chandef,
 				   bool pseudo_restart, bool radar_enabled)
 {
@@ -8481,17 +8954,18 @@ static int ath12k_mac_vdev_restart(struc
 	return ret;
 }
 
-static int ath12k_vdev_restart_sequence(struct ath12k_vif *arvif,
+static int ath12k_vdev_restart_sequence(struct ath12k_link_vif *arvif,
 					struct ieee80211_chanctx_conf *new_ctx,
 					u64 vif_down_failed_map,
 					int vdev_index)
 {
 	struct ath12k *ar = arvif->ar;
-	struct ath12k_vif *tx_arvif;
+	struct ath12k_link_vif *tx_arvif;
+	struct ath12k_vif *tx_ahvif;
 	struct ieee80211_chanctx_conf old_chanctx;
-	struct ieee80211_vif *tx_vif;
 	struct vdev_up_params params = { 0 };
 	int ret = -EINVAL;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 
 	spin_lock_bh(&ar->data_lock);
 	old_chanctx = arvif->chanctx;
@@ -8524,13 +8998,14 @@ static int ath12k_vdev_restart_sequence(
 	}
 
 	params.vdev_id = arvif->vdev_id;
-	params.aid = arvif->aid;
+	params.aid = ahvif->aid;
 	params.bssid = arvif->bssid;
-	if (arvif->vif->mbssid_tx_vif) {
-		tx_vif = arvif->vif->mbssid_tx_vif;
-		tx_arvif = ath12k_vif_to_arvif(tx_vif);
+	if (ahvif->vif->mbssid_tx_vif) {
+		tx_ahvif = (void *) ahvif->vif->mbssid_tx_vif->drv_priv;
+		/* TODO ML mbssid changes */
+		tx_arvif = &tx_ahvif->deflink;
 		params.tx_bssid = tx_arvif->bssid;
-		params.profile_idx = arvif->vif->bss_conf.bssid_index;
+		params.profile_idx = ahvif->vif->bss_conf.bssid_index;
 		params.profile_count = tx_arvif->nontransmitting_vif_count;
 	}
 
@@ -8556,36 +9031,79 @@ static void
 ath12k_mac_change_chanctx_cnt_iter(void *data, u8 *mac,
 				   struct ieee80211_vif *vif)
 {
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif;
 	struct ath12k_mac_change_chanctx_arg *arg = data;
+	u16 links_map;
+	u8 link_id;
+	struct ieee80211_bss_conf *link_conf;
+	struct ath12k_hw *ah = ahvif->ah;
 
-	if ((rcu_access_pointer(vif->bss_conf.chanctx_conf) != arg->ctx) ||
-	    (arvif->ar != arg->ar))
-		return;
+	lockdep_assert_held(&ah->conf_mutex);
 
-	arg->n_vifs++;
+	links_map = ahvif->links_map;
+
+	for_each_set_bit(link_id, &links_map, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arvif = ahvif->link[link_id];
+ 
+		if (WARN_ON(arvif == NULL))
+			continue;
+
+		link_conf = rcu_dereference(vif->link_conf[arvif->link_id]);
+
+		if (WARN_ON(link_conf == NULL))
+			continue;
+
+		if ((rcu_access_pointer(link_conf->chanctx_conf) != arg->ctx) ||
+		    (arvif->ar != arg->ar))
+			continue;
+			
+		arg->n_vifs++;
+	}
 }
 
 static void
 ath12k_mac_change_chanctx_fill_iter(void *data, u8 *mac,
 				    struct ieee80211_vif *vif)
 {
-	struct ath12k_vif *arvif = ath12k_vif_to_arvif(vif);
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
+	struct ath12k_link_vif *arvif;
 	struct ath12k_mac_change_chanctx_arg *arg = data;
 	struct ieee80211_chanctx_conf *ctx;
+	u16 links_map;
+	u8 link_id;
+	struct ieee80211_bss_conf *link_conf;
+	struct ath12k_hw *ah = ahvif->ah;
 
-	ctx = rcu_access_pointer(vif->bss_conf.chanctx_conf);
-	if ((ctx != arg->ctx) ||
-	    (arvif->ar != arg->ar))
-		return;
+	lockdep_assert_held(&ah->conf_mutex);
 
-	if (WARN_ON(arg->next_vif == arg->n_vifs))
-		return;
+	links_map = ahvif->links_map;
+ 
+	for_each_set_bit(link_id, &links_map, IEEE80211_MLD_MAX_NUM_LINKS) {
+		arvif = ahvif->link[link_id];
 
-	arg->vifs[arg->next_vif].vif = vif;
-	arg->vifs[arg->next_vif].old_ctx = ctx;
-	arg->vifs[arg->next_vif].new_ctx = ctx;
-	arg->next_vif++;
+		if (WARN_ON(arvif == NULL))
+			continue;
+
+		link_conf = rcu_dereference(vif->link_conf[arvif->link_id]);
+
+		if (WARN_ON(link_conf == NULL))
+			continue;
+
+		ctx = rcu_access_pointer(link_conf->chanctx_conf);
+		if ((ctx != arg->ctx) ||
+		    (arvif->ar != arg->ar))
+			continue;
+
+		if (WARN_ON(arg->next_vif == arg->n_vifs))
+			return;
+
+		arg->vifs[arg->next_vif].vif = vif;
+		arg->vifs[arg->next_vif].old_ctx = ctx;
+		arg->vifs[arg->next_vif].new_ctx = ctx;
+		arg->vifs[arg->next_vif].link_conf = link_conf;
+		arg->next_vif++;
+	}
 }
 
 static void ath12k_mac_num_chanctxs_iter(struct ieee80211_hw *hw,
@@ -8663,7 +9181,8 @@ ath12k_mac_update_vif_chan(struct ath12k
 			   int n_vifs)
 {
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_vif *arvif, *tx_arvif;
+	struct ath12k_link_vif *arvif, *tx_arvif;
+	struct ath12k_vif *ahvif;
 	struct cfg80211_chan_def *chandef = NULL;
 	int ret;
 	int i, trans_vdev_index;
@@ -8683,7 +9202,11 @@ ath12k_mac_update_vif_chan(struct ath12k
 	tx_arvif = NULL;
 
 	for (i = 0; i < n_vifs; i++) {
-		arvif = (void *)vifs[i].vif->drv_priv;
+		ahvif = (void *)vifs[i].vif->drv_priv;
+		arvif = ahvif->link[vifs[i].link_conf->link_id];
+
+		if (WARN_ON(!arvif))
+			continue;
 
 		if (vifs[i].vif->type == NL80211_IFTYPE_MONITOR)
 			monitor_vif = true;
@@ -8702,10 +9225,11 @@ ath12k_mac_update_vif_chan(struct ath12k
 		if (!arvif->is_up)
 			continue;
 
-		if (arvif->vif->mbssid_tx_vif &&
-		    arvif == (struct ath12k_vif *)arvif->vif->mbssid_tx_vif->drv_priv) {
-			tx_vif = arvif->vif->mbssid_tx_vif;
-			tx_arvif = ath12k_vif_to_arvif(tx_vif);
+		if (ahvif->vif->mbssid_tx_vif &&
+		    ahvif == (struct ath12k_vif *)ahvif->vif->mbssid_tx_vif->drv_priv) {
+			tx_vif = ahvif->vif->mbssid_tx_vif;
+			/* TODO ML mbssid changes */
+			tx_arvif = &ath12k_vif_to_ahvif(tx_vif)->deflink;
 			trans_vdev_index = i;
 		}
 
@@ -8734,12 +9258,16 @@ ath12k_mac_update_vif_chan(struct ath12k
 	}
 
 	for (i = 0; i < n_vifs; i++) {
-		arvif = (void *)vifs[i].vif->drv_priv;
+		ahvif = (void *)vifs[i].vif->drv_priv;
+		arvif = ahvif->link[vifs[i].link_conf->link_id];
+
+		if (WARN_ON(!arvif))
+			continue;
 
 		if (vifs[i].vif->type == NL80211_IFTYPE_MONITOR)
 			monitor_vif = true;
 
-		if (arvif->vif->mbssid_tx_vif &&
+		if (ahvif->vif->mbssid_tx_vif &&
 		    arvif == tx_arvif)
 			continue;
 
@@ -8801,16 +9329,18 @@ ath12k_mac_update_active_vif_chan(struct
 
 	lockdep_assert_held(&ar->conf_mutex);
 
+	mutex_lock(&ah->conf_mutex);
+
 	ieee80211_iterate_active_interfaces_atomic(ah->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
 						   ath12k_mac_change_chanctx_cnt_iter,
 						   &arg);
 	if (arg.n_vifs == 0)
-		return;
+		goto out;
 
 	arg.vifs = kcalloc(arg.n_vifs, sizeof(arg.vifs[0]), GFP_KERNEL);
 	if (!arg.vifs)
-		return;
+		goto out;
 
 	ieee80211_iterate_active_interfaces_atomic(ah->hw,
 						   IEEE80211_IFACE_ITER_NORMAL,
@@ -8820,6 +9350,8 @@ ath12k_mac_update_active_vif_chan(struct
 	ath12k_mac_update_vif_chan(ar, arg.vifs, arg.n_vifs);
 
 	kfree(arg.vifs);
+out:
+	mutex_unlock(&ah->conf_mutex);
 }
 
 static void ath12k_mac_op_change_chanctx(struct ieee80211_hw *hw,
@@ -8864,7 +9396,8 @@ static int ath12k_start_vdev_delay(struc
 				   struct ieee80211_vif *vif)
 {
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif = &ahvif->deflink;
 	int ret;
 
 	if (WARN_ON(arvif->is_started))
@@ -8874,12 +9407,12 @@ static int ath12k_start_vdev_delay(struc
 			arvif->chanctx.radar_enabled);
 	if (ret) {
 		ath12k_warn(ab, "failed to start vdev %i addr %pM on freq %d: %d\n",
-			    arvif->vdev_id, vif->addr,
+			    arvif->vdev_id, arvif->addr,
 			    arvif->chanctx.def.chan->center_freq, ret);
 		return ret;
 	}
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
 		ret = ath12k_monitor_vdev_up(ar, arvif->vdev_id);
 		if (ret) {
 			ath12k_warn(ab, "failed put monitor up: %d\n", ret);
@@ -9090,11 +9623,12 @@ static void ath12k_mac_get_eirp_power(st
 }
 
 void ath12k_mac_fill_reg_tpc_info(struct ath12k *ar,
-                                  struct ieee80211_vif *vif,
+                                  struct ath12k_link_vif *arvif,
                                   struct ieee80211_chanctx_conf *ctx)
 {
         struct ath12k_base *ab = ar->ab;
-        struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
         struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
         struct ath12k_reg_tpc_power_info *reg_tpc_info = &arvif->reg_tpc_info;
         struct ieee80211_channel *chan, *temp_chan;
@@ -9109,9 +9643,9 @@ void ath12k_mac_fill_reg_tpc_info(struct
         * AP cant parse its own beacon. Hence, we get the 6g power mode
         * from the wdev corresponding to the struct ieee80211_vif
         */
-       if (arvif->vdev_type == WMI_VDEV_TYPE_STA)
+       if (ahvif->vdev_type == WMI_VDEV_TYPE_STA)
                reg_6g_power_mode = vif->bss_conf.power_type;
-       else if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
+       else if (ahvif->vdev_type == WMI_VDEV_TYPE_AP) {
                struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
                /* With respect to ieee80211, the 6G AP power mode starts from index
                 * 1 while the power type stored in struct wireless_dev is based on
@@ -9129,7 +9663,7 @@ void ath12k_mac_fill_reg_tpc_info(struct
         start_freq = ath12k_mac_get_6g_start_frequency(&ctx->def);
         pwr_reduction = bss_conf->pwr_reduction;
 
-        if (arvif->vdev_type == WMI_VDEV_TYPE_STA &&
+        if (ahvif->vdev_type == WMI_VDEV_TYPE_STA &&
 	    arvif->reg_tpc_info.num_pwr_levels) {
                 is_tpe_present = true;
                 num_pwr_levels = arvif->reg_tpc_info.num_pwr_levels;
@@ -9283,11 +9817,12 @@ void ath12k_mac_fill_reg_tpc_info(struct
 }
 
 static void ath12k_mac_parse_tx_pwr_env(struct ath12k *ar,
-                                        struct ieee80211_vif *vif,
+                                        struct ath12k_link_vif *arvif,
                                         struct ieee80211_chanctx_conf *ctx)
 {
         struct ath12k_base *ab = ar->ab;
-        struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
         struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
         struct ieee80211_tx_pwr_env *single_tpe;
         enum wmi_reg_6g_client_type client_type;
@@ -9415,21 +9950,34 @@ ath12k_mac_op_assign_vif_chanctx(struct
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar, *arvif_ar;
 	struct ath12k_base *ab;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
 	int ret;
 	struct peer_create_params param;
 	enum ieee80211_ap_reg_power power_type;
 
+	u8 link_id = link_conf->link_id;
+
 	if (!ctx)
 		return -EINVAL;
 
 	mutex_lock(&ah->conf_mutex);
+
+	arvif = ath12k_mac_get_link_vif(ah, vif, link_id);
+	if (!arvif) {
+		ath12k_err(NULL, "unable to allocate link vif\n");
+		return -ENOMEM;
+	}
+
 	if (!arvif->is_created) {
-		ar = ath12k_mac_assign_vif_to_vdev(hw, vif, ctx);
+		ar = ath12k_mac_assign_vif_to_vdev(hw, arvif, ctx);
 		if (!ar) {
 			mutex_unlock(&ah->conf_mutex);
 			return -EINVAL;
 		}
+	} else if(vif->valid_links){
+		ar = arvif->ar;
+		/* Note below case not expected for MLO/not handled now */
 	} else {
 		ar = ath12k_get_ar_by_ctx(hw, ctx);
 		if (!ar) {
@@ -9441,6 +9989,7 @@ ath12k_mac_op_assign_vif_chanctx(struct
 
 		/* If vif is already assigned, but now the chan is different and belongs
 		 * to a different ar, then delete the old vdev in different ar and create new
+		 * This is not expected for MLO
 		 */
 		if (ar != arvif->ar) {
 			if (WARN_ON(arvif->is_started)) {
@@ -9451,13 +10000,13 @@ ath12k_mac_op_assign_vif_chanctx(struct
 			arvif_ar = arvif->ar;
 
 			mutex_lock(&arvif_ar->conf_mutex);
-			ret = ath12k_mac_vdev_delete(arvif_ar, vif);
+			ret = ath12k_mac_vdev_delete(arvif_ar, arvif);
 			mutex_unlock(&arvif_ar->conf_mutex);
 			if (ret)
 				ath12k_warn(arvif_ar->ab, "unable to delete vdev %d\n", ret);
 
 			mutex_lock(&ar->conf_mutex);
-			ret = ath12k_mac_vdev_create(ar, vif);
+			ret = ath12k_mac_vdev_create(ar, arvif);
 			if (ret) {
 				mutex_unlock(&ar->conf_mutex);
 				mutex_unlock(&ah->conf_mutex);
@@ -9477,8 +10026,8 @@ ath12k_mac_op_assign_vif_chanctx(struct
 		   ctx, arvif->vdev_id);
 
 	if (ar->supports_6ghz && ctx->def.chan->band == NL80211_BAND_6GHZ &&
-            (arvif->vdev_type == WMI_VDEV_TYPE_STA ||
-             arvif->vdev_type == WMI_VDEV_TYPE_AP)) {
+            (ahvif->vdev_type == WMI_VDEV_TYPE_STA ||
+             ahvif->vdev_type == WMI_VDEV_TYPE_AP)) {
                 power_type = vif->bss_conf.power_type;
                 ath12k_dbg(ab, ATH12K_DBG_MAC, "mac chanctx power type %d\n",
                            power_type);
@@ -9489,16 +10038,16 @@ ath12k_mac_op_assign_vif_chanctx(struct
 		/* TODO: Transmit Power Envelope specification for 320 is not
                  * available yet. Need to add TPE 320 support when spec is ready
                  */
-                if (arvif->vdev_type == WMI_VDEV_TYPE_STA &&
+                if (ahvif->vdev_type == WMI_VDEV_TYPE_STA &&
 		    ctx->def.width != NL80211_CHAN_WIDTH_320) {
-                        ath12k_mac_parse_tx_pwr_env(ar, vif, ctx);
+                        ath12k_mac_parse_tx_pwr_env(ar, arvif, ctx);
 		}
         }
 
 	/* for some targets bss peer must be created before vdev_start */
 	if (ab->hw_params->vdev_start_delay &&
-	    arvif->vdev_type != WMI_VDEV_TYPE_AP &&
-	    arvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
+	    ahvif->vdev_type != WMI_VDEV_TYPE_AP &&
+	    ahvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
 	    !ath12k_peer_find_by_vdev_id(ab, arvif->vdev_id)) {
 		memcpy(&arvif->chanctx, ctx, sizeof(*ctx));
 		ret = 0;
@@ -9511,8 +10060,8 @@ ath12k_mac_op_assign_vif_chanctx(struct
 	}
 
 	if (ab->hw_params->vdev_start_delay &&
-	    (arvif->vdev_type == WMI_VDEV_TYPE_AP ||
-	     arvif->vdev_type == WMI_VDEV_TYPE_MONITOR)) {
+	    (ahvif->vdev_type == WMI_VDEV_TYPE_AP ||
+	     ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR)) {
 		param.vdev_id = arvif->vdev_id;
 		param.peer_type = WMI_PEER_TYPE_DEFAULT;
 		param.peer_addr = ar->mac_addr;
@@ -9525,7 +10074,7 @@ ath12k_mac_op_assign_vif_chanctx(struct
 		}
 	}
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
 		ret = ath12k_mac_monitor_start(ar);
 		if (ret)
 			goto out;
@@ -9536,12 +10085,12 @@ ath12k_mac_op_assign_vif_chanctx(struct
 	ret = ath12k_mac_vdev_start(arvif, &ctx->def, ctx->radar_enabled);
 	if (ret) {
 		ath12k_warn(ab, "failed to start vdev %i addr %pM on freq %d: %d\n",
-			    arvif->vdev_id, vif->addr,
+			    arvif->vdev_id, arvif->addr,
 			    ctx->def.chan->center_freq, ret);
 		goto out;
 	}
 
-	if (arvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
+	if (ahvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
 	    test_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags))
 		ath12k_mac_monitor_start(ar);
 
@@ -9564,11 +10113,14 @@ ath12k_mac_op_unassign_vif_chanctx(struc
 				   struct ieee80211_bss_conf *link_conf,
 				   struct ieee80211_chanctx_conf *ctx)
 {
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
+	struct ath12k_link_vif *arvif;
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k_base *ab;
 	struct ath12k *ar;
 	int ret;
+	/* TODO tmp, link_id passed through func */
+	u8 link_id = 0;
 
 	mutex_lock(&ah->conf_mutex);
 	/* The vif is expected to be attached to an ar's VDEV.
@@ -9578,7 +10130,17 @@ ath12k_mac_op_unassign_vif_chanctx(struc
 	 * remove_interface() or when there is a change in channel
 	 * that moves the vif to a new ar
 	 */
-	ar = ath12k_get_ar_by_vif(hw, vif);
+	arvif = ahvif->link[link_id];
+
+	if (!arvif) {
+		ath12k_err(NULL,
+			   "unable to determine the assigned link vif on link id %d\n",
+			   link_id);
+		mutex_unlock(&ah->conf_mutex);
+		return;
+	}
+
+	ar = arvif->ar;
 	if (!ar) {
 		ath12k_err(NULL,
 			   "unable to determine device to stop vdev during channel unassign\n");
@@ -9597,11 +10159,11 @@ ath12k_mac_op_unassign_vif_chanctx(struc
 	WARN_ON(!arvif->is_started);
 
 	if (ab->hw_params->vdev_start_delay &&
-	    arvif->vdev_type == WMI_VDEV_TYPE_MONITOR &&
+	    ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR &&
 	    ath12k_peer_find_by_addr(ab, ar->mac_addr))
 		ath12k_peer_delete(ar, arvif->vdev_id, ar->mac_addr);
 
-	if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
 		ret = ath12k_mac_monitor_stop(ar);
 		if (ret)
 			goto out;
@@ -9618,10 +10180,10 @@ ath12k_mac_op_unassign_vif_chanctx(struc
 	arvif->is_started = false;
 
 	if (ab->hw_params->vdev_start_delay &&
-	    arvif->vdev_type == WMI_VDEV_TYPE_MONITOR)
+	    ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR)
 		ath12k_wmi_vdev_down(ar, arvif->vdev_id);
 
-	if (arvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
+	if (ahvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
 	    ar->num_started_vdevs == 1 &&
 	    test_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags))
 		ath12k_mac_monitor_stop(ar);
@@ -9672,7 +10234,7 @@ ath12k_mac_op_switch_vif_chanctx(struct
 static int
 ath12k_set_vdev_param_to_all_vifs(struct ath12k *ar, int param, u32 value)
 {
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	int ret = 0;
 
 	mutex_lock(&ar->conf_mutex);
@@ -9780,7 +10342,8 @@ static void ath12k_mac_op_flush(struct i
 			ar++;
 		}
 	} else {
-		ar = ath12k_get_ar_by_vif(hw, vif);
+		/* TODO in case of ML links, flush all link vif */
+		ar = ath12k_get_ar_by_vif(hw, vif, 0);
 		if (!ar) {
 			ath12k_err(NULL,
 				   "unable to determine device for tx flush\n");
@@ -9982,15 +10545,31 @@ ath12k_mac_get_single_legacy_rate(struct
 }
 
 static int
-ath12k_mac_set_fixed_rate_GI_LTF(struct ath12k_vif *arvif, u8 gi, u8 ltf)
+ath12k_mac_set_fixed_rate_GI_LTF(struct ath12k_link_vif *arvif, u8 gi, u8 ltf)
 {
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
+	struct ieee80211_bss_conf *link_conf;
 	struct ath12k *ar = arvif->ar;
 	int param, ret;
+	bool eht_support;
 
 	/* 0.8 = 0, 1.6 = 2 and 3.2 = 3. */
 	if (gi && gi != 0xFF)
 		gi += 1;
 
+	rcu_read_lock();
+
+	link_conf = rcu_dereference(vif->link_conf[arvif->link_id]);
+
+	if (!link_conf) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
+
+	eht_support = link_conf->eht_support;
+
+	rcu_read_unlock();
+
 	ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
 					    WMI_VDEV_PARAM_SGI, gi);
 	if (ret) {
@@ -10002,7 +10581,7 @@ ath12k_mac_set_fixed_rate_GI_LTF(struct
 	if (ltf != 0xFF)
 		ltf += 1;
 
-	if (arvif->vif->bss_conf.eht_support)
+	if (eht_support)
 		param = WMI_VDEV_PARAM_EHT_LTF;
 	else
 		param = WMI_VDEV_PARAM_HE_LTF;
@@ -10019,7 +10598,7 @@ ath12k_mac_set_fixed_rate_GI_LTF(struct
 }
 
 static int
-ath12k_mac_set_auto_rate_GI_LTF(struct ath12k_vif *arvif, u16 gi, u8 ltf)
+ath12k_mac_set_auto_rate_GI_LTF(struct ath12k_link_vif *arvif, u16 gi, u8 ltf)
 {
 	struct ath12k *ar = arvif->ar;
 	int ret;
@@ -10075,19 +10654,36 @@ ath12k_mac_set_auto_rate_GI_LTF(struct a
 	return 0;
 }
 
-static int ath12k_mac_set_rate_params(struct ath12k_vif *arvif,
+static int ath12k_mac_set_rate_params(struct ath12k_link_vif *arvif,
 				      u32 rate, u8 nss, u8 sgi, u8 ldpc,
 				      u8 he_gi, u8 he_ltf, bool he_fixed_rate,
 				      u8 eht_gi, u8 eht_ltf,
 				      bool eht_fixed_rate,
 				      int he_ul_rate, u8 he_ul_nss)
 {
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
+	struct ieee80211_bss_conf *link_conf;
 	struct ath12k *ar = arvif->ar;
 	u32 vdev_param, rate_code;
 	int ret;
+	bool he_support, eht_support;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
+	rcu_read_lock();
+
+	link_conf = rcu_dereference(vif->link_conf[arvif->link_id]);
+
+	if (!link_conf) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
+
+	eht_support = link_conf->eht_support;
+	he_support = link_conf->he_support;
+
+	rcu_read_unlock();
+
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
 		   "mac set rate params vdev %i, rate:0x%02x, nss:0x%02x, sgi:0x%02x, ldpc:0x%02x\n",
 		   arvif->vdev_id, rate, nss, sgi, ldpc);
@@ -10100,7 +10696,7 @@ static int ath12k_mac_set_rate_params(st
 		   "eht_gi:0x%02x, eht_ltf:0x%02x, eht_fixed_rate:%d\n", eht_gi,
 		   eht_ltf, eht_fixed_rate);
 
-	if (!arvif->vif->bss_conf.he_support || !arvif->vif->bss_conf.eht_support) {
+	if (!he_support || !eht_support) {
 		vdev_param = WMI_VDEV_PARAM_FIXED_RATE;
 		ret = ath12k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
 						    vdev_param, rate);
@@ -10129,7 +10725,7 @@ static int ath12k_mac_set_rate_params(st
 		return ret;
 	}
 
-	if (arvif->vif->bss_conf.eht_support) {
+	if (eht_support) {
 		if (eht_fixed_rate) {
 			ret = ath12k_mac_set_fixed_rate_GI_LTF(arvif, eht_gi,
 							       eht_ltf);
@@ -10139,7 +10735,7 @@ static int ath12k_mac_set_rate_params(st
 		}
 		if (ret)
 			return ret;
-	} else if (arvif->vif->bss_conf.he_support) {
+	} else if (he_support) {
 		if (he_fixed_rate) {
 			ret = ath12k_mac_set_fixed_rate_GI_LTF(arvif, he_gi,
 							       he_ltf);
@@ -10277,13 +10873,21 @@ ath12k_mac_eht_mcs_range_present(struct
 static void ath12k_mac_set_bitrate_mask_iter(void *data,
 					     struct ieee80211_sta *sta)
 {
-	struct ath12k_vif *arvif = data;
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_vif *arvif = data;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta;
 	struct ath12k *ar = arvif->ar;
+	u8 link_id = arvif->link_id;
+
+	if (ahsta->ahvif != arvif->ahvif)
+		return;
 
-	if (arsta->arvif != arvif)
+	/* Check if there is a link sta in the vif link */
+	if (!(BIT(link_id) & ahsta->links_map))
 		return;
 
+	arsta = ahsta->link[link_id];
+
 	spin_lock_bh(&ar->data_lock);
 	arsta->changed |= IEEE80211_RC_SUPP_RATES_CHANGED;
 	spin_unlock_bh(&ar->data_lock);
@@ -10294,14 +10898,22 @@ static void ath12k_mac_set_bitrate_mask_
 static void ath12k_mac_disable_peer_fixed_rate(void *data,
 					       struct ieee80211_sta *sta)
 {
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
-	struct ath12k_vif *arvif = data;
-	struct ath12k *ar = arvif->ar;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_vif *arvif = data;
+	struct ath12k *ar;
 	int ret;
+	u8 link_id = arvif->link_id;
 
-	if (arsta->arvif != arvif)
+	if (ahsta->ahvif != arvif->ahvif)
 		return;
 
+	/* Check if there is a link sta in the vif link */
+	if (!(BIT(link_id) & ahsta->links_map))
+		return;
+
+	ar = arvif->ar;
+
+	/* TODO move to sta->link addr */
 	ret = ath12k_wmi_set_peer_param(ar, sta->addr,
 					arvif->vdev_id,
 					WMI_PEER_PARAM_FIXED_RATE,
@@ -10384,13 +10996,25 @@ exit:
 }
 
 static bool
-ath12k_mac_check_fixed_rate_settings_for_mumimo(struct ath12k_vif *arvif, const u16 *vht_mcs_mask, const u16 *he_mcs_mask)
+ath12k_mac_check_fixed_rate_settings_for_mumimo(struct ath12k_link_vif *arvif,
+						const u16 *vht_mcs_mask,
+						const u16 *he_mcs_mask)
 {
 	struct ath12k *ar = arvif->ar;
 	struct ieee80211_he_cap_elem he_cap_elem = {0};
 	int nss_idx;
 	int he_nss;
 	int vht_nss;
+	struct ieee80211_bss_conf *link_conf;
+
+	rcu_read_lock();
+
+	link_conf = rcu_dereference(arvif->ahvif->vif->link_conf[arvif->link_id]);
+
+	if (!link_conf) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
 
 	vht_nss =  ath12k_mac_max_vht_nss(vht_mcs_mask);
 
@@ -10400,21 +11024,26 @@ ath12k_mac_check_fixed_rate_settings_for
 				continue;
 
 			if (arvif->vht_cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE) {
+				rcu_read_unlock();
 				ath12k_warn(ar->ab, "vht fixed NSS rate is allowed only when MU MIMO is disabled\n");
 				return false;
 			}
 		}
 	}
 
-	if (!arvif->vif->bss_conf.he_support)
+	if (!link_conf->he_support) {
+		rcu_read_unlock();
 		return true;
+	}
 
 	 he_nss =  ath12k_mac_max_he_nss(he_mcs_mask);
 
-	 if (he_nss == 1)
-		 return true;
+	 if (he_nss == 1) {
+		rcu_read_unlock();
+		return true;
+	}
 
-	 memcpy(&he_cap_elem, &arvif->vif->bss_conf.he_cap_elem, sizeof(he_cap_elem));
+	 memcpy(&he_cap_elem, &link_conf->he_cap_elem, sizeof(he_cap_elem));
 
 	 for (nss_idx = he_nss-1; nss_idx >= 0; nss_idx--) {
 		 if (he_mcs_mask[nss_idx])
@@ -10422,11 +11051,13 @@ ath12k_mac_check_fixed_rate_settings_for
 
 		 if ((he_cap_elem.phy_cap_info[2] & IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO) ||
 		      (he_cap_elem.phy_cap_info[4] & IEEE80211_HE_PHY_CAP4_MU_BEAMFORMER)) {
-			 ath12k_warn(ar->ab, "he fixed NSS rate is allowed only when MU MIMO is disabled\n");
-			 return false;
+			rcu_read_unlock();
+			ath12k_warn(ar->ab, "he fixed NSS rate is allowed only when MU MIMO is disabled\n");
+			return false;
 		 }
 	 }
 
+	 rcu_read_unlock();
 	 return true;
 }
 
@@ -10436,7 +11067,7 @@ ath12k_mac_op_set_bitrate_mask(struct ie
 			       const struct cfg80211_bitrate_mask *mask)
 {
 	struct ath12k_hw *ah = hw->priv;
-	struct ath12k_vif *arvif = (void *)vif->drv_priv;
+	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
 	struct cfg80211_chan_def def;
 	struct ath12k *ar;
 	enum nl80211_band band;
@@ -10459,13 +11090,23 @@ ath12k_mac_op_set_bitrate_mask(struct ie
 	int he_ul_rate = -1;
 	bool he_fixed_rate = false;
 	bool eht_fixed_rate = false;
+	struct ath12k_link_vif *arvif;
+	/* TODO move after link id passed through this op */
+	u8 link_id = 0;
 
-	if (ath12k_mac_vif_chan(vif, &def))
+	if (ath12k_mac_vif_chan(vif, &def, link_id))
 		return -EPERM;
 
 	mutex_lock(&ah->conf_mutex);
 
-	ar = ath12k_get_ar_by_vif(hw, vif);
+	arvif = ahvif->link[link_id];
+
+	if (!arvif) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ar = ath12k_get_ar_by_vif(hw, vif, link_id);
 	if (!ar) {
 		ath12k_err(NULL,
 			   "unable to determine device to set bitrates, configs can be applied after device bringup\n");
@@ -10781,14 +11422,14 @@ exit:
 }
 
 void ath12k_mac_ap_ps_recalc(struct ath12k *ar) {
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	enum ath12k_ap_ps_state state = ATH12K_AP_PS_STATE_OFF;
 	int ret;
 	bool allow_ap_ps = true;
 
 	lockdep_assert_held(&ar->conf_mutex);
 	list_for_each_entry(arvif, &ar->arvifs, list) {
-		if (arvif->vdev_type != WMI_VDEV_TYPE_AP) {
+		if (arvif->ahvif->vdev_type != WMI_VDEV_TYPE_AP) {
 			allow_ap_ps = false;
 			break;
 		}
@@ -10818,7 +11459,10 @@ static void ath12k_mac_op_sta_statistics
 					 struct ieee80211_sta *sta,
 					 struct station_info *sinfo)
 {
-	struct ath12k_sta *arsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_sta *arsta = &ahsta->deflink;
+
+	/* TODO accumulate link sta stats here? */
 
 	sinfo->rx_duration = arsta->rx_duration;
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);
@@ -10856,7 +11500,8 @@ static const struct ieee80211_ops ath12k
 	.remove_interface		= ath12k_mac_op_remove_interface,
 	.update_vif_offload		= ath12k_mac_op_update_vif_offload,
 	.config                         = ath12k_mac_op_config,
-	.bss_info_changed               = ath12k_mac_op_bss_info_changed,
+	.link_info_changed              = ath12k_mac_op_bss_info_changed,
+	.vif_cfg_changed		= ath12k_mac_op_vif_cfg_changed,
 	.configure_filter		= ath12k_mac_op_configure_filter,
 	.hw_scan                        = ath12k_mac_op_hw_scan,
 	.cancel_hw_scan                 = ath12k_mac_op_cancel_hw_scan,
@@ -11547,6 +12192,9 @@ static int ath12k_mac_hw_register(struct
 	hw->wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |
 			       NL80211_FEATURE_AP_SCAN;
 
+	if (ag->mlo_capable)
+		hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_MLO;
+
 	/* TODO Split queues per chip */
 	hw->queues = ATH12K_HW_MAX_QUEUES;
 	hw->wiphy->tx_queue_len = ATH12K_QUEUE_LEN;
--- a/drivers/net/wireless/ath/ath12k/mac.h
+++ b/drivers/net/wireless/ath/ath12k/mac.h
@@ -145,14 +145,14 @@ u8 ath12k_mac_hw_rate_to_idx(const struc
 void __ath12k_mac_scan_finish(struct ath12k *ar);
 void ath12k_mac_scan_finish(struct ath12k *ar);
 
-struct ath12k_vif *ath12k_mac_get_arvif(struct ath12k *ar, u32 vdev_id);
-struct ath12k_vif *ath12k_mac_get_arvif_by_vdev_id(struct ath12k_base *ab,
+struct ath12k_link_vif *ath12k_mac_get_arvif(struct ath12k *ar, u32 vdev_id);
+struct ath12k_link_vif *ath12k_mac_get_arvif_by_vdev_id(struct ath12k_base *ab,
 						   u32 vdev_id);
 struct ath12k *ath12k_mac_get_ar_by_vdev_id(struct ath12k_base *ab, u32 vdev_id);
 struct ath12k *ath12k_mac_get_ar_by_pdev_id(struct ath12k_base *ab, u32 pdev_id);
 
 void ath12k_mac_fill_reg_tpc_info(struct ath12k *ar,
-                                  struct ieee80211_vif *vif,
+                                  struct ath12k_link_vif *arvif,
                                   struct ieee80211_chanctx_conf *ctx);
 void ath12k_mac_drain_tx(struct ath12k *ar);
 void ath12k_mac_peer_cleanup_all(struct ath12k *ar);
@@ -166,8 +166,9 @@ enum hal_encrypt_type ath12k_dp_tx_get_e
 void ath12k_mac_get_any_chandef_iter(struct ieee80211_hw *hw,
                                      struct ieee80211_chanctx_conf *conf,
                                      void *data);
-void ath12k_mac_bcn_tx_event(struct ath12k_vif *arvif);
-struct ath12k *ath12k_get_ar_by_vif(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+void ath12k_mac_bcn_tx_event(struct ath12k_link_vif *arvif);
+struct ath12k *ath12k_get_ar_by_vif(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+				    u8 link_id);
 int ath12k_mac_mlo_setup(struct ath12k_hw *ah);
 int ath12k_mac_mlo_ready(struct ath12k_hw *ah);
 int ath12k_mac_mlo_teardown(struct ath12k_hw *ah);
--- a/drivers/net/wireless/ath/ath12k/peer.c
+++ b/drivers/net/wireless/ath/ath12k/peer.c
@@ -263,12 +263,14 @@ static int ath12k_wait_for_peer_created(
 	return ath12k_wait_for_peer_common(ar->ab, vdev_id, addr, true);
 }
 
-int ath12k_peer_create(struct ath12k *ar, struct ath12k_vif *arvif,
+int ath12k_peer_create(struct ath12k *ar, struct ath12k_link_vif *arvif,
 		       struct ieee80211_sta *sta, struct peer_create_params *param)
 {
 	struct ath12k_peer *peer;
-	struct ath12k_sta *arsta;
-	struct ieee80211_vif *vif = arvif->vif;
+	struct ath12k_sta *ahsta;
+	struct ath12k_link_sta *arsta;
+	u8 link_id = arvif->link_id;
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
 
 	int ret;
 
@@ -330,7 +332,7 @@ int ath12k_peer_create(struct ath12k *ar
 	peer->pdev_idx = ar->pdev_idx;
 	peer->sta = sta;
 
-	if (arvif->vif->type == NL80211_IFTYPE_STATION) {
+	if (vif->type == NL80211_IFTYPE_STATION) {
 		arvif->ast_hash = peer->ast_hash;
 		arvif->ast_idx = peer->hw_peer_id;
 	}
@@ -340,7 +342,9 @@ int ath12k_peer_create(struct ath12k *ar
 	peer->vif = vif;
 
 	if (sta) {
-		arsta = (struct ath12k_sta *)sta->drv_priv;
+		/* TODO handling for ML PEER */
+		ahsta = (struct ath12k_sta *)sta->drv_priv;
+		arsta = ahsta->link[link_id];
 		arsta->tcl_metadata |= FIELD_PREP(HTT_TCL_META_DATA_TYPE, 0) |
 				       FIELD_PREP(HTT_TCL_META_DATA_PEER_ID,
 						  peer->peer_id);
--- a/drivers/net/wireless/ath/ath12k/peer.h
+++ b/drivers/net/wireless/ath/ath12k/peer.h
@@ -63,7 +63,7 @@ struct ath12k_peer *ath12k_peer_find_by_
 struct ath12k_peer *ath12k_peer_find_by_id(struct ath12k_base *ab, int peer_id);
 void ath12k_peer_cleanup(struct ath12k *ar, u32 vdev_id);
 int ath12k_peer_delete(struct ath12k *ar, u32 vdev_id, u8 *addr);
-int ath12k_peer_create(struct ath12k *ar, struct ath12k_vif *arvif,
+int ath12k_peer_create(struct ath12k *ar, struct ath12k_link_vif *arvif,
 		       struct ieee80211_sta *sta, struct peer_create_params *param);
 int ath12k_wait_for_peer_delete_done(struct ath12k *ar, u32 vdev_id,
 				     const u8 *addr);
--- a/drivers/net/wireless/ath/ath12k/spectral.c
+++ b/drivers/net/wireless/ath/ath12k/spectral.c
@@ -156,7 +156,7 @@ static const struct rchan_callbacks rfs_
 
 static struct ath12k_vif *ath12k_spectral_get_vdev(struct ath12k *ar)
 {
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -174,7 +174,7 @@ static struct ath12k_vif *ath12k_spectra
 
 static int ath12k_spectral_scan_trigger(struct ath12k *ar)
 {
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	int ret;
 
 	lockdep_assert_held(&ar->conf_mutex);
@@ -205,7 +205,7 @@ static int ath12k_spectral_scan_config(s
 				       enum ath12k_spectral_mode mode)
 {
 	struct ath12k_wmi_vdev_spectral_conf_param param = { 0 };
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	int ret, count;
 
 	lockdep_assert_held(&ar->conf_mutex);
--- a/drivers/net/wireless/ath/ath12k/spectral.h
+++ b/drivers/net/wireless/ath/ath12k/spectral.h
@@ -42,7 +42,7 @@ struct ath12k_spectral {
 
 int ath12k_spectral_init(struct ath12k_base *ab);
 void ath12k_spectral_deinit(struct ath12k_base *ab);
-int ath12k_spectral_vif_stop(struct ath12k_vif *arvif);
+int ath12k_spectral_vif_stop(struct ath12k_link_vif *arvif);
 void ath12k_spectral_reset_buffer(struct ath12k *ar);
 enum ath12k_spectral_mode ath12k_spectral_get_mode(struct ath12k *ar);
 struct ath12k_dbring *ath12k_spectral_get_dbring(struct ath12k *ar);
@@ -58,7 +58,7 @@ static inline void ath12k_spectral_deini
 {
 }
 
-static inline int ath12k_spectral_vif_stop(struct ath12k_vif *arvif)
+static inline int ath12k_spectral_vif_stop(struct ath12k_link_vif *arvif)
 {
 	return 0;
 }
--- a/drivers/net/wireless/ath/ath12k/testmode.c
+++ b/drivers/net/wireless/ath/ath12k/testmode.c
@@ -439,7 +439,8 @@ int ath12k_tm_cmd(struct ieee80211_hw *h
 
 	mutex_lock(&ah->conf_mutex);
 
-	ar = ath12k_get_ar_by_vif(hw, vif);
+	/* TODO cmd for all ML vifs */
+	ar = ath12k_get_ar_by_vif(hw, vif, 0);
 	ab = ar->ab;
 	if (!ar) {
 		mutex_unlock(&ah->conf_mutex);
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -5728,7 +5728,7 @@ static int wmi_process_mgmt_tx_comp(stru
 	struct ath12k_skb_cb *skb_cb;
 	struct ieee80211_hdr *hdr;
 	struct ieee80211_vif *vif;
-	struct ath12k_vif *arvif;
+	struct ath12k_vif *ahvif;
 	struct ath12k_mgmt_frame_stats *mgmt_stats;
 	u16 frm_type;
 	int num_mgmt;
@@ -5762,8 +5762,8 @@ static int wmi_process_mgmt_tx_comp(stru
 			goto skip_mgmt_stats;
 		}
 
-	        arvif = ath12k_vif_to_arvif(vif);
-		mgmt_stats = &arvif->mgmt_stats;
+	        ahvif = ath12k_vif_to_ahvif(vif);
+		mgmt_stats = &ahvif->mgmt_stats;
 
 		if (!status)
 			mgmt_stats->tx_compl_succ[frm_type]++;
@@ -6595,7 +6595,7 @@ ath12k_wmi_fw_vdev_stats_fill(struct ath
 {
 	u32 len = *length;
 	u32 buf_len = ATH12K_FW_STATS_BUF_SIZE;
-	struct ath12k_vif *arvif = ath12k_mac_get_arvif(ar, vdev->vdev_id);
+	struct ath12k_link_vif *arvif = ath12k_mac_get_arvif(ar, vdev->vdev_id);
 	u8 *vif_macaddr;
 	int i;
 
@@ -6605,7 +6605,7 @@ ath12k_wmi_fw_vdev_stats_fill(struct ath
 	if (!arvif)
 		return;
 
-	vif_macaddr = arvif->vif->addr;
+	vif_macaddr = arvif->addr;
 
 	len += scnprintf(buf + len, buf_len - len, "%30s %u\n",
 			 "VDEV ID", vdev->vdev_id);
@@ -6691,7 +6691,7 @@ ath12k_wmi_fw_bcn_stats_fill(struct ath1
 {
 	u32 len = *length;
 	u32 buf_len = ATH12K_FW_STATS_BUF_SIZE;
-	struct ath12k_vif *arvif = ath12k_mac_get_arvif(ar, bcn->vdev_id);
+	struct ath12k_link_vif *arvif = ath12k_mac_get_arvif(ar, bcn->vdev_id);
 	u8 *vdev_macaddr;
 
 	if (!arvif) {
@@ -6700,7 +6700,7 @@ ath12k_wmi_fw_bcn_stats_fill(struct ath1
 		return;
 	}
 
-	vdev_macaddr = arvif->vif->addr;
+	vdev_macaddr = arvif->addr;
 
 	len += scnprintf(buf + len, buf_len - len, "%30s %u\n",
 			 "VDEV ID", bcn->vdev_id);
@@ -7111,7 +7111,7 @@ static void ath12k_vdev_start_resp_event
 
 static void ath12k_bcn_tx_status_event(struct ath12k_base *ab, struct sk_buff *skb)
 {
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	u32 vdev_id, tx_status;
 
 	if (ath12k_pull_bcn_tx_status_ev(ab, skb->data, skb->len,
@@ -7168,7 +7168,7 @@ static void ath12k_mgmt_rx_event(struct
 	struct ieee80211_supported_band *sband;
 	struct ath12k_peer *peer;
 	struct ieee80211_vif *vif;
-	struct ath12k_vif *arvif;
+	struct ath12k_vif *ahvif;
 	struct ath12k_mgmt_frame_stats *mgmt_stats;
 	u16 frm_type = 0;
 
@@ -7257,8 +7257,8 @@ static void ath12k_mgmt_rx_event(struct
 
 	spin_lock_bh(&ar->data_lock);
 
-	arvif = ath12k_vif_to_arvif(vif);
-	mgmt_stats = &arvif->mgmt_stats;
+	ahvif = ath12k_vif_to_ahvif(vif);
+	mgmt_stats = &ahvif->mgmt_stats;
 	mgmt_stats->rx_cnt[frm_type]++;
 
 	spin_unlock_bh(&ar->data_lock);
@@ -7840,7 +7840,8 @@ ath12k_wmi_process_csa_switch_count_even
 					  const u32 *vdev_ids)
 {
 	int i;
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
+	struct ieee80211_bss_conf *link_conf;
 
 	/* Finish CSA once the switch count becomes NULL */
 	if (ev->current_switch_count)
@@ -7855,9 +7856,14 @@ ath12k_wmi_process_csa_switch_count_even
 				    vdev_ids[i]);
 			continue;
 		}
+		link_conf = arvif->ahvif->vif->link_conf[arvif->link_id];
+ 
+		if (!link_conf)
+			continue;
 
-		if (arvif->is_up && arvif->vif->bss_conf.csa_active)
-			ieee80211_csa_finish(arvif->vif);
+		/* FIXME some changes are expected for ML vifs */
+		if (arvif->is_up && link_conf->csa_active)
+			ieee80211_csa_finish(arvif->ahvif->vif);
 	}
 	rcu_read_unlock();
 }
@@ -9072,7 +9078,7 @@ ath12k_wmi_obss_color_collision_event(st
 {
 	const void **tb;
 	const struct wmi_obss_color_collision_event *ev;
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	struct ath12k *ar;
 	int ret;
 
@@ -9461,13 +9467,15 @@ ath12k_wmi_send_unit_test_cmd(struct ath
 
 int ath12k_wmi_simulate_radar(struct ath12k *ar)
 {
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_vif *ahvif;
 	u32 dfs_args[DFS_MAX_TEST_ARGS];
 	struct wmi_unit_test_cmd wmi_ut;
 	bool arvif_found = false;
 
 	list_for_each_entry(arvif, &ar->arvifs, list) {
-		if (arvif->is_started && arvif->vdev_type == WMI_VDEV_TYPE_AP) {
+		ahvif = arvif->ahvif;
+		if (arvif->is_started && ahvif->vdev_type == WMI_VDEV_TYPE_AP) {
 			arvif_found = true;
 			break;
 		}
@@ -9496,7 +9504,8 @@ int ath12k_wmi_simulate_radar(struct ath
 
 int ath12k_wmi_simulate_awgn(struct ath12k *ar, u32 chan_bw_interference_bitmap)
 {
-        struct ath12k_vif *arvif;
+        struct ath12k_link_vif *arvif;
+	struct ath12k_vif *ahvif;
         u32 awgn_args[WMI_AWGN_MAX_TEST_ARGS];
         struct wmi_unit_test_cmd wmi_ut;
         bool arvif_found = false;
@@ -9507,7 +9516,8 @@ int ath12k_wmi_simulate_awgn(struct ath1
         }
 
         list_for_each_entry(arvif, &ar->arvifs, list) {
-                if (arvif->is_started && arvif->vdev_type == WMI_VDEV_TYPE_AP) {
+		ahvif = arvif->ahvif;
+                if (arvif->is_started && ahvif->vdev_type == WMI_VDEV_TYPE_AP) {
                         arvif_found = true;
                         break;
                 }
@@ -9533,7 +9543,7 @@ int ath12k_wmi_simulate_awgn(struct ath1
 
 int ath12k_wmi_pdev_m3_dump_enable(struct ath12k *ar, u32 enable)
 {
-	struct ath12k_vif *arvif;
+	struct ath12k_link_vif *arvif;
 	u32 m3_args[WMI_M3_MAX_TEST_ARGS];
 	struct wmi_unit_test_cmd wmi_ut;
 	bool arvif_found = false;
