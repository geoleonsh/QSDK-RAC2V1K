From 12ce51423d768da650db9c76c5b67a8d2e86ff8c Mon Sep 17 00:00:00 2001
From: Sowmiya Sree Elavalagan <ssreeela@codeaurora.org>
Date: Tue, 22 Dec 2020 20:08:37 +0530
Subject: [PATCH] ath11k: qcn6122 bring up

Add qcn6122 platform support.
qcn6122 is a hybrid bus type device which is enumerated as
pci device by Q6 and enumerates as ahb device on host.
It uses qgic interrupts to notify events to host driver.
Used qgic api to convert MSI interrupt to qgic interrupt.
Added qmi message to learn bar address from qcn6122.
Test performed:
Ran ping test for open, ccmp and tkip modes.
Ran iperf traffic for few mins.

Signed-off-by: Sowmiya Sree Elavalagan <ssreeela@codeaurora.org>
---
 drivers/net/wireless/ath/ath11k/ahb.c   | 190 +++++++++++++++++++++----
 drivers/net/wireless/ath/ath11k/ce.c    |   2 +-
 drivers/net/wireless/ath/ath11k/core.c  |  80 +++++++++--
 drivers/net/wireless/ath/ath11k/core.h  |  11 ++
 drivers/net/wireless/ath/ath11k/debugfs.c |   7 +-
 drivers/net/wireless/ath/ath11k/hal.h   |   1 -
 drivers/net/wireless/ath/ath11k/hif.h   |  33 +++++
 drivers/net/wireless/ath/ath11k/hw.c    | 117 +++++++++++++++
 drivers/net/wireless/ath/ath11k/hw.h    |   3 +
 drivers/net/wireless/ath/ath11k/mhi.c   |   6 +-
 drivers/net/wireless/ath/ath11k/nss.c   |   3 +
 drivers/net/wireless/ath/ath11k/nss.h   |   1 +
 drivers/net/wireless/ath/ath11k/pci.c   | 243 +++++++++++++++++++++-----------
 drivers/net/wireless/ath/ath11k/pci.h   |  62 +++++++-
 drivers/net/wireless/ath/ath11k/qmi.c   | 178 ++++++++++++++++++++++-
 drivers/net/wireless/ath/ath11k/qmi.h   |  23 ++-
 16 files changed, 828 insertions(+), 132 deletions(-)

--- a/drivers/net/wireless/ath/ath11k/ahb.c
+++ b/drivers/net/wireless/ath/ath11k/ahb.c
@@ -34,6 +34,9 @@ static const struct of_device_id ath11k_
 	{ .compatible = "qcom,ipq5018-wifi",
 	  .data = (void *)ATH11K_HW_IPQ5018,
 	},
+	{ .compatible = "qcom,qcn6122-wifi",
+	  .data = (void *)ATH11K_HW_QCN6122,
+	},
 	{ }
 };
 
@@ -139,46 +142,35 @@ enum ext_irq_num {
 };
 
 static int
-ath11k_ahb_get_msi_irq_wcn6750(struct ath11k_base *ab, unsigned int vector)
+ath11k_ahb_get_msi_irq(struct ath11k_base *ab, unsigned int vector)
 {
 	return ab->pci.msi.irqs[vector];
 }
 
-static inline u32
-ath11k_ahb_get_window_start_wcn6750(struct ath11k_base *ab, u32 offset)
+static u32 ath11k_ahb_get_window_start(struct ath11k_base *ab, u32 offset)
 {
-	u32 window_start = 0;
-
-	/* If offset lies within DP register range, use 1st window */
-	if ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) < ATH11K_PCI_WINDOW_RANGE_MASK)
-		window_start = ATH11K_PCI_WINDOW_START;
-	/* If offset lies within CE register range, use 2nd window */
-	else if ((offset ^ HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab)) <
-		 ATH11K_PCI_WINDOW_RANGE_MASK)
-		window_start = 2 * ATH11K_PCI_WINDOW_START;
-
-	return window_start;
+	return ath11k_pcic_get_window_start(ab, offset, ATH11K_BUS_AHB);
 }
 
 static void
-ath11k_ahb_window_write32_wcn6750(struct ath11k_base *ab, u32 offset, u32 value)
+ath11k_ahb_window_write32(struct ath11k_base *ab, u32 offset, u32 value)
 {
 	u32 window_start;
 
 	/* WCN6750 uses static window based register access*/
-	window_start = ath11k_ahb_get_window_start_wcn6750(ab, offset);
+	window_start = ath11k_ahb_get_window_start(ab, offset);
 
 	iowrite32(value, ab->mem + window_start +
 		  (offset & ATH11K_PCI_WINDOW_RANGE_MASK));
 }
 
-static u32 ath11k_ahb_window_read32_wcn6750(struct ath11k_base *ab, u32 offset)
+static u32 ath11k_ahb_window_read32(struct ath11k_base *ab, u32 offset)
 {
 	u32 window_start;
 	u32 val;
 
 	/* WCN6750 uses static window based register access */
-	window_start = ath11k_ahb_get_window_start_wcn6750(ab, offset);
+	window_start = ath11k_ahb_get_window_start(ab, offset);
 
 	val = ioread32(ab->mem + window_start +
 		       (offset & ATH11K_PCI_WINDOW_RANGE_MASK));
@@ -188,11 +180,20 @@ static u32 ath11k_ahb_window_read32_wcn6
 static const struct ath11k_pci_ops ath11k_ahb_pci_ops_wcn6750 = {
 	.wakeup = NULL,
 	.release = NULL,
-	.get_msi_irq = ath11k_ahb_get_msi_irq_wcn6750,
-	.window_write32 = ath11k_ahb_window_write32_wcn6750,
-	.window_read32 = ath11k_ahb_window_read32_wcn6750,
+	.get_msi_irq = ath11k_ahb_get_msi_irq,
+	.window_write32 = ath11k_ahb_window_write32,
+	.window_read32 = ath11k_ahb_window_read32,
 };
 
+static const struct ath11k_pci_ops ath11k_ahb_pci_ops_qcn6122 = {
+	.wakeup = NULL,
+	.release = NULL,
+	.get_msi_irq = ath11k_ahb_get_msi_irq,
+	.window_write32 = ath11k_ahb_window_write32,
+	.window_read32 = ath11k_ahb_window_read32,
+};
+
+
 static inline u32 ath11k_ahb_read32(struct ath11k_base *ab, u32 offset)
 {
 	if (ab->ce_remap && (offset & HAL_CE_REMAP_REG_BASE)) {
@@ -449,6 +450,7 @@ static void ath11k_ahb_init_qmi_ce_confi
 	cfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;
 	cfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;
 	ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
+	ab->qmi.service_ins_id += ab->userpd_id;
 }
 
 static void ath11k_ahb_free_ext_irq(struct ath11k_base *ab)
@@ -470,6 +472,9 @@ static void ath11k_ahb_free_irq(struct a
 	int irq_idx;
 	int i;
 
+	if (ab->hw_params.internal_pci)
+		return ath11k_pcic_ipci_free_irq(ab);
+
 	if (ab->hw_params.hybrid_bus_type)
 		return ath11k_pcic_free_irq(ab);
 
@@ -633,6 +638,9 @@ static int ath11k_ahb_config_irq(struct
 	int irq, irq_idx, i;
 	int ret;
 
+	if (ab->hw_params.internal_pci)
+		return ath11k_pcic_ipci_config_irq(ab);
+
 	if (ab->hw_params.hybrid_bus_type)
 		return ath11k_pcic_config_irq(ab);
 
@@ -760,6 +768,27 @@ static const struct ath11k_hif_ops ath11
 	.power_up = ath11k_ahb_power_up,
 };
 
+static const struct ath11k_hif_ops ath11k_ahb_hif_ops_qcn6122 = {
+	.start = ath11k_pcic_start,
+	.stop = ath11k_pcic_stop,
+	.read32 = ath11k_pcic_read32,
+	.write32 = ath11k_pcic_write32,
+	.power_down = ath11k_ahb_power_down,
+	.power_up = ath11k_ahb_power_up,
+	.irq_enable = ath11k_pcic_ext_irq_enable,
+	.irq_disable = ath11k_pcic_ext_irq_disable,
+	.get_msi_address =  ath11k_pcic_get_msi_address,
+	.get_user_msi_vector = ath11k_pcic_get_user_msi_assignment,
+	.map_service_to_pipe = ath11k_pcic_map_service_to_pipe,
+	.get_ce_msi_idx = ath11k_pcic_get_ce_msi_idx,
+	.config_static_window = ath11k_pcic_config_static_window,
+	.get_window_offset = ath11k_pci_get_window_offset,
+#ifdef CONFIG_QCOM_QMI_HELPERS
+	.ssr_notifier_reg = ath11k_ahb_ssr_notifier_reg,
+	.ssr_notifier_unreg = ath11k_ahb_ssr_notifier_unreg,
+#endif
+};
+
 static int ath11k_core_get_rproc(struct ath11k_base *ab)
 {
 	struct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);
@@ -838,6 +867,11 @@ static int ath11k_ahb_setup_resources(st
 	struct resource *mem_res;
 	void __iomem *mem;
 
+	if (ab->hw_params.internal_pci) {
+		set_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags);
+		return 0;
+	}
+
 	if (ab->hw_params.hybrid_bus_type)
 		return ath11k_ahb_setup_msi_resources(ab);
 
@@ -1020,6 +1054,28 @@ static int ath11k_ahb_fw_resource_deinit
 	return 0;
 }
 
+static int ath11k_get_userpd_id(struct device *dev)
+{
+	int ret;
+	int userpd_id = 0;
+	const char *subsys_name;
+
+	ret = of_property_read_string(dev->of_node,
+				      "qcom,userpd-subsys-name",
+				      &subsys_name);
+	if (ret) {
+		dev_err(dev, "Not multipd architecture");
+		return 0;
+	}
+
+	if (strcmp(subsys_name, "q6v5_wcss_userpd2") == 0)
+		userpd_id = QCN6122_USERPD_0;
+	else if (strcmp(subsys_name, "q6v5_wcss_userpd3") == 0)
+		userpd_id = QCN6122_USERPD_1;
+
+	return userpd_id;
+}
+
 static int ath11k_ahb_probe(struct platform_device *pdev)
 {
 	struct ath11k_base *ab;
@@ -1028,7 +1084,7 @@ static int ath11k_ahb_probe(struct platf
 	const struct ath11k_hif_ops *hif_ops;
 	const struct ath11k_pci_ops *pci_ops;
 	enum ath11k_hw_rev hw_rev;
-	int ret;
+	int ret, userpd_id;
 	u32 hw_mode_id;
 
 	of_id = of_match_device(ath11k_ahb_of_match, &pdev->dev);
@@ -1050,11 +1106,16 @@ static int ath11k_ahb_probe(struct platf
 		hif_ops = &ath11k_ahb_hif_ops_wcn6750;
 		pci_ops = &ath11k_ahb_pci_ops_wcn6750;
 		break;
+	case ATH11K_HW_QCN6122:
+		hif_ops = &ath11k_ahb_hif_ops_qcn6122;
+		pci_ops = &ath11k_ahb_pci_ops_qcn6122;
+		break;
 	default:
 		dev_err(&pdev->dev, "unsupported device type %d\n", hw_rev);
 		return -EOPNOTSUPP;
 	}
 
+	userpd_id = ath11k_get_userpd_id(dev);
 	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
 	if (ret) {
 		dev_err(&pdev->dev, "failed to set 32-bit consistent dma\n");
@@ -1071,6 +1132,7 @@ static int ath11k_ahb_probe(struct platf
 	ab->hif.ops = hif_ops;
 	ab->pdev = pdev;
 	ab->hw_rev = hw_rev;
+	ab->userpd_id = userpd_id;
 	ab->fw_mode = ATH11K_FIRMWARE_MODE_NORMAL;
 	ab->enable_cold_boot_cal = ath11k_cold_boot_cal;
 	platform_set_drvdata(pdev, ab);
--- a/drivers/net/wireless/ath/ath11k/ce.c
+++ b/drivers/net/wireless/ath/ath11k/ce.c
@@ -217,7 +217,7 @@ const struct ce_attr ath11k_host_ce_conf
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
-		.dest_nentries = 32,
+		.dest_nentries = 128,
 		.recv_cb = ath11k_htc_rx_completion_handler,
 	},
 
@@ -548,7 +548,11 @@ static void ath11k_ce_srng_msi_ring_para
 
 	ring_params->msi_addr = addr_lo;
 	ring_params->msi_addr |= (dma_addr_t)(((uint64_t)addr_hi) << 32);
-	ring_params->msi_data = (msi_data_idx % msi_data_count) + msi_data_start;
+	if (ab->hw_params.internal_pci)
+		ring_params->msi_data = ab->ipci.ce_msi_data[ce_id];
+	else
+		ring_params->msi_data = (msi_data_idx % msi_data_count) + msi_data_start;
+
 	ring_params->flags |= HAL_SRNG_FLAGS_MSI_INTR;
 }
 
--- a/drivers/net/wireless/ath/ath11k/ce.h
+++ b/drivers/net/wireless/ath/ath11k/ce.h
@@ -7,6 +7,7 @@
 #define ATH11K_CE_H
 
 #define CE_COUNT_MAX 12
+#define ATH11K_QCN6122_CE_COUNT	6
 
 /* Byte swap data words */
 #define CE_ATTR_BYTE_SWAP_DATA 2
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@ -580,6 +580,8 @@ static const struct ath11k_hw_params ath
 		.hybrid_bus_type = true,
 		.fixed_fw_mem = true,
 		.support_off_channel_tx = false,
+		.ce_window = 2,
+		.dp_window = 1,
 	},
 	{
 		.hw_rev = ATH11K_HW_IPQ5018,
@@ -595,7 +597,7 @@ static const struct ath11k_hw_params ath
 		.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),
 		.hw_ops = &ipq5018_ops,
 		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074,
-		.ring_mask = &ath11k_hw_ring_mask_ipq8074,
+		.ring_mask = &ath11k_hw_ring_mask_qcn6122,
 		.regs = &ipq5018_regs,
 		.m3_addr = ATH11K_QMI_IPQ5018_M3_DUMP_ADDRESS,
 		.credit_flow = false,
@@ -647,6 +649,76 @@ static const struct ath11k_hw_params ath
 		.fixed_fw_mem = false,
 		.support_off_channel_tx = false,
 	},
+	{
+		.hw_rev = ATH11K_HW_QCN6122,
+		.name = "qcn6122",
+		.fw = {
+			.dir = "qcn6122/hw1.0",
+			.board_size = 256 * 1024,
+			.cal_offset = 128 * 1024,
+		},
+		.hal_params = &ath11k_hw_hal_params_ipq8074,
+		.max_radios = 1,
+		.bdf_addr = 0x4D200000,
+		/* hal_desc_sz is similar to qcn9074 */
+		.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),
+		.hw_ops = &qcn6122_ops,
+		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6122,
+		.ring_mask = &ath11k_hw_ring_mask_qcn6122,
+		.regs = &qcn6122_regs,
+		.num_dscp_tid_map_tbl = HAL_IPQ5018_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX,
+
+		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
+					BIT(NL80211_IFTYPE_AP) |
+					BIT(NL80211_IFTYPE_MESH_POINT),
+		.m3_addr = ATH11K_QMI_QCN6122_M3_DUMP_ADDRESS,
+		.spectral = {
+			.fft_sz = 2,
+			.fft_pad_sz = 0,
+			.summary_pad_sz = 16,
+			.fft_hdr_len = 24,
+			.max_fft_bins = 1024,
+		},
+		.credit_flow = false,
+		.supports_monitor = true,
+		.supports_shadow_regs = false,
+		.idle_ps = false,
+		.supports_suspend = false,
+		.host_ce_config = ath11k_host_ce_config_qcn9074,
+		.ce_count = 6,
+		.target_ce_config = ath11k_target_ce_config_wlan_ipq5018,
+		.target_ce_count = 9,
+		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq5018,
+		.svc_to_ce_map_len = 17,
+		.single_pdev_only = false,
+		.rxdma1_enable = true,
+		.num_rxmda_per_pdev = 1,
+		.rx_mac_buf_ring = false,
+		.vdev_start_delay = false,
+		.htt_peer_map_v2 = true,
+		.cold_boot_calib = true,
+		.fix_l1ss = true,
+		.alloc_cacheable_memory = true,
+		.m3_fw_support = false,
+		.fixed_bdf_addr = true,
+		.fixed_mem_region = true,
+		.static_window_map = true,
+		.hybrid_bus_type = false,
+		.internal_pci = true,
+		.ce_window = 2,
+		.dp_window = 3,
+		.fw_mem_mode = ATH11K_QMI_TARGET_MEM_MODE_512M,
+		.ce_fwlog_enable = false,
+		.fwmem_mode_change = false,
+		.supports_sta_ps = false,
+		.dbr_debug_support = true,
+		.bios_sar_capa = NULL,
+		.fixed_fw_mem = false,
+		.support_off_channel_tx = false,
+		.m3_offset = ATH11K_QMI_QCN6122_M3_OFFSET,
+		.qdss_offset = ATH11K_QMI_QCN6122_QDSS_OFFSET,
+		.caldb_offset = ATH11K_QMI_QCN6122_CALDB_OFFSET,
+ 	},
 };
 
 static const struct ath11k_num_vdevs_peers ath11k_vdevs_peers[] = {
--- a/drivers/net/wireless/ath/ath11k/core.h
+++ b/drivers/net/wireless/ath/ath11k/core.h
@@ -55,6 +55,9 @@ extern bool ath11k_collect_dump;
 #define ATH11K_RX_RATE_TABLE_NUM 320
 #define ATH11K_RX_RATE_TABLE_11AX_NUM 576
 
+#define QCN6122_USERPD_0               1
+#define QCN6122_USERPD_1               2
+
 /* SMBIOS type containing Board Data File Name Extension */
 #define ATH11K_SMBIOS_BDF_EXT_TYPE 0xF8
 
@@ -163,6 +166,7 @@ enum ath11k_hw_rev {
 	ATH11K_HW_WCN6855_HW21,
 	ATH11K_HW_WCN6750_HW10,
 	ATH11K_HW_IPQ5018,
+	ATH11K_HW_QCN6122,
 };
 
 enum ath11k_firmware_mode {
@@ -949,6 +953,14 @@ struct ath11k_num_vdevs_peers {
 	u32 num_peers;
 };
 
+struct ath11k_internal_pci {
+	bool gic_enabled;
+	wait_queue_head_t gic_msi_waitq;
+	u32 dp_msi_data[ATH11K_EXT_IRQ_GRP_NUM_MAX];
+	u32 ce_msi_data[ATH11K_QCN6122_CE_COUNT];
+	u32 dp_irq_num[8];
+};
+
 /* Master structure to hold the hw data which may be used in core module */
 struct ath11k_base {
 	enum ath11k_hw_rev hw_rev;
@@ -1013,6 +1025,8 @@ struct ath11k_base {
 	wait_queue_head_t peer_mapping_wq;
 	u8 mac_addr[ETH_ALEN];
 	bool wmi_ready;
+	int userpd_id;
+	struct ath11k_internal_pci ipci;
 	u32 wlan_init_status;
 	int irq_num[ATH11K_IRQ_NUM_MAX];
 	struct ath11k_ext_irq_grp ext_irq_grp[ATH11K_EXT_IRQ_GRP_NUM_MAX];
--- a/drivers/net/wireless/ath/ath11k/debugfs.c
+++ b/drivers/net/wireless/ath/ath11k/debugfs.c
@@ -1469,7 +1469,12 @@ int ath11k_debugfs_soc_create(struct ath
 		return 0;
 
 	if (ab->hif.bus == ATH11K_BUS_AHB) {
-		snprintf(soc_name, sizeof(soc_name), "%s", ab->hw_params.name);
+		if (ab->userpd_id)
+			snprintf(soc_name, sizeof(soc_name), "%s_%d",
+				 ab->hw_params.name, ab->userpd_id);
+		else
+			snprintf(soc_name, sizeof(soc_name), "%s",
+				 ab->hw_params.name);
 	} else {
 		snprintf(soc_name, sizeof(soc_name), "%s_%s",
 			 ab->hw_params.name, dev_name(dev));
--- a/drivers/net/wireless/ath/ath11k/dp.c
+++ b/drivers/net/wireless/ath/ath11k/dp.c
@@ -229,8 +229,12 @@ static void ath11k_dp_srng_msi_setup(str
 
 	ring_params->msi_addr = addr_lo;
 	ring_params->msi_addr |= (dma_addr_t)(((uint64_t)addr_hi) << 32);
-	ring_params->msi_data = (msi_group_number % msi_data_count)
+	if (ab->hw_params.internal_pci) {
+		ring_params->msi_data = ab->ipci.dp_msi_data[msi_group_number];
+	} else {
+		ring_params->msi_data = (msi_group_number % msi_data_count)
 		+ msi_data_start;
+	}
 	ring_params->flags |= HAL_SRNG_FLAGS_MSI_INTR;
 }
 
--- a/drivers/net/wireless/ath/ath11k/hif.h
+++ b/drivers/net/wireless/ath/ath11k/hif.h
@@ -34,6 +34,7 @@ struct ath11k_hif_ops {
 	void (*ssr_notifier_unreg)(struct ath11k_base *ab);
 #endif
 	u32 (*get_window_offset)(struct ath11k_base *ab, u32 offset);
+	void (*config_static_window)(struct ath11k_base *ab);
 };
 
 static inline void ath11k_hif_ce_irq_enable(struct ath11k_base *ab)
@@ -165,4 +166,12 @@ static inline void ath11k_hif_ssr_notifi
 	ab->hif.ops->ssr_notifier_unreg(ab);
 }
 #endif
+
+static inline void ath11k_hif_config_static_window(struct ath11k_base *ab)
+{
+	if (!ab->hif.ops->config_static_window)
+		return;
+
+	ab->hif.ops->config_static_window(ab);
+}
 #endif /* _HIF_H_ */
--- a/drivers/net/wireless/ath/ath11k/hw.c
+++ b/drivers/net/wireless/ath/ath11k/hw.c
@@ -1287,6 +1287,49 @@ const struct ath11k_hw_ops ipq5018_ops =
 	.rx_desc_get_hal_mpdu_len = ath11k_hw_qcn9074_rx_desc_get_hal_mpdu_len,
 };
 
+const struct ath11k_hw_ops qcn6122_ops = {
+	.get_hw_mac_from_pdev_id = ath11k_hw_ipq6018_mac_from_pdev_id,
+	.wmi_init_config = ath11k_init_wmi_config_ipq8074,
+	.mac_id_to_pdev_id = ath11k_hw_mac_id_to_pdev_id_ipq8074,
+	.mac_id_to_srng_id = ath11k_hw_mac_id_to_srng_id_ipq8074,
+	.rx_desc_mac_addr2_valid = ath11k_hw_ipq9074_rx_desc_mac_addr2_valid,
+	.rx_desc_mpdu_start_addr2 = ath11k_hw_ipq9074_rx_desc_mpdu_start_addr2,
+	.tx_mesh_enable = ath11k_hw_qcn9074_tx_mesh_enable,
+	.rx_desc_get_first_msdu = ath11k_hw_qcn9074_rx_desc_get_first_msdu,
+	.rx_desc_get_last_msdu = ath11k_hw_qcn9074_rx_desc_get_last_msdu,
+	.rx_desc_get_l3_pad_bytes = ath11k_hw_qcn9074_rx_desc_get_l3_pad_bytes,
+	.rx_desc_get_hdr_status = ath11k_hw_qcn9074_rx_desc_get_hdr_status,
+	.rx_desc_encrypt_valid = ath11k_hw_qcn9074_rx_desc_encrypt_valid,
+	.rx_desc_get_encrypt_type = ath11k_hw_qcn9074_rx_desc_get_encrypt_type,
+	.rx_desc_get_decap_type = ath11k_hw_qcn9074_rx_desc_get_decap_type,
+	.rx_desc_get_mesh_ctl = ath11k_hw_qcn9074_rx_desc_get_mesh_ctl,
+	.rx_desc_get_ldpc_support = ath11k_hw_qcn9074_rx_desc_get_ldpc_support,
+	.rx_desc_get_mpdu_seq_ctl_vld = ath11k_hw_qcn9074_rx_desc_get_mpdu_seq_ctl_vld,
+	.rx_desc_get_mpdu_fc_valid = ath11k_hw_qcn9074_rx_desc_get_mpdu_fc_valid,
+	.rx_desc_get_mpdu_start_seq_no = ath11k_hw_qcn9074_rx_desc_get_mpdu_start_seq_no,
+	.rx_desc_get_msdu_len = ath11k_hw_qcn9074_rx_desc_get_msdu_len,
+	.rx_desc_get_msdu_sgi = ath11k_hw_qcn9074_rx_desc_get_msdu_sgi,
+	.rx_desc_get_msdu_rate_mcs = ath11k_hw_qcn9074_rx_desc_get_msdu_rate_mcs,
+	.rx_desc_get_msdu_rx_bw = ath11k_hw_qcn9074_rx_desc_get_msdu_rx_bw,
+	.rx_desc_get_msdu_freq = ath11k_hw_qcn9074_rx_desc_get_msdu_freq,
+	.rx_desc_get_msdu_pkt_type = ath11k_hw_qcn9074_rx_desc_get_msdu_pkt_type,
+	.rx_desc_get_msdu_nss = ath11k_hw_qcn9074_rx_desc_get_msdu_nss,
+	.rx_desc_get_mpdu_tid = ath11k_hw_qcn9074_rx_desc_get_mpdu_tid,
+	.rx_desc_get_mpdu_peer_id = ath11k_hw_qcn9074_rx_desc_get_mpdu_peer_id,
+	.rx_desc_copy_attn_end_tlv = ath11k_hw_qcn9074_rx_desc_copy_attn_end,
+	.rx_desc_get_mpdu_start_tag = ath11k_hw_qcn9074_rx_desc_get_mpdu_start_tag,
+	.rx_desc_get_mpdu_ppdu_id = ath11k_hw_qcn9074_rx_desc_get_mpdu_ppdu_id,
+	.rx_desc_set_msdu_len = ath11k_hw_qcn9074_rx_desc_set_msdu_len,
+	.reo_setup = ath11k_hw_ipq5018_reo_setup,
+	.rx_desc_get_attention = ath11k_hw_qcn9074_rx_desc_get_attention,
+	.rx_desc_get_msdu_payload = ath11k_hw_qcn9074_rx_desc_get_msdu_payload,
+	.mpdu_info_get_peerid = ath11k_hw_ipq8074_mpdu_info_get_peerid,
+	.set_rx_fragmentation_dst_ring = ath11k_hw_ipq5018_set_rx_fragmentation_dst_ring,
+	.get_reo_dest_remap_config = ath11k_get_reo_dest_remap_config_5018,
+	.rx_desc_get_hal_mpdu_len = ath11k_hw_qcn9074_rx_desc_get_hal_mpdu_len,
+	.rx_desc_get_hal_ppdu_id = ath11k_hw_qcn9074_rx_desc_get_hal_mpdu_ppdu_id,
+};
+
 #define ATH11K_TX_RING_MASK_0 0x1
 #define ATH11K_TX_RING_MASK_1 0x2
 #define ATH11K_TX_RING_MASK_2 0x4
@@ -2095,6 +2138,43 @@ const struct service_to_pipe ath11k_targ
 	},
 };
 
+const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn6122 = {
+	.tx  = {
+		ATH11K_TX_RING_MASK_0,
+		ATH11K_TX_RING_MASK_1,
+		ATH11K_TX_RING_MASK_2,
+	},
+	.rx_mon_status = {
+		0, 0, 0,
+		ATH11K_RX_MON_STATUS_RING_MASK_0,
+	},
+	.rx = {
+		0, 0, 0, 0,
+		ATH11K_RX_RING_MASK_0,
+		ATH11K_RX_RING_MASK_1,
+		ATH11K_RX_RING_MASK_2,
+		ATH11K_RX_RING_MASK_3,
+	},
+	.rx_err = {
+		0, 0, 0, 0, 0, 0, 0, 0,
+		ATH11K_RX_ERR_RING_MASK_0,
+	},
+	.rx_wbm_rel = {
+		0, 0, 0, 0, 0, 0, 0, 0, 0,
+		ATH11K_RX_WBM_REL_RING_MASK_0,
+	},
+       .reo_status = {
+		0, 0, 0,
+		ATH11K_REO_STATUS_RING_MASK_0,
+	},
+	.rxdma2host = {
+		ATH11K_RXDMA2HOST_RING_MASK_0,
+	},
+	.host2rxdma = {
+		ATH11K_HOST2RXDMA_RING_MASK_0,
+	},
+};
+
 /* Target firmware's Copy Engine configuration for IPQ5018 */
 const struct ce_pipe_config ath11k_target_ce_config_wlan_ipq5018[] = {
 	/* CE0: host->target HTC control and raw streams */
@@ -2855,6 +2935,81 @@ const struct ath11k_hw_regs wcn6750_regs
 	.hal_reo1_misc_ctl = 0x000005d8,
 };
 
+const struct ath11k_hw_regs qcn6122_regs = {
+	/* SW2TCL(x) R0 ring configuration address */
+	.hal_tcl1_ring_base_lsb = 0x00000694,
+	.hal_tcl1_ring_base_msb = 0x00000698,
+	.hal_tcl1_ring_id = 0x0000069c,
+	.hal_tcl1_ring_misc = 0x000006a4,
+	.hal_tcl1_ring_tp_addr_lsb = 0x000006b0,
+	.hal_tcl1_ring_tp_addr_msb = 0x000006b4,
+	.hal_tcl1_ring_consumer_int_setup_ix0 = 0x000006c4,
+	.hal_tcl1_ring_consumer_int_setup_ix1 = 0x000006c8,
+	.hal_tcl1_ring_msi1_base_lsb = 0x000006dc,
+	.hal_tcl1_ring_msi1_base_msb = 0x000006e0,
+	.hal_tcl1_ring_msi1_data = 0x000006e4,
+	.hal_tcl2_ring_base_lsb = 0x000006ec,
+	.hal_tcl_ring_base_lsb = 0x0000079c,
+
+	/* TCL STATUS ring address */
+	.hal_tcl_status_ring_base_lsb = 0x000008a4,
+
+	/* REO2SW(x) R0 ring configuration address */
+	.hal_reo1_ring_base_lsb = 0x000001ec,
+	.hal_reo1_ring_base_msb = 0x000001f0,
+	.hal_reo1_ring_id = 0x000001f4,
+	.hal_reo1_ring_misc = 0x000001fc,
+	.hal_reo1_ring_hp_addr_lsb = 0x00000200,
+	.hal_reo1_ring_hp_addr_msb = 0x00000204,
+	.hal_reo1_ring_producer_int_setup = 0x00000210,
+	.hal_reo1_ring_msi1_base_lsb = 0x00000234,
+	.hal_reo1_ring_msi1_base_msb = 0x00000238,
+	.hal_reo1_ring_msi1_data = 0x0000023c,
+	.hal_reo2_ring_base_lsb = 0x00000244,
+	.hal_reo1_aging_thresh_ix_0 = 0x00000564,
+	.hal_reo1_aging_thresh_ix_1 = 0x00000568,
+	.hal_reo1_aging_thresh_ix_2 = 0x0000056c,
+	.hal_reo1_aging_thresh_ix_3 = 0x00000570,
+
+	/* REO2SW(x) R2 ring pointers (head/tail) address */
+	.hal_reo1_ring_hp = 0x00003028,
+	.hal_reo1_ring_tp = 0x0000302c,
+	.hal_reo2_ring_hp = 0x00003030,
+
+	/* REO2TCL R0 ring configuration address */
+	.hal_reo_tcl_ring_base_lsb = 0x000003fc,
+	.hal_reo_tcl_ring_hp = 0x00003058,
+
+	/* SW2REO ring address */
+	.hal_sw2reo_ring_base_lsb = 0x0000013c,
+	.hal_sw2reo_ring_hp = 0x00003018,
+
+	/* REO CMD ring address */
+	.hal_reo_cmd_ring_base_lsb = 0x000000e4,
+	.hal_reo_cmd_ring_hp = 0x00003010,
+
+	/* REO status address */
+	.hal_reo_status_ring_base_lsb = 0x00000504,
+	.hal_reo_status_hp = 0x00003070,
+
+	/* WCSS relative address */
+	.hal_seq_wcss_umac_ce0_src_reg = 0x03B80000,
+	.hal_seq_wcss_umac_ce0_dst_reg = 0x03b81000,
+	.hal_seq_wcss_umac_ce1_src_reg = 0x03b82000,
+	.hal_seq_wcss_umac_ce1_dst_reg = 0x03b83000,
+
+	/* WBM Idle address */
+	.hal_wbm_idle_link_ring_base_lsb = 0x00000874,
+	.hal_wbm_idle_link_ring_misc = 0x00000884,
+
+	/* SW2WBM release address */
+	.hal_wbm_release_ring_base_lsb = 0x000001ec,
+
+	/* WBM2SW release address */
+	.hal_wbm0_release_ring_base_lsb = 0x00000924,
+	.hal_wbm1_release_ring_base_lsb = 0x0000097c,
+};
+
 const struct ath11k_hw_hal_params ath11k_hw_hal_params_ipq8074 = {
 	.rx_buf_rbm = HAL_RX_BUF_RBM_SW3_BM,
 };
--- a/drivers/net/wireless/ath/ath11k/hw.h
+++ b/drivers/net/wireless/ath/ath11k/hw.h
@@ -92,9 +92,12 @@
 #define ATH11K_BOARD_API2_FILE		"board-2.bin"
 #define ATH11K_DEFAULT_BOARD_FILE	"board.bin"
 #define ATH11K_DEFAULT_CAL_FILE		"caldata.bin"
+#define ATH11K_QMI_DEF_CAL_FILE_PREFIX	"caldata_"
+#define ATH11K_QMI_DEF_CAL_FILE_SUFFIX	".bin"
 #define ATH11K_AMSS_FILE		"amss.bin"
 #define ATH11K_M3_FILE			"m3.bin"
 #define ATH11K_REGDB_FILE_NAME		"regdb.bin"
+#define NODE_ID_BASE                   	0x27
 
 enum ath11k_hw_rate_cck {
 	ATH11K_HW_RATE_CCK_LP_11M = 0,
@@ -123,6 +126,7 @@ enum ath11k_bus {
 };
 
 #define ATH11K_EXT_IRQ_GRP_NUM_MAX 11
+#define ATH11K_EXT_MSI_IRQ_GRP_MAX 8
 
 struct hal_rx_desc;
 struct hal_tcl_data_cmd;
@@ -222,6 +226,9 @@ struct ath11k_hw_params {
 	bool hybrid_bus_type;
 	bool fixed_fw_mem;
 	bool support_off_channel_tx;
+	bool internal_pci;
+	u8 ce_window;
+	u8 dp_window;
 };
 
 struct ath11k_hw_ops {
@@ -276,10 +283,12 @@ extern const struct ath11k_hw_ops qcn907
 extern const struct ath11k_hw_ops wcn6855_ops;
 extern const struct ath11k_hw_ops wcn6750_ops;
 extern const struct ath11k_hw_ops ipq5018_ops;
+extern const struct ath11k_hw_ops qcn6122_ops;
 
 extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_ipq8074;
 extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qca6390;
 extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn9074;
+extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn6122;
 
 extern const struct ath11k_hw_hal_params ath11k_hw_hal_params_ipq8074;
 extern const struct ath11k_hw_hal_params ath11k_hw_hal_params_qca6390;
@@ -410,6 +419,7 @@ extern const struct ath11k_hw_regs qcn90
 extern const struct ath11k_hw_regs wcn6855_regs;
 extern const struct ath11k_hw_regs wcn6750_regs;
 extern const struct ath11k_hw_regs ipq5018_regs;
+extern const struct ath11k_hw_regs qcn6122_regs;
 
 static inline const char *ath11k_bd_ie_type_str(enum ath11k_bd_ie_type type)
 {
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@ -53,32 +53,7 @@ static void ath11k_pci_bus_release(struc
 
 static u32 ath11k_pci_get_window_start(struct ath11k_base *ab, u32 offset)
 {
-	if (!ab->hw_params.static_window_map)
-		return ATH11K_PCI_WINDOW_START;
-
-	if ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) < ATH11K_PCI_WINDOW_RANGE_MASK)
-		/* if offset lies within DP register range, use 3rd window */
-		return 3 * ATH11K_PCI_WINDOW_START;
-	else if ((offset ^ HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab)) <
-		 ATH11K_PCI_WINDOW_RANGE_MASK)
-		 /* if offset lies within CE register range, use 2nd window */
-		return 2 * ATH11K_PCI_WINDOW_START;
-	else
-		return ATH11K_PCI_WINDOW_START;
-}
-
-static inline u32 ath11k_pci_get_window_offset(struct ath11k_base *ab,
-					       u32 offset)
-{
-	u32 window_start;
-
-	if (ab->hw_params.static_window_map) {
-		window_start = ath11k_pci_get_window_start(ab, offset);
-
-		if (window_start)
-			offset = window_start + (offset & ATH11K_PCI_WINDOW_RANGE_MASK);
-	}
-	return offset;
+	return ath11k_pcic_get_window_start(ab, offset, ATH11K_BUS_PCI);
 }
 
 static inline void ath11k_pci_select_window(struct ath11k_pci *ab_pci, u32 offset)
@@ -172,20 +147,6 @@ static const struct ath11k_msi_config ms
 	},
 };
 
-static inline void ath11k_pci_select_static_window(struct ath11k_pci *ab_pci)
-{
-	u32 umac_window;
-	u32 ce_window;
-	u32 window;
-
-	umac_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_SEQ_WCSS_UMAC_OFFSET);
-	ce_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_CE_WFSS_CE_REG_BASE);
-	window = (umac_window << 12) | (ce_window << 6);
-
-	iowrite32(ATH11K_PCI_WINDOW_ENABLE_BIT | window,
-		  ab_pci->ab->mem + ATH11K_PCI_WINDOW_REG_ADDRESS);
-}
-
 static void ath11k_pci_soc_global_reset(struct ath11k_base *ab)
 {
 	u32 val, delay;
@@ -393,6 +354,7 @@ static void ath11k_pci_init_qmi_ce_confi
 	cfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;
 	cfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;
 	ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
+	ab->qmi.service_ins_id += ab->userpd_id;
 
 	ret = of_property_read_u32(ab->dev->of_node, "qrtr_instance_id", &node_id);
 	if (!ret)
@@ -639,7 +601,7 @@ static int ath11k_pci_power_up(struct at
 	}
 
 	if (ab->hw_params.static_window_map)
-		ath11k_pci_select_static_window(ab_pci);
+		ath11k_pcic_config_static_window(ab);
 
 	return 0;
 }
--- a/drivers/net/wireless/ath/ath11k/pcic.c
+++ b/drivers/net/wireless/ath/ath11k/pcic.c
@@ -7,6 +7,10 @@
 #include "core.h"
 #include "pcic.h"
 #include "debug.h"
+#include "pci.h"
+#include <linux/msi.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
 
 const char *ce_irq_name[ATH11K_MAX_PCI_DOMAINS + 1][CE_COUNT_MAX] = {
 	{
@@ -85,6 +89,15 @@ static const struct ath11k_msi_config at
 		},
 		.hw_rev = ATH11K_HW_WCN6750_HW10,
 	},
+	{
+		.total_vectors = 13,
+		.total_users = 2,
+		.users = (struct ath11k_msi_user[]) {
+			{ .name = "CE", .num_vectors = 5, .base_vector = 0 },
+			{ .name = "DP", .num_vectors = 8, .base_vector = 5 },
+		},
+		.hw_rev = ATH11K_HW_QCN6122,
+	},
 };
 
 int ath11k_pcic_init_msi_config(struct ath11k_base *ab)
@@ -241,6 +254,15 @@ void ath11k_pcic_free_irq(struct ath11k_
 }
 EXPORT_SYMBOL(ath11k_pcic_free_irq);
 
+void ath11k_pcic_ipci_free_irq(struct ath11k_base *ab)
+{
+	struct platform_device *pdev = ab->pdev;
+
+	ath11k_pcic_free_irq(ab);
+	platform_msi_domain_free_irqs(&pdev->dev);
+}
+EXPORT_SYMBOL(ath11k_pcic_ipci_free_irq);
+
 static void ath11k_pcic_ce_irq_enable(struct ath11k_base *ab, u16 ce_id)
 {
 	u32 irq_idx;
@@ -650,7 +672,8 @@ EXPORT_SYMBOL(ath11k_pcic_stop);
 
 int ath11k_pcic_start(struct ath11k_base *ab)
 {
-	set_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags);
+	if (!ab->hw_params.internal_pci)
+		set_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags);
 
 	ath11k_pcic_ce_irqs_enable(ab);
 	ath11k_ce_rx_post_buf(ab);
@@ -710,7 +733,7 @@ int ath11k_pcic_register_pci_ops(struct
 		return 0;
 
 	/* Return error if mandatory pci_ops callbacks are missing */
-	if (!pci_ops->get_msi_irq || !pci_ops->window_write32 ||
+	if (!pci_ops->window_write32 ||
 	    !pci_ops->window_read32)
 		return -EINVAL;
 
@@ -718,3 +741,258 @@ int ath11k_pcic_register_pci_ops(struct
 	return 0;
 }
 EXPORT_SYMBOL(ath11k_pcic_register_pci_ops);
+
+void ath11k_pcic_select_static_window(struct ath11k_base *ab)
+{
+	u32 umac_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_SEQ_WCSS_UMAC_OFFSET);
+	u32 ce_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_CE_WFSS_CE_REG_BASE);
+	u32 window;
+
+	window = (umac_window << 12) | (ce_window << 6);
+
+	iowrite32(ATH11K_PCI_WINDOW_ENABLE_BIT | window,
+		  ab->mem + ATH11K_PCI_WINDOW_REG_ADDRESS);
+}
+
+void ath11k_pcic_config_static_window(struct ath11k_base *ab)
+{
+	if (ab->hw_params.static_window_map)
+		ath11k_pcic_select_static_window(ab);
+}
+EXPORT_SYMBOL(ath11k_pcic_config_static_window);
+
+int ath11k_pcic_ext_config_gic_msi_irq(struct ath11k_base *ab, struct platform_device *pdev,
+				      struct msi_desc *msi_desc, int i)
+{
+	u32 user_base_data = 0, base_vector = 0, base_idx;
+	struct ath11k_ext_irq_grp *irq_grp;
+	int j, ret = 0, num_vectors = 0;
+	u32 num_irq = 0;
+
+	base_idx = ATH11K_PCI_IRQ_CE0_OFFSET + CE_COUNT_MAX;
+	ret = ath11k_pcic_get_user_msi_assignment(ab, "DP", &num_vectors,
+						 &user_base_data, &base_vector);
+	if (ret < 0)
+		return ret;
+
+	irq_grp = &ab->ext_irq_grp[i];
+	irq_grp->ab = ab;
+	irq_grp->grp_id = i;
+	init_dummy_netdev(&irq_grp->napi_ndev);
+	netif_napi_add(&irq_grp->napi_ndev, &irq_grp->napi,
+		       ath11k_pcic_ext_grp_napi_poll, NAPI_POLL_WEIGHT);
+
+	if (ab->hw_params.ring_mask->tx[i] ||
+	    ab->hw_params.ring_mask->rx[i] ||
+	    ab->hw_params.ring_mask->rx_err[i] ||
+	    ab->hw_params.ring_mask->rx_wbm_rel[i] ||
+	    ab->hw_params.ring_mask->reo_status[i] ||
+	    ab->hw_params.ring_mask->rxdma2host[i] ||
+	    ab->hw_params.ring_mask->host2rxdma[i] ||
+	    ab->hw_params.ring_mask->rx_mon_status[i]) {
+		num_irq = 1;
+	}
+
+	irq_grp->num_irq = num_irq;
+	irq_grp->irqs[0] = base_idx + i;
+
+	for (j = 0; j < irq_grp->num_irq; j++) {
+		int irq_idx = irq_grp->irqs[j];
+		int vector = (i % num_vectors);
+
+		irq_set_status_flags(msi_desc->irq, IRQ_DISABLE_UNLAZY);
+		ret = devm_request_irq(&pdev->dev, msi_desc->irq,
+				       ath11k_pcic_ext_interrupt_handler,
+				       IRQF_SHARED, dp_irq_name[ab->userpd_id][i],
+				       irq_grp);
+		if (ret) {
+			ath11k_err(ab, "failed request irq %d: %d\n",
+				   irq_idx, ret);
+			return ret;
+		}
+		ab->irq_num[irq_idx] = msi_desc->irq;
+		ab->ipci.dp_irq_num[vector] = msi_desc->irq;
+		ab->ipci.dp_msi_data[i] = msi_desc->msg.data;
+		disable_irq_nosync(ab->irq_num[irq_idx]);
+	}
+	return ret;
+}
+
+int ath11k_pcic_config_gic_msi_irq(struct ath11k_base *ab, struct platform_device *pdev,
+				  struct msi_desc *msi_desc, int i)
+{
+	struct ath11k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];
+	int irq_idx, ret;
+
+	tasklet_setup(&ce_pipe->intr_tq, ath11k_pcic_ce_tasklet);
+	irq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + i;
+
+	ret = devm_request_irq(&pdev->dev, msi_desc->irq,
+			       ath11k_pcic_ce_interrupt_handler,
+			       IRQF_SHARED, ce_irq_name[ab->userpd_id][i],
+			       ce_pipe);
+	if (ret) {
+		ath11k_warn(ab, "failed to request irq %d: %d\n",
+			    irq_idx, ret);
+		return ret;
+	}
+	ab->irq_num[irq_idx] = msi_desc->irq;
+	ab->ipci.ce_msi_data[i] = msi_desc->msg.data;
+	ath11k_pcic_ce_irq_disable(ab, i);
+
+	return ret;
+}
+
+static void ath11k_msi_msg_handler(struct msi_desc *desc, struct msi_msg *msg)
+{
+	desc->msg.address_lo = msg->address_lo;
+	desc->msg.address_hi = msg->address_hi;
+	desc->msg.data = msg->data;
+}
+
+int ath11k_pcic_ipci_config_irq(struct ath11k_base *ab)
+{
+	int ret;
+	struct platform_device *pdev = ab->pdev;
+	struct msi_desc *msi_desc;
+	bool ce_done = false;
+	int i = 0;
+
+	if (ab->userpd_id != QCN6122_USERPD_0 &&
+	    ab->userpd_id != QCN6122_USERPD_1) {
+		ath11k_warn(ab, "ath11k userpd invalid %d\n", ab->userpd_id);
+		return -ENODEV;
+	}
+
+	ret = ath11k_pcic_init_msi_config(ab);
+	if (ret) {
+		ath11k_err(ab, "failed to fetch msi config: %d\n", ret);
+		return ret;
+	}
+
+	ret = platform_msi_domain_alloc_irqs(&pdev->dev, ab->pci.msi.config->total_vectors,
+					     ath11k_msi_msg_handler);
+	if (ret) {
+		ath11k_warn(ab, "failed to alloc irqs %d ab %pM\n", ret, ab);
+		return ret;
+	}
+
+	for_each_msi_entry(msi_desc, &pdev->dev) {
+		if (!ce_done && i == ab->hw_params.ce_count) {
+			i = 0;
+			ce_done = true;
+		}
+
+		if (!ce_done && i < ab->hw_params.ce_count) {
+			if (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
+				i++;
+
+			ret = ath11k_pcic_config_gic_msi_irq(ab, pdev, msi_desc, i);
+			if (ret) {
+				ath11k_warn(ab, "failed to request irq %d\n", ret);
+				return ret;
+			}
+		} else {
+			ret = ath11k_pcic_ext_config_gic_msi_irq(ab, pdev, msi_desc, i);
+			if (ret) {
+				ath11k_warn(ab, "failed to config ext msi irq %d\n", ret);
+				return ret;
+			}
+		}
+
+		i++;
+		ab->pci.msi.addr_lo = msi_desc->msg.address_lo;
+		ab->pci.msi.addr_hi = msi_desc->msg.address_hi;
+
+		if (i == 0 && !ce_done)
+			ab->pci.msi.ep_base_data = msi_desc->msg.data;
+	}
+
+	for_each_msi_entry(msi_desc, &pdev->dev) {
+		u32 user_base_data = 0, base_vector = 0;
+		int vector, num_vectors = 0;
+
+		ret = ath11k_pcic_get_user_msi_assignment(ab, "DP", &num_vectors,
+							 &user_base_data, &base_vector);
+		if (ret < 0)
+			return ret;
+
+		vector = (i % num_vectors);
+
+		if (i >= ATH11K_EXT_IRQ_GRP_NUM_MAX)
+			break;
+
+		if (ab->ipci.dp_irq_num[vector] != msi_desc->irq)
+			continue;
+
+		ret = ath11k_pcic_ext_config_gic_msi_irq(ab, pdev, msi_desc, i);
+		if (ret) {
+			ath11k_warn(ab, "failed to config ext msi irq %d\n", ret);
+			return ret;
+		}
+
+		i++;
+	}
+
+	ab->ipci.gic_enabled = 1;
+	wake_up(&ab->ipci.gic_msi_waitq);
+	return ret;
+}
+EXPORT_SYMBOL(ath11k_pcic_ipci_config_irq);
+
+u32 ath11k_pcic_get_window_start(struct ath11k_base *ab, u32 offset,
+				 enum ath11k_bus bus)
+{
+	u32 window_start = 0;
+
+	if (bus == ATH11K_BUS_PCI) {
+        	if (!ab->hw_params.static_window_map)
+        		return ATH11K_PCI_WINDOW_START;
+
+		/* if offset lies within DP register range, use 3rd window */
+		if ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) <
+		    ATH11K_PCI_WINDOW_RANGE_MASK)
+			window_start = 3 * ATH11K_PCI_WINDOW_START;
+		/* if offset lies within CE register range, use 2nd window */
+		else if ((offset ^ HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab)) <
+			 ATH11K_PCI_WINDOW_RANGE_MASK)
+			window_start = 2 * ATH11K_PCI_WINDOW_START;
+		else
+			window_start = ATH11K_PCI_WINDOW_START;
+	} else if (bus == ATH11K_BUS_AHB) {
+		/* If offset lies within DP register range, use 1st window */
+		if ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) <
+		    ATH11K_PCI_WINDOW_RANGE_MASK)
+			window_start =
+			      ab->hw_params.dp_window * ATH11K_PCI_WINDOW_START;
+		/* If offset lies within CE register range, use 2nd window */
+		else if ((offset ^ HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab)) <
+			 ATH11K_PCI_WINDOW_RANGE_MASK)
+			window_start =
+			      ab->hw_params.ce_window * ATH11K_PCI_WINDOW_START;
+		else
+			window_start = ATH11K_PCI_WINDOW_START;
+	}
+	else {
+		/* Must not come here */
+		WARN_ON(1);
+	}
+
+	return window_start;
+}
+EXPORT_SYMBOL(ath11k_pcic_get_window_start);
+
+u32 ath11k_pci_get_window_offset(struct ath11k_base *ab, u32 offset)
+{
+	u32 window_start;
+
+	if (ab->hw_params.static_window_map) {
+		window_start = ath11k_pcic_get_window_start(ab, offset,
+			       ATH11K_BUS_PCI);
+
+		if (window_start)
+			offset = window_start + (offset & ATH11K_PCI_WINDOW_RANGE_MASK);
+	}
+	return offset;
+}
+EXPORT_SYMBOL(ath11k_pci_get_window_offset);
--- a/drivers/net/wireless/ath/ath11k/pcic.h
+++ b/drivers/net/wireless/ath/ath11k/pcic.h
@@ -75,4 +75,11 @@ void ath11k_pcic_ce_irq_disable_sync(str
 int ath11k_pcic_init_msi_config(struct ath11k_base *ab);
 int ath11k_pcic_register_pci_ops(struct ath11k_base *ab,
 				 const struct ath11k_pci_ops *pci_ops);
+void ath11k_pcic_select_static_window(struct ath11k_base *ab);
+void ath11k_pcic_ipci_free_irq(struct ath11k_base *ab);
+int ath11k_pcic_ipci_config_irq(struct ath11k_base *ab);
+void ath11k_pcic_config_static_window(struct ath11k_base *ab);
+u32 ath11k_pcic_get_window_start(struct ath11k_base *ab, u32 offset,
+				 enum ath11k_bus bus);
+u32 ath11k_pci_get_window_offset(struct ath11k_base *ab, u32 offset);
 #endif
--- a/drivers/net/wireless/ath/ath11k/qmi.c
+++ b/drivers/net/wireless/ath/ath11k/qmi.c
@@ -7,7 +7,7 @@
 #include <linux/elf.h>
 
 #include "qmi.h"
-#include "core.h"
+#include "hif.h"
 #include "debug.h"
 #include "hif.h"
 #include <linux/of.h>
@@ -2898,6 +2898,10 @@ static int ath11k_qmi_assign_target_mem_
 			idx++;
 			break;
 		case BDF_MEM_REGION_TYPE:
+			if (!of_property_read_u32(ab->dev->of_node, "qcom,bdf-addr",
+						  &addr))
+				ab->hw_params.bdf_addr = (u32)addr;
+
 			ab->qmi.target_mem[idx].paddr = ab->hw_params.bdf_addr;
 			ab->qmi.target_mem[idx].vaddr = NULL;
 			ab->qmi.target_mem[idx].size = ab->qmi.target_mem[i].size;
@@ -2918,6 +2922,10 @@ static int ath11k_qmi_assign_target_mem_
 				} else if (ath11k_host_ddr_addr) {
 					ab->qmi.target_mem[idx].paddr = ath11k_host_ddr_addr +
 						ATH11K_HOST_DDR_CALDB_OFFSET;
+				} else if (of_property_read_u32(ab->dev->of_node,
+								"qcom,caldb-addr",
+								&addr)) {
+					ab->qmi.target_mem[idx].paddr = (u32)addr;
 				} else {
 					ab->qmi.target_mem[idx].paddr =
 						ATH11K_QMI_CALDB_ADDRESS;
@@ -2981,7 +2989,7 @@ static int ath11k_qmi_request_device_inf
 	int ret;
 
 	/* device info message req is only sent for hybrid bus devices */
-	if (!ab->hw_params.hybrid_bus_type)
+	if (!ab->hw_params.hybrid_bus_type && !ab->hw_params.internal_pci)
 		return 0;
 
 	ret = qmi_txn_init(&ab->qmi.handle, &txn,
@@ -3039,8 +3047,15 @@ static int ath11k_qmi_request_device_inf
 	}
 
 	ab->mem = bar_addr_va;
+	ab->mem_pa = resp.bar_addr;
 	ab->mem_len = resp.bar_size;
 
+	if (ab->hw_params.internal_pci)
+		ath11k_hif_config_static_window(ab);
+
+	ath11k_dbg(ab, ATH11K_DBG_QMI, "Device BAR Info pa: %pad, size: 0x%lx\n",
+		   &ab->mem_pa, ab->mem_len);
+
 	return 0;
 out:
 	return ret;
@@ -3318,10 +3333,27 @@ static int ath11k_qmi_load_bdf_qmi(struc
 		fw_size = ATH11K_QMI_MAX_BDF_FILE_NAME_SIZE;
 	} else {
 		file_type = ATH11K_QMI_FILE_TYPE_CALDATA;
-
 		/* cal-<bus>-<id>.bin */
 		snprintf(filename, sizeof(filename), "cal-%s-%s.bin",
 			 ath11k_bus_str(ab->hif.bus), dev_name(dev));
+
+		if (ab->hw_params.fixed_bdf_addr) {
+			snprintf(filename, sizeof(filename), "%s",
+				 ATH11K_DEFAULT_CAL_FILE);
+
+			if (ab->hw_params.internal_pci) {
+				snprintf(filename, sizeof(filename), "%s%d%s",
+					 ATH11K_QMI_DEF_CAL_FILE_PREFIX,
+					 ab->userpd_id,
+					 ATH11K_QMI_DEF_CAL_FILE_SUFFIX);
+			}
+		} else {
+			snprintf(filename, sizeof(filename), "%s%d%s",
+				 ATH11K_QMI_DEF_CAL_FILE_PREFIX,
+				 ab->qmi.service_ins_id - (NODE_ID_BASE - 1),
+				 ATH11K_QMI_DEF_CAL_FILE_SUFFIX);
+		}
+
 		fw_entry = ath11k_core_firmware_request(ab, filename);
 		if (!IS_ERR(fw_entry))
 			goto success;
@@ -3996,6 +4028,25 @@ int ath11k_qmi_pci_alloc_qdss_mem(struct
 	return 0;
 }
 
+static
+struct device_node *ath11k_get_etr_dev_node(struct ath11k_base *ab)
+{
+	struct device_node *dev_node = NULL;
+
+	if (ab->userpd_id) {
+		if (ab->userpd_id == QCN6122_USERPD_0)
+			dev_node = of_find_node_by_name(NULL,
+							"q6_qcn6122_etr_1");
+		else if (ab->userpd_id == QCN6122_USERPD_1)
+			dev_node = of_find_node_by_name(NULL,
+							"q6_qcn6122_etr_2");
+	} else {
+		dev_node = of_find_node_by_name(NULL, "q6_etr_dump");
+	}
+
+	return dev_node;
+}
+
 int ath11k_qmi_qdss_mem_alloc(struct ath11k_qmi *qmi)
 {
 	int ret, i;
@@ -4004,7 +4055,7 @@ int ath11k_qmi_qdss_mem_alloc(struct ath
 	struct resource q6_etr;
 
 	if (ab->hw_params.fixed_bdf_addr) {
-		dev_node = of_find_node_by_name(NULL, "q6_etr_dump");
+		dev_node = ath11k_get_etr_dev_node(ab);
 		if (!dev_node) {
 			ath11k_err(ab, "No q6_etr_dump available in dts\n");
 			return -ENOMEM;
@@ -4019,6 +4070,19 @@ int ath11k_qmi_qdss_mem_alloc(struct ath
 			ab->qmi.qdss_mem[i].paddr = q6_etr.start;
 			ab->qmi.qdss_mem[i].size = resource_size(&q6_etr);
 			ab->qmi.qdss_mem[i].type = QDSS_ETR_MEM_REGION_TYPE;
+			if (ab->hw_rev == ATH11K_HW_QCN6122) {
+				ab->qmi.qdss_mem[i].vaddr =
+					ioremap(ab->qmi.qdss_mem[i].paddr,
+						ab->qmi.qdss_mem[i].size);
+				if (!ab->qmi.qdss_mem[i].vaddr) {
+					ath11k_err(ab, "Error: etr-addr remap failed\n");
+					return -ENOMEM;
+				}
+			}
+			ath11k_dbg(ab, ATH11K_DBG_QMI, "QDSS mem addr pa 0x%x va 0x%p, size 0x%x",
+				   (unsigned int)ab->qmi.qdss_mem[i].paddr,
+				   ab->qmi.qdss_mem[i].vaddr,
+				   (unsigned int)ab->qmi.qdss_mem[i].size);
 		}
 	} else {
 		ret = ath11k_qmi_pci_alloc_qdss_mem(qmi);
@@ -4584,6 +4648,23 @@ static const struct qmi_ops ath11k_qmi_o
 	.del_server = ath11k_qmi_ops_del_server,
 };
 
+static int ath11k_wait_for_gic_msi(struct ath11k_base *ab)
+{
+	int timeout;
+
+	if (ab->hw_rev != ATH11K_HW_QCN6122)
+		return 0;
+
+	timeout = wait_event_timeout(ab->ipci.gic_msi_waitq,
+				     (ab->ipci.gic_enabled == 1),
+				     ATH11K_RCV_GIC_MSI_HDLR_DELAY);
+	if (timeout <= 0) {
+		ath11k_warn(ab, "Receive gic msi handler timed out\n");
+		return -ETIMEDOUT;
+	}
+	return 0;
+}
+
 static void ath11k_qmi_driver_event_work(struct work_struct *work)
 {
 	struct ath11k_qmi *qmi = container_of(work, struct ath11k_qmi,
@@ -4649,6 +4730,14 @@ static void ath11k_qmi_driver_event_work
 				clear_bit(ATH11K_FLAG_CRASH_FLUSH,
 					  &ab->dev_flags);
 				clear_bit(ATH11K_FLAG_RECOVERY, &ab->dev_flags);
+				ret = ath11k_wait_for_gic_msi(ab);
+				if (ret) {
+					ath11k_warn(ab,
+					"Failed to get qgic handler for dev %d ret: %d\n",
+						    ab->hw_rev, ret);
+					break;
+				}
+
 				ret = ath11k_core_qmi_firmware_ready(ab);
 				if (ret) {
 					set_bit(ATH11K_FLAG_QMI_FAIL, &ab->dev_flags);
@@ -4775,6 +4864,7 @@ int ath11k_qmi_init_service(struct ath11
 		return ret;
 	}
 
+	init_waitqueue_head(&ab->ipci.gic_msi_waitq);
 	return ret;
 }
 
--- a/drivers/net/wireless/ath/ath11k/qmi.h
+++ b/drivers/net/wireless/ath/ath11k/qmi.h
@@ -24,6 +24,7 @@
 #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074	0x02
 #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN9074	0x07
 #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_WCN6750	0x03
+#define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6122	0x40
 #define ATH11K_QMI_WLANFW_MAX_TIMESTAMP_LEN_V01	32
 #define ATH11K_QMI_RESP_LEN_MAX			8192
 #define ATH11K_QMI_WLANFW_MAX_NUM_MEM_SEG_V01	52
@@ -67,6 +68,8 @@
 #define ATH11K_COLD_BOOT_FW_RESET_DELAY		(60 * HZ)
 
 #define ATH11K_QMI_DEVICE_BAR_SIZE		0x200000
+#define ATH11K_RCV_GIC_MSI_HDLR_DELAY 		(3 * HZ)
+#define ATH11K_QMI_QCN6122_M3_DUMP_ADDRESS	0x4E200000
 
 struct ath11k_base;
 extern unsigned int ath11k_host_ddr_addr;
--- a/drivers/net/wireless/ath/ath11k/nss.c
+++ b/drivers/net/wireless/ath/ath11k/nss.c
@@ -2164,6 +2164,8 @@ static int ath11k_nss_get_target_type(st
 		return ATH11K_WIFILI_TARGET_TYPE_QCN9074;
 	case ATH11K_HW_IPQ5018:
 		return ATH11K_WIFILI_TARGET_TYPE_QCA5018;
+	case ATH11K_HW_QCN6122:
+		return ATH11K_WIFILI_TARGET_TYPE_QCN6122;
 	default:
 		ath11k_warn(ab, "NSS Offload not supported for this HW\n");
 		return ATH11K_WIFILI_TARGET_TYPE_UNKNOWN;
@@ -2178,6 +2180,7 @@ static int ath11k_nss_get_interface_type
 	case ATH11K_HW_IPQ5018:
 		return NSS_WIFILI_INTERNAL_INTERFACE;
 	case ATH11K_HW_QCN9074_HW10:
+	case ATH11K_HW_QCN6122:
 		return nss_get_available_wifili_external_if();
 	default:
 		/* This can't happen since we validated target type earlier */
--- a/drivers/net/wireless/ath/ath11k/nss.h
+++ b/drivers/net/wireless/ath/ath11k/nss.h
@@ -32,6 +32,7 @@ struct hal_rx_user_status;
 #define ATH11K_WIFILI_TARGET_TYPE_QCA6018   25
 #define ATH11K_WIFILI_TARGET_TYPE_QCN9074   26
 #define ATH11K_WIFILI_TARGET_TYPE_QCA5018   29
+#define ATH11K_WIFILI_TARGET_TYPE_QCN6122   30
 
 /* Max limit for NSS Queue */
 #define ATH11K_WIFIILI_MAX_TX_PROCESSQ 1024
